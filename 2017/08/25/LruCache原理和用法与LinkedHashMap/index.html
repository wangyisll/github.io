<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>LruCache原理和用法与LinkedHashMap | 喵了个呜的小宇宙</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LruCache原理和用法与LinkedHashMap</h1><a id="logo" href="/.">喵了个呜的小宇宙</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">LruCache原理和用法与LinkedHashMap</h1><div class="post-meta"><span class="date">Aug 25, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/2017/08/25/LruCache原理和用法与LinkedHashMap/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><h1 id="一-LruCache算法"><a href="#一-LruCache算法" class="headerlink" title="一.LruCache算法"></a>一.LruCache算法</h1><p>LruCache算法就是Least Recently Used，也就是最近最少使用算法。</p>
<p>他的算法就是当缓存空间满了的时候，将最近最少使用的数据从缓存空间中删除以增加可用的缓存空间来缓存新内容。</p>
<p>这个算分的内部有一个缓存列表。每当一个缓存数据被访问的时候，这个数据就会被提到列表头部，每次都这样的话，列表的尾部数据就是最近最不常使用的了，当缓存空间不足时，就会删除列表尾部的缓存数据。</p>
<a id="more"></a>
<h1 id="二-LruCache部分源码"><a href="#二-LruCache部分源码" class="headerlink" title="二.LruCache部分源码"></a>二.LruCache部分源码</h1><p>Least Recently Used，最近最少使用<br>下面只是部分源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div></pre></td><td class="code"><pre><div class="line">package android.util;</div><div class="line"></div><div class="line">import java.util.LinkedHashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line">/**</div><div class="line"> * LruCache通过强引用来缓存一定数量的值. </div><div class="line"> * 每当一个值被访问的时候，这个值就会移动到缓存队列的头部.        </div><div class="line"> * 如果插入数据时发现缓存不够了，就会将队列中访问次数最少的数据删掉.</div><div class="line"> * 可以设置缓存大小：设为4M</div><div class="line"> * &lt;pre&gt;   &#123;@code</div><div class="line"> *   int cacheSize = 4 * 1024 * 1024; // 4MiB</div><div class="line"> *   LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line"> *       protected int sizeOf(String key, Bitmap value) &#123;</div><div class="line"> *           return value.getByteCount();</div><div class="line"> *       &#125;</div><div class="line"> *   &#125;&#125;&lt;/pre&gt;</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class LruCache&lt;K, V&gt; &#123;</div><div class="line">    /**</div><div class="line">     * 真正放置缓存内容的map。</div><div class="line">     */</div><div class="line">    private final LinkedHashMap&lt;K, V&gt; map;</div><div class="line"></div><div class="line">    /** Size of this cache in units. Not necessarily the number of elements.</div><div class="line">     * 当前缓存已经使用用的大小，不一定是元素的个数。*/</div><div class="line">    private int size;</div><div class="line">    /** 内存的最大值 */</div><div class="line">    private int maxSize;</div><div class="line"></div><div class="line">    //各个方法被调用的次数</div><div class="line">    private int putCount;</div><div class="line">    private int createCount;</div><div class="line">    private int evictionCount;</div><div class="line">    private int hitCount;</div><div class="line">    private int missCount;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *            构造方法，传入缓存的最大值maxSize。</div><div class="line">     */</div><div class="line">    public LruCache(int maxSize) &#123;</div><div class="line">        if (maxSize &lt;= 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</div><div class="line">        &#125;</div><div class="line">        this.maxSize = maxSize;</div><div class="line">        //初始化LinkedHashMap。</div><div class="line">        //第一个参数是初始容量</div><div class="line">        //第二个参数是填装因子，或叫加载因子</div><div class="line">        //第三个参数是排序模式，true表示在访问的时候进行排序，否则只在插入的时候才排序。</div><div class="line">        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 重新设置最大缓存</div><div class="line">     */</div><div class="line">    public void resize(int maxSize) &#123;</div><div class="line">        if (maxSize &lt;= 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            this.maxSize = maxSize;</div><div class="line">        &#125;</div><div class="line">        trimToSize(maxSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通过key获取缓存的数据，如果通过这个方法得到的需要的元素，</div><div class="line">     * 那么这个元素会被放在缓存队列的头部，</div><div class="line">     * 可以理解成最近常用的元素，不会在缓存空间不够的时候自动清理掉</div><div class="line">     */</div><div class="line">    public final V get(K key) &#123;</div><div class="line">        if (key == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;key == null&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        V mapValue;</div><div class="line">        //这里用同步代码块，</div><div class="line">        synchronized (this) &#123;</div><div class="line">            //从LinkedHashMap中获取数据。</div><div class="line">            mapValue = map.get(key);</div><div class="line">            if (mapValue != null) &#123;</div><div class="line">                hitCount++;</div><div class="line">                return mapValue;</div><div class="line">            &#125;</div><div class="line">            missCount++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       </div><div class="line">        /**</div><div class="line">         * 如果通过key从缓存集合中获取不到缓存数据，就尝试使用creat(key)方法创造一个新数据。</div><div class="line">         * create(key)默认返回的也是null，需要的时候可以重写这个方法。</div><div class="line">         */</div><div class="line">         </div><div class="line">        V createdValue = create(key);</div><div class="line">        if (createdValue == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果重写了create(key)方法，创建了新的数据，就讲新数据放入缓存中。</div><div class="line">        synchronized (this) &#123;</div><div class="line">            createCount++;</div><div class="line">            mapValue = map.put(key, createdValue);</div><div class="line"></div><div class="line">            if (mapValue != null) &#123;</div><div class="line">                // There was a conflict so undo that last put</div><div class="line">                map.put(key, mapValue);</div><div class="line">            &#125; else &#123;</div><div class="line">                size += safeSizeOf(key, createdValue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mapValue != null) &#123;</div><div class="line">            entryRemoved(false, key, createdValue, mapValue);</div><div class="line">            return mapValue;</div><div class="line">        &#125; else &#123;</div><div class="line">            trimToSize(maxSize);</div><div class="line">            return createdValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 往缓存中添加数据</div><div class="line">     */</div><div class="line">    public final V put(K key, V value) &#123;</div><div class="line">        if (key == null || value == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;key == null || value == null&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        V previous;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            putCount++;</div><div class="line">            //safeSizeOf(key, value)。</div><div class="line">            // 这个方法返回的是1，也就是将缓存的个数加1.</div><div class="line">            // 当缓存的是图片的时候，这个size应该表示图片占用的内存的大小，</div><div class="line">            // 所以应该重写里面调用的sizeOf(key, value)方法</div><div class="line">            size += safeSizeOf(key, value);</div><div class="line">            //将创建的新元素添加进缓存队列，并添加成功后返回这个元素</div><div class="line">            previous = map.put(key, value);</div><div class="line">            if (previous != null) &#123;</div><div class="line">                //如果返回的是null，说明添加缓存失败，在已用缓存大小中减去这个元素的大小。</div><div class="line">                size -= safeSizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (previous != null) &#123;</div><div class="line">            entryRemoved(false, key, previous, value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        trimToSize(maxSize);</div><div class="line">        return previous;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 修改缓存大小，使已用的缓存不大于设置的缓存最大值</div><div class="line">     */</div><div class="line">    public void trimToSize(int maxSize) &#123;</div><div class="line">        while (true) &#123; //开启一个死循环</div><div class="line">            K key;</div><div class="line">            V value;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</div><div class="line">                    throw new IllegalStateException(getClass().getName()</div><div class="line">                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //当已用的缓存小于最大缓存，完成任务，退出循环</div><div class="line">                if (size &lt;= maxSize) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //否则就在缓存队列中先找到最近最少使用的元素，调用LinkedHashMap的eldest()方法返回最不经常使用的方法。</div><div class="line">                Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class="line">                if (toEvict == null) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                //然后删掉这个元素，并减少已使用的缓存空间</div><div class="line">                key = toEvict.getKey();</div><div class="line">                value = toEvict.getValue();</div><div class="line">                map.remove(key);</div><div class="line">                size -= safeSizeOf(key, value);</div><div class="line">                evictionCount++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            entryRemoved(true, key, value, null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除 很简单</div><div class="line">     */</div><div class="line">    public final V remove(K key) &#123;</div><div class="line">        if (key == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;key == null&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        V previous;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            previous = map.remove(key);</div><div class="line">            if (previous != null) &#123;</div><div class="line">                size -= safeSizeOf(key, previous);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (previous != null) &#123;</div><div class="line">            entryRemoved(false, key, previous, null);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return previous;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 这个方法在前面很多地方都会被调用，默认是空方法，有需要的时候自己实现</div><div class="line">     * evicted如果是true，则表示这个元素是因为空间不够而被自动清理了，</div><div class="line">     * 所以可以在这个地方对这个被清理的元素进行再次缓存</div><div class="line">     */</div><div class="line">    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 一个空方法，也是在需要的时候重写实现</div><div class="line">     */</div><div class="line">    protected V create(K key) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int safeSizeOf(K key, V value) &#123;</div><div class="line">        int result = sizeOf(key, value);</div><div class="line">        if (result &lt; 0) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 这个方法可以说是用来定义已用缓存的数量算法，默认是返回数量</div><div class="line">     */</div><div class="line">    protected int sizeOf(K key, V value) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 清空所有缓存</div><div class="line">     */</div><div class="line">    public final void evictAll() &#123;</div><div class="line">        trimToSize(-1); // -1 will evict 0-sized elements</div><div class="line">    &#125;</div><div class="line"></div><div class="line">.......</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个源码，可以发现，LruCache的算法实现主要是依靠LinkedHashMap来实现的。</p>
<h1 id="三-为什么用LinkedHashMap"><a href="#三-为什么用LinkedHashMap" class="headerlink" title="三.为什么用LinkedHashMap"></a>三.为什么用LinkedHashMap</h1><p>为什么要用LinkedHashMap来存缓存呢，这个跟算法有关，LinkedHashMap刚好能提供LRUCache需要的算法。</p>
<p>这个集合内部本来就有个排序功能，当第三个参数是true的时候，数据在被访问的时候就会排序，这个排序的结果就是把最近访问的数据放到集合的最后面。</p>
<p>到时候删除的时候就从前面开始删除。</p>
<h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h2><p>LinkedHashMap有个构造方法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</div><div class="line">     * specified initial capacity, load factor and ordering mode.</div><div class="line">     *</div><div class="line">     * @param  initialCapacity the initial capacity</div><div class="line">     * @param  loadFactor      the load factor</div><div class="line">     * @param  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</div><div class="line">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</div><div class="line">     * @throws IllegalArgumentException if the initial capacity is negative</div><div class="line">     *         or the load factor is nonpositive</div><div class="line">     */</div><div class="line">    public LinkedHashMap(int initialCapacity,</div><div class="line">                         float loadFactor,</div><div class="line">                         boolean accessOrder) &#123;</div><div class="line">        super(initialCapacity, loadFactor);</div><div class="line">        this.accessOrder = accessOrder;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-Entity的定义"><a href="#2-Entity的定义" class="headerlink" title="2.Entity的定义"></a>2.Entity的定义</h2><p>LinkedHashMap内部是使用双向循环链表来存储数据的。也就是每一个元素都持有他上一个元素的地址和下一个元素的地址，看Entity的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * LinkedHashMap entry.</div><div class="line">     */</div><div class="line">    private static class LinkedHashMapEntry&lt;K,V&gt; extends HashMapEntry&lt;K,V&gt; &#123;</div><div class="line">        // These fields comprise the doubly linked list used for iteration.</div><div class="line">        LinkedHashMapEntry&lt;K,V&gt; before, after;</div><div class="line"></div><div class="line">        LinkedHashMapEntry(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123;</div><div class="line">            super(hash, key, value, next);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 从链表中删除这个元素</div><div class="line">         */</div><div class="line">        private void remove() &#123;</div><div class="line">            before.after = after;</div><div class="line">            after.before = before;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Inserts this entry before the specified existing entry in the list.</div><div class="line">         */</div><div class="line">        private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123;</div><div class="line">            after  = existingEntry;</div><div class="line">            before = existingEntry.before;</div><div class="line">            before.after = this;</div><div class="line">            after.before = this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 当集合的get方法被调用时，会调用这个方法。</div><div class="line">         * 如果accessOrder为true，就把这个元素放在集合的最末端。</div><div class="line">         */</div><div class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;</div><div class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">            if (lm.accessOrder) &#123;</div><div class="line">                lm.modCount++;</div><div class="line">                remove();</div><div class="line">                addBefore(lm.header);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;</div><div class="line">            remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-get方法的排序过程"><a href="#3-get方法的排序过程" class="headerlink" title="3.get方法的排序过程"></a>3.get方法的排序过程</h2><p>看LinkedHashMap的get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key);</div><div class="line">        if (e == null)</div><div class="line">            return null;</div><div class="line">        e.recordAccess(this);</div><div class="line">        return e.value;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>具体是怎么进行排序的，画个图看看：</p>
<ol>
<li>当LinkedHashMap初始化的时候，会有一个头节点header。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void init() &#123;</div><div class="line">        header = new LinkedHashMapEntry&lt;&gt;(-1, null, null, null);</div><div class="line">        header.before = header.after = header;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到这个头节点的前节点和后节点都指向自己。</p>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Android/lru1.png" alt="image"></p>
<ol>
<li>添加一个数据A</li>
</ol>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Android/lru2.png" alt="image"></p>
<ol>
<li>添加一个数据B</li>
</ol>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Android/lru3.png" alt="image"></p>
<ol>
<li>再添加一个数据C</li>
</ol>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Android/lru4.png" alt="image"></p>
<ol>
<li>这是通过get访问数据B</li>
</ol>
<p>看上面的get方法就知道，他会调用B的recordAccess(this)方法,这个this就是这个LinkedHashMap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;</div><div class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">            if (lm.accessOrder) &#123;</div><div class="line">                lm.modCount++;</div><div class="line">                remove();</div><div class="line">                addBefore(lm.header);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<ol>
<li>recordAccess(this)方法<br>会先调用remove方法，把自己从链表中移除：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private void remove() &#123;</div><div class="line">            before.after = after;</div><div class="line">            after.before = before;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Android/lru5.png" alt="image"></p>
<p>在调用addBefore(lm.header)方法，把自己添加到链表的结尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123;</div><div class="line">            after  = existingEntry;</div><div class="line">            before = existingEntry.before;</div><div class="line">            before.after = this;</div><div class="line">            after.before = this;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Android/lru6.png" alt="image"></p>
<p>大功告成。这样就完成了一次Lru排序。将最近访问的数据放在了链表的结尾，链表越靠前的越不常用，缓存空间不够就优先清楚前面的。</p>
<h2 id="4-获取一个最该清除的不常用的元素"><a href="#4-获取一个最该清除的不常用的元素" class="headerlink" title="4.获取一个最该清除的不常用的元素"></a>4.获取一个最该清除的不常用的元素</h2><p>LinkedHashMap还有一个方法eldest()，提供的就是最近最少使用的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Map.Entry&lt;K, V&gt; eldest() &#123;</div><div class="line">        Entry&lt;K, V&gt; eldest = header.after;</div><div class="line">        return eldest != header ? eldest : null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>结合流程图片可以看到，header.after就是A，也就是符合要求的需要清除的数据。</p>
<h1 id="四-回到LruCache类"><a href="#四-回到LruCache类" class="headerlink" title="四.回到LruCache类"></a>四.回到LruCache类</h1><p>在LruCache中是怎么结合LinkedHashMap实现这个缓存的呢？</p>
<p>前面的方法就很明显了。</p>
<ol>
<li>首先在初始化LinkedHashMap的时候，是这样的：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</div></pre></td></tr></table></figure>
<p>第三个参数为true，因此每次访问LinkedHashMap的数据，LinkedHashMap都回去进行排序，将最近访问的放在链表末尾。</p>
<ol>
<li>LruCache的put方法调用了LinkedHashMap的put来存储数据，自己进行了对缓存空间的计算。LinkedHashMap的put方法也会进行排序。</li>
<li>LruCache的get方法调用了LinkedHashMap的get来获取数据，由于上面的第三个参数是true，因此get也会触发LinkedHashMap的排序</li>
</ol>
<h2 id="trimToSize-int-maxSize"><a href="#trimToSize-int-maxSize" class="headerlink" title="trimToSize(int maxSize)"></a>trimToSize(int maxSize)</h2><p>这是LruCache的核心方法了，get和put都可能会执行这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public void trimToSize(int maxSize) &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            K key;</div><div class="line">            V value;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</div><div class="line">                    throw new IllegalStateException(getClass().getName()</div><div class="line">                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (size &lt;= maxSize) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class="line">                if (toEvict == null) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                key = toEvict.getKey();</div><div class="line">                value = toEvict.getValue();</div><div class="line">                map.remove(key);</div><div class="line">                size -= safeSizeOf(key, value);</div><div class="line">                evictionCount++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            entryRemoved(true, key, value, null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法会检查已用的缓存大小和设置的最大缓存大小。</p>
<p>当发现需要进行删除数据来腾出缓存空间的时候，会调用LinkedHashMap的eldest()方法来获取最应该删除的那个数据，然后删除。</p>
<p>这样就完成了他的算法。</p>
<h1 id="五-用LruCache来缓存Bitmap的初始化"><a href="#五-用LruCache来缓存Bitmap的初始化" class="headerlink" title="五.用LruCache来缓存Bitmap的初始化"></a>五.用LruCache来缓存Bitmap的初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">LruCache&lt;String, Bitmap&gt; mLruCache;</div><div class="line">        //获取手机最大内存 单位 kb</div><div class="line">        int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line">        //一般都将1/8设为LruCache的最大缓存</div><div class="line">        int cacheSize = maxMemory / 8;</div><div class="line">        mLruCache = new LruCache&lt;String, Bitmap&gt;(maxMemory / 8) &#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 这个方法从源码中看出来是设置已用缓存的计算方式的。</div><div class="line">             * 默认返回的值是1，也就是没缓存一张图片就将已用缓存大小加1.</div><div class="line">             * 缓存图片看的是占用的内存的大小，每张图片的占用内存也是不一样的，一次不能这样算。</div><div class="line">             * 因此要重写这个方法，手动将这里改为本次缓存的图片的大小。</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap value) &#123;</div><div class="line">                return value.getByteCount() / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//加入缓存</div><div class="line">       mLruCache.put(&quot;key&quot;, BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));</div><div class="line">       //从缓存中读取</div><div class="line">       Bitmap bitmap = mLruCache.get(&quot;key&quot;);</div></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/08/24/关于散列Hash的一点笔记/" class="next">关于散列Hash的一点笔记</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一-LruCache算法"><span class="toc-text">一.LruCache算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二-LruCache部分源码"><span class="toc-text">二.LruCache部分源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三-为什么用LinkedHashMap"><span class="toc-text">三.为什么用LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-构造方法"><span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Entity的定义"><span class="toc-text">2.Entity的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-get方法的排序过程"><span class="toc-text">3.get方法的排序过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-获取一个最该清除的不常用的元素"><span class="toc-text">4.获取一个最该清除的不常用的元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四-回到LruCache类"><span class="toc-text">四.回到LruCache类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#trimToSize-int-maxSize"><span class="toc-text">trimToSize(int maxSize)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五-用LruCache来缓存Bitmap的初始化"><span class="toc-text">五.用LruCache来缓存Bitmap的初始化</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/LruCache原理和用法与LinkedHashMap/">LruCache原理和用法与LinkedHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/关于散列Hash的一点笔记/">关于散列Hash的一点笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/15/APP启动页背景颜色变化/">APP启动页背景颜色变化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/ArrayList和LinkedList的简单实现/">ArrayList和LinkedList的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/Android-socket的基本使用，发送文字和图片以及心跳/">Android-socket的基本使用，发送文字和图片以及心跳</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/将带有jni的Eclipse项目导入AndroidStudio遇到的问题/">将带有jni的Eclipse项目导入AndroidStudio遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/AVL树的旋转图解和简单实现/">AVL树的旋转图解和简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/查找二叉树的简单实现/">查找二叉树的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/ADB常用命令/">ADB常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/Android解压中文乱码/">Android解压中文乱码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/文字识别/" style="font-size: 15px;">文字识别</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/版本控制/" style="font-size: 15px;">版本控制</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/翻墙/" style="font-size: 15px;">翻墙</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://blog.csdn.net/qq_25806863" title="csdn" target="_blank">csdn</a><ul></ul><a href="https://github.com/wangyisll" title="github" target="_blank">github</a><ul></ul><a href="http://www.jianshu.com/u/cb3133f5a1bd" title="简书" target="_blank">简书</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Sitemap</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">喵了个呜.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>