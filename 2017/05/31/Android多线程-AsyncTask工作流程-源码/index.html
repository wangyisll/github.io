<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android多线程-AsyncTask工作流程(源码) | 喵了个呜的小宇宙</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="AsyncTask的源码是很简单的，看着并不复杂。只是对Handler和ThreadPoolExecutor进行了一下封装。 基于api25（7.1）的代码， 使用起来也是很简单的，看上个就知道了。一般要继承AsyncTask并重写下面几个方法,这些方法的执行顺序一目了然： 原文地址 http://blog.csdn.net/qq_25806863/article/details/72820844">
<meta name="keywords" content="Android,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Android多线程-AsyncTask工作流程(源码)">
<meta property="og:url" content="http://blog.miaolegewu.top/2017/05/31/Android多线程-AsyncTask工作流程-源码/index.html">
<meta property="og:site_name" content="喵了个呜的小宇宙">
<meta property="og:description" content="AsyncTask的源码是很简单的，看着并不复杂。只是对Handler和ThreadPoolExecutor进行了一下封装。 基于api25（7.1）的代码， 使用起来也是很简单的，看上个就知道了。一般要继承AsyncTask并重写下面几个方法,这些方法的执行顺序一目了然： 原文地址 http://blog.csdn.net/qq_25806863/article/details/72820844">
<meta property="og:updated_time" content="2017-06-29T00:29:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android多线程-AsyncTask工作流程(源码)">
<meta name="twitter:description" content="AsyncTask的源码是很简单的，看着并不复杂。只是对Handler和ThreadPoolExecutor进行了一下封装。 基于api25（7.1）的代码， 使用起来也是很简单的，看上个就知道了。一般要继承AsyncTask并重写下面几个方法,这些方法的执行顺序一目了然： 原文地址 http://blog.csdn.net/qq_25806863/article/details/72820844">
  
    <link rel="alternate" href="/atom.xml" title="喵了个呜的小宇宙" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">喵了个呜的小宇宙</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.miaolegewu.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android多线程-AsyncTask工作流程-源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/31/Android多线程-AsyncTask工作流程-源码/" class="article-date">
  <time datetime="2017-05-31T02:19:18.000Z" itemprop="datePublished">2017-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android多线程-AsyncTask工作流程(源码)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>AsyncTask的源码是很简单的，看着并不复杂。只是对Handler和ThreadPoolExecutor进行了一下封装。</p>
<p>基于api25（7.1）的代码，</p>
<p>使用起来也是很简单的，看<a href="http://blog.csdn.net/qq_25806863/article/details/72782050" target="_blank" rel="external">上个就知道了</a>。一般要继承AsyncTask并重写下面几个方法,这些方法的执行顺序一目了然：</p>
<p>原文地址 <a href="http://blog.csdn.net/qq_25806863/article/details/72820844" target="_blank" rel="external">http://blog.csdn.net/qq_25806863/article/details/72820844</a></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//任务执行前调用</div><div class="line">protected void onPreExecute() &#123;&#125;</div><div class="line">//执行后台任务</div><div class="line">protected abstract Result doInBackground(Params... params);</div><div class="line">//返回任务执行结果</div><div class="line">protected void onPostExecute(Result result) &#123;&#125;</div><div class="line">//返回任务执行进度</div><div class="line">protected void onProgressUpdate(Progress... values) &#123;&#125;</div><div class="line">//任务取消时调用</div><div class="line">protected void onCancelled() &#123;&#125;</div></pre></td></tr></table></figure>
<p>只有<code>doInBackground</code>一个方法是抽象的，必须重写，其他的可以不用重写。</p>
<p>然后通常的调用方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new MyAsyncTask().execute();</div></pre></td></tr></table></figure>
<h1 id="Handler和线程池"><a href="#Handler和线程池" class="headerlink" title="Handler和线程池"></a>Handler和线程池</h1><p>既然是对Handler和线程池的封装，就先看看封装的什么用的Handler和线程池。都是定义在AsyncTask类中。</p>
<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                    <span class="comment">// There is only one result</span></div><div class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                    result.mTask.onProgressUpdate(result.mData);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">                sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> sHandler;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先有一个变量sHandler。</p>
<p>InternalHandler是一个静态内部类</p>
<p>在这个构造方法中可以看出，InternalHandler使用了主线程也就是UI线程的Looper来处理消息，所以这个Handler收到的消息会在主线程中处理。使用这个Handler就达到了跟主线程进行交互的目的。</p>
<p>然后提供了一个方法getHandler，用单例来获取唯一的一个InternalHandler。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</div><div class="line">                sPoolWorkQueue, sThreadFactory);</div><div class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">        THREAD_POOL_EXECUTOR = threadPoolExecutor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</div><div class="line"><span class="comment">//默认的线程池</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">        Runnable mActive;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        r.run();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        scheduleNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">                scheduleNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultExecutor</span><span class="params">(Executor exec)</span> </span>&#123;</div><div class="line">        sDefaultExecutor = exec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这里可以看见连个线程池，<code>THREAD_POOL_EXECUTOR</code>和<code>SERIAL_EXECUTOR</code>,以及一个默认使用的线程池变量<code>sDefaultExecutor</code>。</p>
<p>这两个线程池关系到了<a href="">为什么AsyncTask的任务是串行的</a>。在ActivityThread中有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//android.os.Build.VERSION_CODES.HONEYCOMB_MR1=12</span></div><div class="line"><span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">    AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看来只有当版本小于13的时候，才会将<code>THREAD_POOL_EXECUTOR</code>作为默认线程池，可以并行执行任务。</p>
<h3 id="THREAD-POOL-EXECUTOR"><a href="#THREAD-POOL-EXECUTOR" class="headerlink" title="THREAD_POOL_EXECUTOR"></a>THREAD_POOL_EXECUTOR</h3><p>其中<code>THREAD_POOL_EXECUTOR</code>是在静态代码块中定义的，在类加载的时候就执行了，而且只会执行一次。</p>
<p>直接使用<code>ThreadPoolExecutor</code>的构造方法来构造了一个线程池，来看一下参数：</p>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">4</span>));</div></pre></td></tr></table></figure>
<p>核心线程数，其中<code>CPU_COUNT = Runtime.getRuntime().availableProcessors()</code>表示CPU数量。最低两个，最多四个。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>最大线程数，是CPU核心数的2倍+1.</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">30</span>;</div></pre></td></tr></table></figure>
<p>空闲线程存活时间，30 。根据第四个参数<code>TimeUnit.SECONDS</code>知道是30秒。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div></pre></td></tr></table></figure>
<p>使用了<code>LinkedBlockingQueue</code>，超过核心线程数量的任务会在队列中排队。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个只是给每个线程池中创建的额线程起了个名字，叫 <code>AsyncTask # 数字</code>，数字自增长。</p>
</li>
</ul>
<p>然后设置语序核心线程空闲超时<code>threadPoolExecutor.allowCoreThreadTimeOut(true)</code> 。</p>
<p>这是一个中规中矩的线程池，然而默认使用的线程池并不是这个。而是下面的<code>SERIAL_EXECUTOR</code></p>
<h3 id="SERIAL-EXECUTOR"><a href="#SERIAL-EXECUTOR" class="headerlink" title="SERIAL_EXECUTOR"></a>SERIAL_EXECUTOR</h3><p><code>SERIAL_EXECUTOR</code>中维护了一个双端数组队列<code>mTasks</code>，里面存放的Runnable。</p>
<p>当调用他的<code>execute</code>方法执行<code>Runnable</code>时，他会把这个<code>Runnable</code>的<code>run</code>方法和<code>scheduleNext()</code>方法重新加工包装成一个新的<code>Runnable</code>放在队列中。</p>
<p>然后下面会判断<code>mActive</code>是不是空的，第一次肯定是空的，所以会执行<code>scheduleNext()</code>方法。</p>
<p>在这个方法中，会调用队列的<code>poll</code>方法取出一个<code>Runnable</code>,然后调用上面的线程池<code>THREAD_POOL_EXECUTOR</code>来执行任务。</p>
<p>因为每个任务经过加工都加上了<code>scheduleNext()</code>方法，所以队列中的任务都会按顺序执行完。</p>
<ul>
<li>由此可见，这个队列仅仅起到一个排序功能，是各个任务依次执行，真正的执行还是交给了线程池<code>SERIAL_EXECUTOR</code>.</li>
</ul>
<h1 id="AsyncTask的其他内部类"><a href="#AsyncTask的其他内部类" class="headerlink" title="AsyncTask的其他内部类"></a>AsyncTask的其他内部类</h1><h2 id="状态Status"><a href="#状态Status" class="headerlink" title="状态Status"></a>状态Status</h2><p>AsyncTask有一个枚举类定义了三个状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Indicates that the task has not been executed yet.</div><div class="line">     * 表明任务尚未执行</div><div class="line">     */</div><div class="line">    PENDING,</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Indicates that the task is running.</div><div class="line">     * 表明任务正在执行</div><div class="line">     */</div><div class="line">    RUNNING,</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Indicates that &#123;<span class="doctag">@link</span> AsyncTask#onPostExecute&#125; has finished.</div><div class="line">     * 表明onPostExecute已经结束</div><div class="line">     */</div><div class="line">    FINISHED,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然就有一个表示状态的变量,<code>mStatus</code>默认是<code>Status.PENDING</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;</div></pre></td></tr></table></figure>
<h2 id="WorkerRunnable"><a href="#WorkerRunnable" class="headerlink" title="WorkerRunnable"></a>WorkerRunnable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    Params[] mParams;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类就是个CallAble接口，里面增加了一个参数数组。</p>
<h2 id="AsyncTaskResult"><a href="#AsyncTaskResult" class="headerlink" title="AsyncTaskResult"></a>AsyncTaskResult</h2><p>这个类其实就是个存储类，保存了一个<code>AsyncTask</code>和<code>Data[]</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">    <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h1><p>上面的都准备好了，下面就能运行了。</p>
<p>看着调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new MyAsyncTask().execute();</div></pre></td></tr></table></figure>
<p>先实现一个AsyncTask,这时要定义<a href="http://blog.csdn.net/qq_25806863/article/details/72782050" target="_blank" rel="external">三个参数类型</a>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AsyncTask&lt;Params, Progress, Result&gt;</div></pre></td></tr></table></figure>
<p>先new一个，然后调用<code>execute方法</code></p>
<p>new的时候肯定会调用构造方法</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>AsyncTask的构造方法中初始化了两个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mTaskInvoked = <span class="keyword">new</span> AtomicBoolean();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mWorker</code>前面看到了，是一个<code>WorkerRunnable</code>，所以要重写<code>call</code>方法。</p>
<p>这个任务其实才是后台任务，所以这个任务就是真正的AsyncTask的任务了。</p>
<p>然后就调用了<code>doInBackground(mParams)</code>，把参数穿了进去。</p>
<p><code>mFuture</code>是个<code>FutureTask</code>，他把上面的<code>mWorker</code>又进行了一次包装，会先执行<code>mWorker</code>的<code>call</code>方法中的内容，再执行<code>done()</code>。</p>
<h2 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</div><div class="line">    return executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是真正开始执行任务的方法，一般都会传入个参数Params。</p>
<p>里面直接调用了<code>executeOnExecutor(sDefaultExecutor, params)</code>方法，使用的线程池是默认的 ，也就是上面的<code>SERIAL_EXECUTOR</code>。串行执行任务。</p>
<h3 id="onPreExecute"><a href="#onPreExecute" class="headerlink" title="onPreExecute"></a>onPreExecute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里先判断任务的状态<code>mStatus</code>，如果是正在运行或者说运行结束了，都会抛异常。所以一个任务只能执行一次<code>executef</code>方法，一个任务只能执行一次，不能重复执行。</p>
<p>当<code>mStatus</code>是<code>PENDING</code>的时候，先<code>mStatus = Status.RUNNING</code>表示任务正在执行了。</p>
<p>然后就调用到了<code>onPreExecute()</code>方法。</p>
<p><code>mWorker.mParams = params</code>前面看见<code>WorkerRunnable</code>中有一个变量<code>Params[] mParams</code>，保存了传入的参数。</p>
<p>一直到这时候都还是在原来的线程中运行，并没有开启多线程。所以这个方法也是在原来的线程中运行的。</p>
<p>然后调用传入的线程池的<code>execute</code>方法，来执行构造方法中新建的<code>mFuture</code>。这个时候就使用线程池开新线程了。</p>
<h3 id="doInBackground"><a href="#doInBackground" class="headerlink" title="doInBackground"></a>doInBackground</h3><p><code>mFuture</code>里有个<code>mWorker</code>,会执行他的call方法，这个方法中的内容都会在子线程中运行，其中包括了<code>doInBackground</code>，他的参数<code>mParams</code>是<code>WorkerRunnable</code>里的变量。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">        Result result = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ...</div><div class="line">            result = doInBackground(mParams);</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">            mCancelled.set(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">throw</span> tr;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            postResult(result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先把<code>mTaskInvoked</code>设置为<code>true</code>表示这个任务已经开始了。</p>
<p>然后调用重写过的<code>doInBackground</code>方法，运行咱们需要后台运行的任务。</p>
<p><code>doInBackground</code>有一个返回值，也是个泛型。</p>
<p>出现异常时，将<code>mCancelled</code>设置为<code>true</code>,表示任务取消了。</p>
<p>最终都会调用<code>postResult(result)</code>方法。</p>
<p>这个方法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private Result postResult(Result result) &#123;</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getHandler()</code>前面知道是通过单例获取到一个使用主线程<code>Looper</code>创建的<code>Handler</code>,就是<code>InnerHandler</code>,所以他对消息的处理会回到主线程中。</p>
<p>然后通过这个Handler发送消息，消息内容是<code>new AsyncTaskResult&lt;Result&gt;(this, result)</code>。前面也看了这是个载体，将这个<code>AsyncTask</code>本身和后台任务<code>doInBackground</code>的返回结果传了进去。</p>
<p>然后整个工作就完成了。</p>
<h3 id="onProgressUpdate"><a href="#onProgressUpdate" class="headerlink" title="onProgressUpdate"></a>onProgressUpdate</h3><p>这个方法用来更新进度，不能直接调用，要通过<code>publishProgress</code>方法来调用。</p>
<p>在<code>doInBackground</code>，通常会手动调用<code>publishProgress</code>方法来更新进度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected final void publishProgress(Progress... values) &#123;</div><div class="line">    if (!isCancelled()) &#123;</div><div class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</div><div class="line">                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法贤惠判断任务是否取消，如果取消了就什么都不做。</p>
<p>没取消就也用<code>InnerHandler</code>发送消息，内容是<code>new AsyncTaskResult&lt;Progress&gt;(this, values)</code>。传入当前的<code>AsyncTask</code>和进度信息<code>values</code>.</p>
<p>这些方法最终都是以通过Handler发送个消息结束，所以后面的就是Handler的事了</p>
<p>之前已经看过了这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>handleMessage</code>中能看到，<code>result</code>是个<code>AsyncTaskResult</code>类型，在前面也知道这个里面保存了<code>AsyncTask</code>和要传递的数据。前面两个消息携带的信息也是这个类型。</p>
<p>当<code>msg.what==MESSAGE_POST_PROGRESS</code>的时候，表示要更新进度，就先从<code>result</code>中拿到里面的<code>AsyncTask-&gt;result.mTask</code>，然后调用他的<code>onProgressUpdate</code>方法，参数是<code>result</code>中的<code>mData-&gt;result.mData</code>。</p>
<p>如果重写过这个方法，就可以根据这个值更新进度。</p>
<h3 id="onPostExecute"><a href="#onPostExecute" class="headerlink" title="onPostExecute"></a>onPostExecute</h3><p>当<code>msg.what==MESSAGE_POST_RESULT</code>的时候，表示有结果了，这是后台任务已经执行结束了。</p>
<p>调用里面的<code>AsyncTask</code>的<code>finish</code>方法，参数是消息里的<code>mData</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void finish(Result result) &#123;</div><div class="line">    if (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; else &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面也是先判断是否取消，取消了就调用取消的回调<code>onCancelled</code>，没取消就调用正常的回调<code>onPostExecute</code>，并最后把任务状态改为<code>Status.FINISHED</code>。</p>
<p>整个任务结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.miaolegewu.top/2017/05/31/Android多线程-AsyncTask工作流程-源码/" data-id="cj4hps3fi000kdsfyfatebtpl" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/14/对一个KotlinAPP的copy/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nieuwer</strong>
      <div class="article-nav-title">
        
          对一个KotlinAPP的copy
        
      </div>
    </a>
  
  
    <a href="/2017/05/23/Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画/">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字识别/">文字识别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻墙/">翻墙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Kotlin/" style="font-size: 11.43px;">Kotlin</a> <a href="/tags/java/" style="font-size: 14.29px;">java</a> <a href="/tags/动画/" style="font-size: 17.14px;">动画</a> <a href="/tags/多线程/" style="font-size: 15.71px;">多线程</a> <a href="/tags/工具/" style="font-size: 12.86px;">工具</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文字识别/" style="font-size: 11.43px;">文字识别</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/翻墙/" style="font-size: 10px;">翻墙</a> <a href="/tags/设计模式/" style="font-size: 18.57px;">设计模式</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/27/ADB常用命令/">ADB常用命令</a>
          </li>
        
          <li>
            <a href="/2017/06/23/Android解压中文乱码/">Android解压中文乱码</a>
          </li>
        
          <li>
            <a href="/2017/06/23/通过轮廓简单实现一个圆图/">通过轮廓简单实现一个圆图</a>
          </li>
        
          <li>
            <a href="/2017/06/15/Kotlin让属性只能被赋值一次且不能为空/">Kotlin让属性只能被赋值一次且不能为空</a>
          </li>
        
          <li>
            <a href="/2017/06/14/对一个KotlinAPP的copy/">对一个KotlinAPP的copy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 喵了个呜<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>