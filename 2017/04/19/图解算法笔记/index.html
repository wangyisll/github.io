<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>图解算法笔记 | 喵了个呜的小宇宙</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">图解算法笔记</h1><a id="logo" href="/.">喵了个呜的小宇宙</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">图解算法笔记</h1><div class="post-meta"><span class="date">Apr 19, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i> Hits</i></i></span><a href="/2017/04/19/图解算法笔记/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%87%B5%E9%80%BC.gif" alt=""></p>
<p>[TOC]</p>
<h1 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h1><a id="more"></a>
<ul>
<li><p>log都指 $log_2$</p>
</li>
<li><p>大O表示算法的速度有多快，但并不是以秒为单位的速度。而是操作数增加时，算法运行时间的增速。</p>
</li>
<li><p>表示最糟糕情况下的运行时间</p>
</li>
<li><p>除了最糟糕情况下运行时间，还有平均运行时间</p>
</li>
<li><p>从快到慢的常用大O：</p>
<ul>
<li>O(log n)</li>
<li>O(n)</li>
<li>O(n*log n)</li>
<li>O($n^2$)</li>
<li>O(n!)</li>
</ul>
</li>
<li><p>总时间和常量（固定时间量）有关。影响有时很大有时很小。</p>
</li>
<li><p>平均情况和最糟情况，如快读排序可能因为基准数的选择而遇到最坏情况和最糟情况。</p>
</li>
</ul>
<p> 二分查找的速度比简单查找快得多。<br> O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。  算法运行时间并不以秒为单位。<br> 算法运行时间是从其增速的角度度量的。<br> 算法运行时间用大O表示法表示。</p>
<h1 id="内存存储的基本方式-数组和链表"><a href="#内存存储的基本方式-数组和链表" class="headerlink" title="内存存储的基本方式 数组和链表"></a>内存存储的基本方式 数组和链表</h1><ul>
<li><p>两种最基本的数据结构——数组和链表</p>
</li>
<li><p>观众席座位，写便签安排事件顺序表，上菜顺序</p>
</li>
<li><p>数组 查询读取 随机访问</p>
<ul>
<li>数组在内存中是相连的</li>
<li>不预留空间的话，增加新数据很麻烦，后面的都要向后挪。</li>
<li>数组要事前申请一定的内存空间，但可能自己用不了，别人也不能用，浪费内存。</li>
<li>超过申请空间大小，还是要挪。</li>
<li>如果空间不够，可能会需要将整个数组全部复制到另一块内存中。</li>
<li>数组知道每一个元素的地址，随机读取效率高，能迅速找到数组中的任何元素</li>
</ul>
</li>
<li><p>链表 插入 删除 顺序访问</p>
<ul>
<li>可以存储在内存任何地方，每一个元素存储了下一个元素的内存地址，从而串在一起。</li>
<li>增加数据很容易</li>
<li>删除元素很容易</li>
<li>如果需要读取最后一个元素，需要从第一个元素开始访问，然后依次获取下一个元素的内存地址，直至访问到最后一个元素。</li>
<li>需要读所有元素时，链表效率很高：读取第一个元素，然后根据地址读取第二个元素。</li>
<li>如果需要跳跃，效率很低。</li>
</ul>
</li>
<li><p>数组下标索引从0开始</p>
</li>
<li><p>表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>O(n)=线性时间  O(1)=常量时间</p>
<p>链表删除时，只有能一次就访问到的时候时间才是O(1)，链表能直接访问到底额元素是第一个元素和最后一个元素。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p> 计算机内存犹如一大堆抽屉。</p>
<p> 需要存储多个元素时，可使用数组或链表。</p>
<p> 数组的元素都在一起。</p>
<p> 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。</p>
<p> 数组的读取速度很快。</p>
<p> 链表的插入和删除速度很快。</p>
<p> 在同一个数组中，所有元素的类型都必须相同(都为int、double等)。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul>
<li>递归和循环作用相同，递归更清晰。</li>
<li><p>循环性能可能更好，递归可能更清晰</p>
</li>
<li><p>递归要防止死循环</p>
</li>
<li>基线条件-&gt;跳出递归  递归条件-&gt;递归调用自己</li>
</ul>
<h2 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h2><ul>
<li><p>栈不能用于查找</p>
</li>
<li><p>每调用一次方法，系统就会将该方法调用涉及的所有变量存储到内存中。</p>
</li>
<li>调用栈可能会占用大量的内存，如果栈很高，可能意味着计算机存储了大量的调用栈这时：1.改用循环。 2.尾递归</li>
<li>每个程序分配的栈空间有限，超出会引发栈溢出异常。</li>
</ul>
<p> 递归指的是调用自己的函数。</p>
<p> 每个递归函数都有两个条件:基线条件和递归条件。  栈有两种操作:压入和弹出。</p>
<p> 所有函数调用都进入调用栈。</p>
<p> 调用栈可能很长，这将占用大量的内存。</p>
<h1 id="分而治之-递归式问题解决方案"><a href="#分而治之-递归式问题解决方案" class="headerlink" title="分而治之-递归式问题解决方案"></a>分而治之-递归式问题解决方案</h1><ul>
<li>土地分方块</li>
</ul>
<p>原理：</p>
<ul>
<li>找出简单的基线条件</li>
<li>确定如何缩小问题规模，使其符合基线条件</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>选一个基准，进行分区排序</li>
</ul>
<p> D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元 素的数组。</p>
<p> 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。</p>
<p> 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。</p>
<p> 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)<br>快得多。</p>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><ul>
<li>最有用的基本数据结构之一</li>
<li>散列表的内部机制:实现、冲突和散列函数</li>
</ul>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ul>
<li><p>不管给他什么数据，都返还给你一个数字  “将输入映射到数字”</p>
</li>
<li><p>散列函数满足的要求：</p>
<ul>
<li>它必须是一致的。同样的额输入获得同样的数字。</li>
<li>它应该讲不同的输入映射到不同的数字。这个数字为存储数组的下标，然而这样的函数几乎不可能写出。</li>
</ul>
</li>
<li><p>散列表用数组来存储数据，因此 获取元素的速度跟数组一样快</p>
</li>
<li><p>散列函数知道数组有多大，只会返回合法的数组下标</p>
</li>
<li><p>散列表里面由键和值组成，键被散列函数变为一个数字作为数组下标，这个下标的值就是值</p>
</li>
<li><p>平均情况下，散列表的插入删除速度跟链表一样快，查找速度跟数组一样快。O(1)</p>
</li>
<li><p>最糟情况下，散列表的这些速度都是 O(n)</p>
</li>
<li><p>作用</p>
<ul>
<li>散列表被用于大海捞针式的查找 如DNS解析</li>
<li>在插入数据前先查询，防止重复插入。速度非常快</li>
</ul>
</li>
</ul>
<p> 模拟映射关系;</p>
<p> 防止重复;</p>
<p> 缓存/记住数据，以免服务器再通过处理来生成它们。</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><ul>
<li>理想状态是 散列函数总是将不同的键映射到数组的不同位置。 但实际上，几乎不可能编写出这样的散列函数</li>
<li>当多个数据分配到同一个下标的时候，就在这个下标上存储一个链表，</li>
<li>散列函数很重要，如果链表很长，那么性能会急剧下降。好的散列函数不会产生很长的链表。</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>简单查找 O(n) 线性时间</li>
<li>二分查找 O(log n) 对数时间</li>
<li><p>散列查找 O(1) 常量时间</p>
</li>
<li><p>避免冲突就能避开最糟情况：</p>
<ul>
<li>较低的填装因子</li>
<li>良好的散列函数</li>
</ul>
</li>
<li><p>填装因子=元素数/位置数 可以理解为平均每一个位置要存多少个元素。填装因子<1，说明有空位。填装因子=1,则一个位置一个元素。填装因子>1，则一个位置不止一个元素。</1，说明有空位。填装因子=1,则一个位置一个元素。填装因子></p>
</li>
<li><p>一般填装因子&gt;0.7就考虑调整数组长度，减少填装因子。</p>
</li>
<li><p>良好的散列函数就是散列函数尽量将不同的键映射到数组的不同位置，让数组中的值均匀分布  </p>
</li>
<li>SHA函数</li>
</ul>
<p> 你可以结合散列函数和数组来创建散列表。</p>
<p> 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。  散列表的查找、插入和删除速度都非常快。</p>
<p> 散列表适合用于模拟映射关系。</p>
<p> 一旦填装因子超过0.7，就该调整散列表的长度。</p>
<p> 散列表可用于缓存数据(例如，在Web服务器上)。</p>
<p> 散列表非常适合用于防止重复。</p>
<h1 id="广度优先搜索-图算法"><a href="#广度优先搜索-图算法" class="headerlink" title="广度优先搜索  图算法"></a>广度优先搜索  图算法</h1><ul>
<li><p>图由节点和边组成，一个节点可能与多个节点直接连接，叫邻居</p>
</li>
<li><p>广度优先搜索。找一个东西，朋友没有，从朋友的朋友找，从朋友的朋友的朋友找，直到找到</p>
</li>
<li><p>先搜索一度关系，在搜索二度关系</p>
</li>
<li><p>排队，先进先出</p>
</li>
<li><p>有向图 无向图</p>
</li>
</ul>
<h2 id="最短路径算法（非加权图-段数最少）"><a href="#最短路径算法（非加权图-段数最少）" class="headerlink" title="最短路径算法（非加权图 段数最少）"></a>最短路径算法（非加权图 段数最少）</h2><ul>
<li>建立一个队列，先把一度关系加入队列中，然后从第一个人开始，查找不到就把这个人的二度关系加入队列，然后取出队列的第二个人开始搜索。直到找到或队列为空。</li>
<li><p>避免重复检查，陷入死循环</p>
</li>
<li><p>运行时间 = 人数加边数  =O(V+E) V为顶点  E为边数</p>
</li>
<li><p>拓扑排序 </p>
</li>
</ul>
<p> 广度优先搜索指出是否有从A到B的路径。</p>
<p> 如果有，广度优先搜索将找出最短路径。</p>
<p> 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来<br>解决问题。</p>
<p> 有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约<br>会，而rachel也与ross约会”。</p>
<p> 队列是先进先出(FIFO)的。</p>
<p> 栈是后进先出(LIFO)的。</p>
<p> 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必<br>须是队列。</p>
<p> 对于检查过的人，务必不要再去检查，否则可能导致无限循环。</p>
<h1 id="狄克斯特拉算法-加权图"><a href="#狄克斯特拉算法-加权图" class="headerlink" title="狄克斯特拉算法  加权图"></a>狄克斯特拉算法  加权图</h1><ul>
<li>不能将狄克斯特拉算法用于包含负权边的图</li>
</ul>
<h2 id="最短路径算法（加权图-权重最少）"><a href="#最短路径算法（加权图-权重最少）" class="headerlink" title="最短路径算法（加权图 权重最少）"></a>最短路径算法（加权图 权重最少）</h2><ul>
<li><p>这里重述一下，狄克斯特拉算法包含4个步骤。</p>
<ul>
<li>(1) 找出最便宜的节点，即可在最短时间内前往的节点。</li>
<li>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 </li>
<li>(3) 重复这个过程，直到对图中的每个节点都这样做了。</li>
<li>(4) 计算最终路径。(下一节再介绍!)</li>
</ul>
</li>
<li><p>每条边上的数字叫权重</p>
</li>
<li>带权重的叫加权图     最短路径用狄克斯特拉算法</li>
<li><p>不带数字的叫非加权图  最短路径用广度优先搜索</p>
</li>
<li><p>两个节点互相指向对方，就成了一个环</p>
</li>
<li>无向图中，每条边都是一个环</li>
<li>狄克斯特拉算法只适用于有向无环图</li>
</ul>
<h2 id="实现狄克斯特拉算法"><a href="#实现狄克斯特拉算法" class="headerlink" title="实现狄克斯特拉算法"></a>实现狄克斯特拉算法</h2><p> 广度优先搜索用于在非加权图中查找最短路径。 </p>
<p> 狄克斯特拉算法用于在加权图中查找最短路径。 </p>
<p> 仅当权重为正时狄克斯特拉算法才管用。</p>
<p> 如果图中包含负权边，请使用贝尔曼福德算法。</p>
<h1 id="贪婪算法-贪婪策略"><a href="#贪婪算法-贪婪策略" class="headerlink" title="贪婪算法 贪婪策略"></a>贪婪算法 贪婪策略</h1><ul>
<li>贪婪算法优点：简单易行</li>
<li>每步都采取最优的做法，每步都选择局部最优解，最终得打全局最优解</li>
<li><p>易于实现，但并非都有效</p>
</li>
<li><p>贪婪算法可以得到与正确解相近的解，而且更容易得到</p>
</li>
<li><p>近似算法 获取精准解需要的时间太长时，可以使用。  优劣标准如下</p>
<ul>
<li>速度有多快</li>
<li>得到的近似解与最优解的接近程度</li>
</ul>
</li>
</ul>
<h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><ul>
<li>旅行商问题 线路有n!条</li>
<li>需要计算出所有解，并从中选出最小/最短的那个</li>
<li><p>NP完全问题  是以难解著称的问题</p>
</li>
<li><p> 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</p>
</li>
<li><p> 涉及“所有组合”的问题通常是NP完全问题。</p>
</li>
<li><p> 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</p>
</li>
<li><p> 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能就是NP完全问题。 </p>
</li>
<li><p> 如果问题涉及集合(如广播台集合)且难以解决，它可能就是NP完全问题。</p>
</li>
<li><p> 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</p>
</li>
</ul>
<hr>
<p> 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 </p>
<p> 对于NP完全问题，还没有找到快速解决方案。</p>
<p> 面临NP完全问题时，最佳的做法是使用近似算法。</p>
<p> 贪婪算法易于实现、运行速度快，是不错的近似算法。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li>动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当 每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。</li>
</ul>
<h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><ul>
<li>启示：</li>
<li> 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必 须在背包容量给定的情况下，偷到价值最高的商品。</li>
<li><p> 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。</p>
</li>
<li><p>贴士：</p>
</li>
<li> 每种动态规划解决方案都涉及网格。</li>
<li> 单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。</li>
<li><p> 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网<br> 格的坐标轴。  </p>
</li>
<li><p>实际应用：</p>
</li>
<li> 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相 似。最长公共序列还被用来寻找多发性硬化症治疗方案。</li>
<li> 你使用过诸如git diff等命令吗?它们指出两个文件的差异，也是使用动态规划实现的。</li>
<li>前面讨论了字符串的相似程度。编辑距离(levenshtein distance)指出了两个字符串的相 似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。</li>
<li> 你使用过诸如Microsoft Word等具有断字功能的应用程序吗?它们如何确定在什么地方断<br> 字以确保行长一致呢?使用动态规划!</li>
</ul>
<p> 需要在给定约束条件下优化某种指标时，动态规划很有用。</p>
<p> 问题可分解为离散子问题时，可使用动态规划来解决。</p>
<p> 每种动态规划解决方案都涉及网格。</p>
<p> 单元格中的值通常就是你要优化的值。</p>
<p> 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。</p>
<p> 没有放之四海皆准的计算动态规划解决方案的公式。</p>
<h1 id="K最近邻算法-k-nearest-neighbours，KNN"><a href="#K最近邻算法-k-nearest-neighbours，KNN" class="headerlink" title="K最近邻算法 (k-nearest neighbours，KNN)"></a>K最近邻算法 (k-nearest neighbours，KNN)</h1><ul>
<li><p>距离公式</p>
</li>
<li><p>回归</p>
</li>
<li><p>机器学习</p>
</li>
<li><p>推荐系统</p>
</li>
</ul>
<p> KNN用于分类和回归，需要考虑最近的邻居。</p>
<p> 分类就是编组。</p>
<p> 回归就是预测结果(如数字)。</p>
<p> 特征抽取意味着将物品(如水果或用户)转换为一系列可比较的数字。 5  能否挑选合适的特征事关KNN算法的成败。</p>
<h1 id="十一"><a href="#十一" class="headerlink" title="十一"></a>十一</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>二叉查找树 平均查找时间为O(log n)   最糟为 O(n)</li>
<li>最糟情况比有序数组要慢，但是二叉查找树的插入和删除速度很快</li>
<li><p>二叉查找树不能随机访问  。如果二叉查找树处于平衡状态，那么平均访问时间也是 O(log n)</p>
</li>
<li><p>B树</p>
</li>
<li>红黑树</li>
<li>堆</li>
<li>伸展树</li>
</ul>
<h2 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h2><ul>
<li>一个散列表，将单词映射到包含它的页面  这种数据结构叫做反向索引  常用于创建搜索引擎</li>
</ul>
<h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><ul>
<li>如果能够将歌曲分解为不同的频率，就可强化 你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音 乐。</li>
</ul>
<h2 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h2><ul>
<li>并行提升的速度并不是线性的，双核并行计算并不能让算法的速度提高一倍。因为<ul>
<li>并行性管理开销： 假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之 间分配这项任务呢?如果让每个内核对其中500个元素进行排序，再将两个排好序的数组 合并成一个有序数组，那么合并也是需要时间的</li>
<li>负载均衡： 假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核 A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意 味着有那么50秒，内核B在忙死忙活，而内核A却闲得很!你如何均匀地分配工作，让两 个内核都一样忙呢?</li>
</ul>
</li>
</ul>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><ul>
<li>MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。</li>
<li><p>当并行算法只需要几个内核时，一台计算机就能运行了。如果需要大量的内核时，可让算法在多个计算机上运行。</p>
</li>
<li><p>分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理 念:映射(map)函数和归并(reduce)函数。</p>
<ul>
<li>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理</li>
<li>归并是将一个数组转换为一个元素</li>
</ul>
</li>
</ul>
<h1 id="布隆过滤器和HyperLogLog"><a href="#布隆过滤器和HyperLogLog" class="headerlink" title="布隆过滤器和HyperLogLog"></a>布隆过滤器和HyperLogLog</h1><ul>
<li>给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用散列表。</li>
<li>如果数据集很大，散列表很大，需要占用大量的存储空间，可以使用布隆过滤器。</li>
</ul>
<hr>
<ul>
<li>布隆过滤器是一种概率型数据结构。提供的答案有可能不对，但很可能说正确的。</li>
<li>可能出现报错的情况，但不可能出现漏报的情况。有就一定有，但可能会找到错误的。没有就一定没有，不可能返回有。</li>
<li>占用的存储空间很少，适合不要去答案绝对准确的情况。</li>
</ul>
<hr>
<ul>
<li>HyperLogLog是一种类似于布隆过滤器的概率型算法，也不能给出准确答案，但占用存储空间少得多。</li>
</ul>
<h1 id="SHA-安全散列算法"><a href="#SHA-安全散列算法" class="headerlink" title="SHA 安全散列算法"></a>SHA 安全散列算法</h1><ul>
<li>SHA将一个字符串生成另一个字符串，然后根据生成的字符串生成数组索引，存储生成的字符串，索引说安全的。</li>
<li>判断两个文件是否相同，计算SHA值</li>
<li>检查密码。数据库存储散列值。</li>
<li>SHA-0,SHA-1,SHA-2,SHA-3,bcrypt</li>
</ul>
<h1 id="局部敏感的散列算法"><a href="#局部敏感的散列算法" class="headerlink" title="局部敏感的散列算法"></a>局部敏感的散列算法</h1><ul>
<li>SHA短发说局部不敏感的。这很安全，没法根据相似程度来破解</li>
<li>局部敏感的意思是，如果两个字符串的差别很细微，那么生成的散列值的差别哦也很细微。</li>
<li>局部敏感能通过比较散列值来判断两个字符串的相似程度。</li>
</ul>
<hr>
<ul>
<li>Simhash是局部敏感的</li>
</ul>
<h1 id="Diffie-Hellman算法-密钥交换"><a href="#Diffie-Hellman算法-密钥交换" class="headerlink" title="Diffie-Hellman算法 密钥交换"></a>Diffie-Hellman算法 密钥交换</h1><ul>
<li>双方无需知道加密算法。不必会面协商要使用的加密算法</li>
<li><p>要破解加密的消息比登天还难</p>
</li>
<li><p>使用公钥和私钥。</p>
</li>
<li>公钥是公开的，将其发布出去，别人向你发送消息时用公钥加密，然后自己受到消息用私钥解密，只有自己哟私钥，所以只有自己才能解密</li>
</ul>
<h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><ul>
<li>用于在给定约束条件下最大限度地改善指定的指标。</li>
<li>利润最大化</li>
</ul>
</div><div class="tags"><a href="/tags/读书/">读书</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/04/21/java集合的交集，并集，差集/" class="pre">java集合的交集，并集，差集</a><a href="/2017/04/18/Android动画-属性动画-ViewPropertyAnimator/" class="next">Android动画-属性动画-ViewPropertyAnimator</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#大O表示法"><span class="toc-text">大O表示法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存存储的基本方式-数组和链表"><span class="toc-text">内存存储的基本方式 数组和链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序"><span class="toc-text">选择排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#递归调用栈"><span class="toc-text">递归调用栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分而治之-递归式问题解决方案"><span class="toc-text">分而治之-递归式问题解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序"><span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#散列表"><span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#散列函数"><span class="toc-text">散列函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冲突"><span class="toc-text">冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能"><span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#广度优先搜索-图算法"><span class="toc-text">广度优先搜索  图算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最短路径算法（非加权图-段数最少）"><span class="toc-text">最短路径算法（非加权图 段数最少）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#狄克斯特拉算法-加权图"><span class="toc-text">狄克斯特拉算法  加权图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最短路径算法（加权图-权重最少）"><span class="toc-text">最短路径算法（加权图 权重最少）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现狄克斯特拉算法"><span class="toc-text">实现狄克斯特拉算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#贪婪算法-贪婪策略"><span class="toc-text">贪婪算法 贪婪策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NP完全问题"><span class="toc-text">NP完全问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子串"><span class="toc-text">最长公共子串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#K最近邻算法-k-nearest-neighbours，KNN"><span class="toc-text">K最近邻算法 (k-nearest neighbours，KNN)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十一"><span class="toc-text">十一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反向索引"><span class="toc-text">反向索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#傅里叶变换"><span class="toc-text">傅里叶变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行算法"><span class="toc-text">并行算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MapReduce"><span class="toc-text">MapReduce</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布隆过滤器和HyperLogLog"><span class="toc-text">布隆过滤器和HyperLogLog</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SHA-安全散列算法"><span class="toc-text">SHA 安全散列算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#局部敏感的散列算法"><span class="toc-text">局部敏感的散列算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Diffie-Hellman算法-密钥交换"><span class="toc-text">Diffie-Hellman算法 密钥交换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线性规划"><span class="toc-text">线性规划</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/AVL树的旋转图解和简单实现/">AVL树的旋转图解和简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/查找二叉树的简单实现/">查找二叉树的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/ADB常用命令/">ADB常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/Android解压中文乱码/">Android解压中文乱码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/通过轮廓简单实现一个圆图/">通过轮廓简单实现一个圆图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/Kotlin让属性只能被赋值一次且不能为空/">Kotlin让属性只能被赋值一次且不能为空</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/对一个KotlinAPP的copy/">对一个KotlinAPP的copy</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/31/Android多线程-AsyncTask工作流程-源码/">Android多线程-AsyncTask工作流程(源码)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)/">Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/15/Android纯的二维码扫描界面和功能-zxing/">Android纯的二维码扫描界面和功能-zxing</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/文字识别/" style="font-size: 15px;">文字识别</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/版本控制/" style="font-size: 15px;">版本控制</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/翻墙/" style="font-size: 15px;">翻墙</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://blog.csdn.net/qq_25806863" title="csdn" target="_blank">csdn</a><ul></ul><a href="https://github.com/wangyisll" title="github" target="_blank">github</a><ul></ul><a href="http://www.jianshu.com/u/cb3133f5a1bd" title="简书" target="_blank">简书</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Sitemap</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">喵了个呜.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>