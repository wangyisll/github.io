<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>喵了个呜的小宇宙</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">喵了个呜的小宇宙</h1><a id="logo" href="/.">喵了个呜的小宇宙</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2017/04/06/Android设计模式（十七）-代理模式/">Android设计模式（十七）-代理模式</a></h2><div class="post-meta"><span class="date">2017-04-06</span><a href="/2017/04/06/Android设计模式（十七）-代理模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>代理模式也叫委托模式，是结构型设计模式。代理就是让别人帮你做事，比如帮你带饭，请律师打官司什么的。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为其他对象提供一种代理以控制对这个对象的访问。<br></div><p class="readmore"><a href="/2017/04/06/Android设计模式（十七）-代理模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/06/Android设计模式（十六）-中介者模式/">Android设计模式（十六）-中介者模式</a></h2><div class="post-meta"><span class="date">2017-04-06</span><a href="/2017/04/06/Android设计模式（十六）-中介者模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>中介者模式又叫调解者模式或调停者模式，是行为型设计模式之一。</p>
<p>生活中的中介者的作用就是连接两方的一个桥梁，比如房产中介，买房的只需跟中介打交道，然后买房的也跟着中介打交道，</p>
<p>没有中介的时候是这样的：</p>
<p><img src="http://privateimage.oss-cn-hongkong.aliyuncs.com/Sjms/%E4%B9%B0%E6%88%BF1.png" alt=""><br></div><p class="readmore"><a href="/2017/04/06/Android设计模式（十六）-中介者模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/05/Android设计模式（十五）-访问者模式/">Android设计模式（十五）-访问者模式</a></h2><div class="post-meta"><span class="date">2017-04-05</span><a href="/2017/04/05/Android设计模式（十五）-访问者模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>访问者模式是一种将数据操作与数据结构分离的设计模式。确实是我目前为止见过的最复杂的了。</p>
<p>访问者模式的思想是：</p>
<ul>
<li>软件系统中拥有一个由许多对象构成的，比较稳定的对象结构。这些对象都拥有一个accept方法来接受访问者的访问。</li>
<li>访问者是一个接口，对对象结构中的每一个元素都提供一个visit方法，对不同的访问对象执行不同的visit方法做出不同的处理。</li>
<li>在对象结构的一次访问中，遍历整个对象结构，对每一个元素执行accept方法，在每个accept方法中调用访问者的visit方法，从而使访问者可以处理对象结构中的每一个元素。</li>
<li>可以针对同一个对象结构，设计不同的访问者类，达到区别对待的目的。</div><p class="readmore"><a href="/2017/04/05/Android设计模式（十五）-访问者模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/05/Android设计模式（十四）-模板方法模式/">Android设计模式（十四）-模板方法模式</a></h2><div class="post-meta"><span class="date">2017-04-05</span><a href="/2017/04/05/Android设计模式（十四）-模板方法模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>模板方法模式，名字就很直接，也很容易理解。什么是模板，模板就是一套固定格式。我们可以想象一个普通员工的一天的上班模板：去公司上班-&gt;工作-&gt;下班回家。<br>对于每一个员工来说，这三个步骤的具体内容是不一样的，但是流程都是这样的。</p>
<p>在开发中也会有这种情况，架构师或者高级开发人员写好一些方法流程，规定方法名，方法输出，执行顺序等等，但是方法体是空的，留给初级的开发人员去填写具体的实现功能。<br>而且这样一套模板用不同的平台语言实现就可以生成不同平台的产品。这些解决方案都可以称为模板方法模式。<br></div><p class="readmore"><a href="/2017/04/05/Android设计模式（十四）-模板方法模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/05/Android设计模式（十三）-迭代器模式/">Android设计模式（十三）-迭代器模式</a></h2><div class="post-meta"><span class="date">2017-04-05</span><a href="/2017/04/05/Android设计模式（十三）-迭代器模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>迭代器模式又称游标模式，也是行为型设计模式。源于对容器的访问，主要解决容器的遍历操作。</p>
<p>我们队容器的访问必然会用到遍历。我们可以将遍历的方法封装到容器中，或者不提供遍历方法。如果封装在容器中，容器就承担了过多的功能。如果不提供遍历方法，使用者会自己去实现遍历方法，让容器内部细节暴露无遗。</p>
<p>因此在访问类和容器之间加上了第三者–迭代器。<br></div><p class="readmore"><a href="/2017/04/05/Android设计模式（十三）-迭代器模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/05/Android设计模式（十二）-备忘录模式/">Android设计模式（十二）-备忘录模式</a></h2><div class="post-meta"><span class="date">2017-04-05</span><a href="/2017/04/05/Android设计模式（十二）-备忘录模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>备用录模式是一种行为型设计模式，用于保存对象当前的状态，以便之后可以再次恢复到此状态。</p>
<p>备忘录模式要保证保存的对象状态不能被对象从外部访问，保护好被保存的这些对象状态的完整性以及内部实现不向外部暴露。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。<br></div><p class="readmore"><a href="/2017/04/05/Android设计模式（十二）-备忘录模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/04/Android设计模式（十一）-观察者模式/">Android设计模式（十一）-观察者模式</a></h2><div class="post-meta"><span class="date">2017-04-04</span><a href="/2017/04/04/Android设计模式（十一）-观察者模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>观察者模式是一种使用频率非常高的设计模式，最常用的地方就是订阅-发布系统。</p>
<p>这个模式的重要作用就是将观察者和被观察者解耦，使他们之间的依赖更小甚至没有。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义对象一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于他的对象都会得到通知并被自动更新。<br></div><p class="readmore"><a href="/2017/04/04/Android设计模式（十一）-观察者模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/01/Android设计模式（十）-命令模式/">Android设计模式（十）-命令模式</a></h2><div class="post-meta"><span class="date">2017-04-01</span><a href="/2017/04/01/Android设计模式（十）-命令模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>命令模式是行为型设计模式之一。命令模式没那么多条条框框，所以很灵活。命令模式简单的说就是给他下一个命令，然后他就会执行和这个命令的一系列操作。例如点击电脑的<code>关机</code>命令，系统会执行暂停，保存，关闭等一系列的命令，最后完成关机。</p>
<p>命令模式也跟关机一样，将一系列方法封装为一个方法，用户只要执行这个方法就会执行封装的一系列方法。不过真正用起来并不是这么直白简单。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求队列或者记录请求日志，以及支持可撤销的操作。<br></div><p class="readmore"><a href="/2017/04/01/Android设计模式（十）-命令模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/04/01/Android设计模式（九）-解释器模式/">Android设计模式（九）-解释器模式</a></h2><div class="post-meta"><span class="date">2017-04-01</span><a href="/2017/04/01/Android设计模式（九）-解释器模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>解释器模式是一种行为模式，实际开发中用的很少，提供了一种解释语言的语法或表达式的方式。</p>
<p>定义了一个表达式接口，通过接口解释一个特定的上下文。类似于json解析器按一定的语法解析json的。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。<br></div><p class="readmore"><a href="/2017/04/01/Android设计模式（九）-解释器模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/31/Android设计模式（八）-责任链模式/">Android设计模式（八）-责任链模式</a></h2><div class="post-meta"><span class="date">2017-03-31</span><a href="/2017/03/31/Android设计模式（八）-责任链模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>责任链模式是一个行为模式。责任链就是从一个起点发起请求，然后沿着任务链依次传递给每一个节点上的对象，直到有一个节点处理这个请求为止。听着是不是跟Android的事件分发机制很像。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递改请求，直到有对象处理它为止<br></div><p class="readmore"><a href="/2017/03/31/Android设计模式（八）-责任链模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/31/Android设计模式（七）-状态模式/">Android设计模式（七）-状态模式</a></h2><div class="post-meta"><span class="date">2017-03-31</span><a href="/2017/03/31/Android设计模式（七）-状态模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>状态模式看起来和策略模式很像，但是是两个不一样的设计模式。状态模式是一个类根据内部的状态动态的选择行为。策略模式一般用于算法，通过设置不同的策略类来执行不同的算法。状态模式的一个特点就是行为改变状态，而状态又导致行为的变化。策略模式是可以在运行时外部直接策略的，状态模式一般是不能替换的。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。<br></div><p class="readmore"><a href="/2017/03/31/Android设计模式（七）-状态模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（六）-策略模式/">Android设计模式（六）-策略模式</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（六）-策略模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>在开发中几女航遇见下面这种情况：实现同一个功能有很多不停的算法和策略，然后根据实际情况来选择不同的算法和策略。</p>
<p>一般的做法是在一个类里写不同的方法，然后根据实际情况用一连串的if-else或switch来选择对应的方法。这种方法多了后，这个类会变得臃肿，难以修改。</p>
<p>所以如果把不同的策略抽象出来，提供一个统一的接口，为每一个策略写一个实现类，这样客户端就能通过调用接口的不同的实现类来动态替换策略。这就是策略模式<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（六）-策略模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（五）-抽象工厂模式/">Android设计模式（五）-抽象工厂模式</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（五）-抽象工厂模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>在<a href="http://www.jianshu.com/p/31d1057c079c" target="_blank" rel="external">上一篇的工厂模式中</a>中，工厂生产出来的产品都是实现同一个接口或继承同一个抽象类的。而有时候工厂可以生产出不是同一个接口或抽象类的产品，也就是说生产出来的产品是不确定的，就是抽象工厂了。</p>
<p><a href="http://blog.csdn.net/qq_25806863/article/details/68063060#t3" target="_blank" rel="external">博客地址</a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为创建一组相关或相互依赖的对象提供一个接口，而无需指定他们的具体类。<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（五）-抽象工厂模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（四）续：Activity的onCreate是怎么调用的/">Android设计模式（四）续：Activity的onCreate是怎么调用的</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（四）续：Activity的onCreate是怎么调用的/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>这里分析的是app第一次启动时的第一个Activity的onCreate()方法的启动流程。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>先贴一下大致的流程图吧，不会画，很丑<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（四）续：Activity的onCreate是怎么调用的/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（四）-工厂方法模式/">Android设计模式（四）- 工厂方法模式</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（四）-工厂方法模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p>工厂方法模式也是创建型模式。<br>工厂模式根据抽象程度可以分为三种：简单工厂模式，工厂方法模式，抽象工厂模式。</p>
<p><a href="http://blog.csdn.net/qq_25806863/article/details/67110082" target="_blank" rel="external">博客地址</a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（四）-工厂方法模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（三）-原型模式/">Android设计模式（三）- 原型模式</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（三）-原型模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p><a href="http://blog.csdn.net/qq_25806863/article/details/66972873" target="_blank" rel="external">博客地址</a><br>原型模式也是一种创建型设计模式，从名字就能理解，这个模式应该有一个样板实例，也就是原型，然后用户从这个原型中复制出一个内部属性一致的实例，也就是克隆。<br>有时，一个对象的构造比较复杂并且比较耗时时，直接从已有对象复制一个实例比重新构造出来更高效。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（三）-原型模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（二）-续：WindowManager/">Android设计模式（二） 续：WindowManager</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（二）-续：WindowManager/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p><a href="http://blog.csdn.net/qq_25806863/article/details/66530372" target="_blank" rel="external">博客地址</a><br>通过前面的分析可以知道，Android系统中，所有的界面内容显示都是通过Window来实现的，包括Activity，Dialog，Toast等。<br>先初步分析一下Window，WindowManager，WindowManagerService的关系。</p>
<h1 id="获取WindowManager"><a href="#获取WindowManager" class="headerlink" title="获取WindowManager"></a>获取WindowManager</h1><p>从<a href="http://www.jianshu.com/p/0cdd78f01237" target="_blank" rel="external">Android设计模式（一）-单例模式</a>中后面的内容可以看到，系统在启动的时候就注册了许多服务。其中就有这样的代码：<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（二）-续：WindowManager/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（二）-Builder模式/">Android设计模式（二）- Builder模式</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（二）-Builder模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p><a href="http://blog.csdn.net/qq_25806863/article/details/66477142" target="_blank" rel="external">博客地址</a><br>Builder模式是一步一步创建复杂对象的创建型模式。允许用户在不知道内部构建细节的情况下，可以更精细的控制构造流程。该模式是为了将构建过程和表示分开，使构建过程和部件都可以自由扩展，两者的耦合度也降到最低。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（二）-Builder模式/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（一）续：LayoutInflater/">Android设计模式（一）续：LayoutInflater</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（一）续：LayoutInflater/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><h1 id="PhoneLayoutInflater"><a href="#PhoneLayoutInflater" class="headerlink" title="PhoneLayoutInflater"></a>PhoneLayoutInflater</h1></div><p class="readmore"><a href="/2017/03/30/Android设计模式（一）续：LayoutInflater/">Mehr lesen</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/30/Android设计模式（一）-单例模式/">Android设计模式（一）-单例模式</a></h2><div class="post-meta"><span class="date">2017-03-30</span><a href="/2017/03/30/Android设计模式（一）-单例模式/#comments" class="comment-count">Gästebuch</a></div><div class="post-content"><p><a href="http://blog.csdn.net/qq_25806863/article/details/66236371" target="_blank" rel="external">博客地址</a><br>最近在看《Android源码设计模式解析与实战》这本书，发现里面还有对源码的一些分析，之前也没好好看过设计模式，就来做个笔记，跟着看一下。<br>包括设计模式和一些源码分析。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br></div><p class="readmore"><a href="/2017/03/30/Android设计模式（一）-单例模式/">Mehr lesen</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/2/">Vorheriger</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Nächster</a></nav></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/将带有jni的Eclipse项目导入AndroidStudio遇到的问题/">将带有jni的Eclipse项目导入AndroidStudio遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/AVL树的旋转图解和简单实现/">AVL树的旋转图解和简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/查找二叉树的简单实现/">查找二叉树的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/ADB常用命令/">ADB常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/Android解压中文乱码/">Android解压中文乱码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/通过轮廓简单实现一个圆图/">通过轮廓简单实现一个圆图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/15/Kotlin让属性只能被赋值一次且不能为空/">Kotlin让属性只能被赋值一次且不能为空</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/对一个KotlinAPP的copy/">对一个KotlinAPP的copy</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/31/Android多线程-AsyncTask工作流程-源码/">Android多线程-AsyncTask工作流程(源码)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)/">Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/文字识别/" style="font-size: 15px;">文字识别</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/动画/" style="font-size: 15px;">动画</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/版本控制/" style="font-size: 15px;">版本控制</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/翻墙/" style="font-size: 15px;">翻墙</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://blog.csdn.net/qq_25806863" title="csdn" target="_blank">csdn</a><ul></ul><a href="https://github.com/wangyisll" title="github" target="_blank">github</a><ul></ul><a href="http://www.jianshu.com/u/cb3133f5a1bd" title="简书" target="_blank">简书</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Sitemap</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">喵了个呜.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/totop.js?v=2.0.1" async></script></body></html>