[{"title":"将带有jni的Eclipse项目导入AndroidStudio遇到的问题","date":"2017-07-11T01:35:29.000Z","path":"2017/07/11/将带有jni的Eclipse项目导入AndroidStudio遇到的问题/","text":"当然前提是本地已经配置好了ndk的环境 1. NDK integration is deprecated in the current plugin首次编译遇到一个错误： 12345FAILURE: Build failed with an exception.* What went wrong:Execution failed for task &apos;:app:compileDebugNdk&apos;.&gt; Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set &quot;$USE_DEPRECATED_NDK=true&quot; in gradle.properties to continue using the current NDK integration. 解决 先在module下新建文件，gradle.properties 文件中写上一句 android.useDeprecatedNdk=true 然后重新build就没这个问题了 2. Native C/C++ source code is found, but it seems that NDK option is not configured123456789Warning: Native C/C++ source code is found, but it seems that NDK option is not configured. Note that if you have an Android.mk, it is not used for compilation. The recommended workaround is to remove the default jni source code directory by adding: android &#123; sourceSets &#123; main &#123; jni.srcDirs = [] &#125; &#125;&#125;to build.gradle, manually compile the code with ndk-build, and then place the resulting shared object in src/main/jniLibs. build失败在Gradle Console中会打印这个信息 解决其中一种方法就是，就按他提示的吧，加上 sourceSets { main { jni.srcDirs = [] } } 再次build ，： BUILD SUCCESSFUL","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"AVL树的旋转图解和简单实现","date":"2017-07-07T01:56:59.000Z","path":"2017/07/07/AVL树的旋转图解和简单实现/","text":"AVL树是带有平衡条件的查找二叉树。这个平衡条件要容易保持，而且他要保证树的深度为O(logN) 原文地址：http://blog.csdn.net/qq_25806863/article/details/74755131 平衡条件一个最理想的平衡条件是左右两个子树的高度完全相等，但只有节点数量为2^n-1的树才满足这个条件（n是层数，2层要3个，3层要7个）。这个条件太严格，不好用。 如果只要求根节点平衡的话，上面的条件可能会容易实现一点，但是会出现下面这样坏的二叉树： 因此一颗AVL树的条件是，对于每个节点来说，这个节点的左右子树的高度最多差1. 简单示例AVL树： 非AVL二叉树： 旋转在每一次插入数值之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–旋转。 旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 通过旋转可以降低高度。 所谓的左旋和右旋都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行。 如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。 如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。 插入节点时分四种情况，四种情况对应的旋转方法是不同的： 例如对于被破坏平衡的节点 a 来说： 插入方式 描述 旋转方式 LL 在a的左子树根节点的左子树上插入节点而破坏平衡 右旋转 RR 在a的右子树根节点的右子树上插入节点而破坏平衡 左旋转 LR 在a的左子树根节点的右子树上插入节点而破坏平衡 先左旋后右旋 RL 在a的右子树根节点的左子树上插入节点而破坏平衡 先右旋后左旋 1.LL 右旋转就拿最简单的举例了。 一个简单的AVL树： 这时是平衡的，如果在插入一个元素3，就会变成下面这样，破坏平衡： 被破坏了平衡首先要找到是哪个树被破坏了平衡，然后调整这个树。然后继续往上一个一个的调整。 既然是被新插入的节点3破坏的，那么不平衡的树一定在从新插入的节点3到根节点8的路径上。找离新插入的节点最近的不平衡的树进行调整，上图中就是7. 节点7的左子树 高度为1，右子树为空，高度为-1 ，不平衡。根据表格要进行右旋转。 先把7这颗不平衡的树挑出来： 这棵树是最近的不平衡的树，7的左子树5高度为1，右子树为空，所以右子树高度是-1.两者的高度差达到了2，超过了1. 因为左子树5的高度更高，所以要把左子树5向上提一下，这时旋转就很明显了，抓着5向上一提，7就掉到5的右边了，成了5的右子树。 这个过程就是右旋： 这时继续往上找，发现每个节点都符合了平衡条件，所以整棵树就变成了AVL树。 那如果节点5本来就有了右子树呢？照样右旋转，只要把原来5的右子树变成旋转后的7的左子树就行了。因为5的右子树肯定比5大，但是也肯定比7小的： 其实上面最后旋转成的树是下面这样的： 这棵树的根节点是不平衡的，还需要使用后面的双旋转来调整。 使用LR先左旋后右旋调整后是这样的，具体方法看后面的： 2. RR 左旋转在右子树的右子树上插入节点破坏的平衡需要左旋转来矫正。 左旋转和右旋转类似，都是单旋转，给个流程图。 3. LR 先左旋再右旋如果在第一个例子中插入的不是3，而是6，就成了下面的样子，依然说破坏了平衡 被破坏平衡的树依然是7，但是这次就不能通过一次旋转解决了，咋转都不行。 要从6开始到7进行先左旋再右旋才可以矫正平衡： 4. RL 先右旋再左旋当破坏平衡的节点是这个树的右子树的左子树时，要进行先右旋转再左旋转来矫正。 同样是从破坏平衡的那个节点开始旋转，先右旋转后左旋转： 简单实现首先建立一个节点类： 12345678910111213141516private static class AVLNode&lt;E&gt; &#123; E element; AVLNode&lt;E&gt; left; AVLNode&lt;E&gt; right; int height; public AVLNode(E element) &#123; this(element, null, null); &#125; public AVLNode(E element, AVLNode&lt;E&gt; left, AVLNode&lt;E&gt; right) &#123; this.element = element; this.left = left; this.right = right; &#125;&#125; 以及一个插入方法insert()，删除方法remove()，求高度的方法height() 整个类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262public class MyAVLTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private AVLNode root; public MyAVLTree() &#123; this.root = null; &#125; public void insert(E x) &#123; root = insert(x, root); &#125; public void remove(E x) &#123; remove(x, root); &#125; public int height() &#123; return height(root); &#125; /** * 插入新数据 */ public AVLNode&lt;E&gt; insert(E x, AVLNode&lt;E&gt; t) &#123; if (t == null) &#123; return new AVLNode&lt;E&gt;(x); &#125; //先比较 是插左边还是插右边 int compareResult = x.compareTo(t.element); if (compareResult &lt; 0) &#123;//插到左子树上 t.left = insert(x, t.left); //插入之后要判断是否打破了平衡，因为插入的是左子树， // 只有左子树才会打破平衡，用左子树的高减去右子树的高 if (height(t.left) - height(t.right) == 2) &#123; //如果等于2，说明平衡被打破了，需要进行调整。就看选择什么方法调整 if (x.compareTo(t.left.element) &lt; 0) &#123; //如果x小于t的左子树的值，那么x会被插到t的左子树的左子树上，符合LL 用右旋转调整。 t = rightRotate(t); &#125; else &#123; //如果x大于t的左子树的值，则会被插到t的左子树的右子树上，符合LR，用先左旋转后右旋转来矫正。 t = leftAndRightRotate(t); &#125; &#125; &#125; else if (compareResult &gt; 0) &#123;//插到右子树上，逻辑和上面一样。 t.right = insert(x, t.right); if (height(t.right) - height(t.left) == 2) &#123; if (x.compareTo(t.right.element) &gt; 0) &#123; t = leftRotate(t); &#125; else &#123; t = rightAndLeftRotate(t); &#125; &#125; &#125; else &#123; //已经有这个值了 &#125; t.height = Math.max(height(t.left), height(t.right)) + 1; return t; &#125; /** * 删除数据 */ private AVLNode&lt;E&gt; remove(E x, AVLNode&lt;E&gt; t) &#123; if (t == null) return null; int compareResult = x.compareTo(t.element); if (compareResult &lt; 0) &#123; t.left = remove(x, t.left); //完了之后验证该子树是否平衡 if (t.right != null) &#123; //若右子树为空，则一定是平衡的，此时左子树相当对父节点深度最多为1, 所以只考虑右子树非空情况 if (t.left == null) &#123; //若左子树删除后为空，则需要判断右子树 if (height(t.right) - t.height == 2) &#123; AVLNode&lt;E&gt; k = t.right; if (k.right != null) &#123; //右子树存在，按正常情况单旋转 t = leftRotate(t); &#125; else &#123; //否则是右左情况，双旋转 t = rightAndLeftRotate(t); &#125; &#125; &#125; if (t.left!=null)&#123; //否则判断左右子树的高度差 //左子树自身也可能不平衡，故先平衡左子树，再考虑整体 AVLNode&lt;E&gt; k = t.left; //删除操作默认用右子树上最小节点补删除的节点 //k的左子树高度不低于k的右子树 if (k.right != null) &#123; if (height(k.left) - height(k.right) == 2) &#123; AVLNode&lt;E&gt; m = k.left; if (m.left != null) &#123; //左子树存在，按正常情况单旋转 k = rightRotate(k); &#125; else &#123; //否则是左右情况，双旋转 k = leftAndRightRotate(k); &#125; &#125; &#125; else &#123; if (height(k.left) - k.height == 2) &#123; AVLNode&lt;E&gt; m = k.left; if (m.left != null) &#123; //左子树存在，按正常情况单旋转 k = rightRotate(k); &#125; else &#123; //否则是左右情况，双旋转 k = leftAndRightRotate(k); &#125; &#125; &#125; if (height(t.right) - height(t.left) == 2) &#123; //右子树自身一定是平衡的，左右失衡的话单旋转可以解决问题 t = leftRotate(t); &#125; &#125; &#125; //完了之后更新height值 t.height = Math.max(height(t.left), height(t.right)) + 1; &#125; else if (compareResult &gt; 0) &#123; t.right = remove(x, t.right); //下面验证子树是否平衡 if (t.left != null) &#123; //若左子树为空，则一定是平衡的，此时右子树相当对父节点深度最多为1 t = balanceChild(t); &#125; //完了之后更新height值 t.height = Math.max(height(t.left), height(t.right)) + 1; &#125; else if (t.left != null &amp;&amp; t.right != null) &#123; //默认用其右子树的最小数据代替该节点的数据并递归的删除那个节点 AVLNode&lt;E&gt; min = t.right; while (min.left != null) &#123; min = min.left; &#125;// t.element = findMin(t.right).element; t.element = min.element; t.right = remove(t.element, t.right); t = balanceChild(t); //完了之后更新height值 t.height = Math.max(height(t.left), height(t.right)) + 1; &#125; else &#123; t = (t.left != null) ? t.left : t.right; &#125; return t; &#125; private AVLNode&lt;E&gt; balanceChild(AVLNode&lt;E&gt; t) &#123; if (t.right == null) &#123; //若右子树删除后为空，则只需判断左子树与根的高度差 if (height(t.left) - t.height == 2) &#123; AVLNode&lt;E&gt; k = t.left; if (k.left != null) &#123; t = rightRotate(t); &#125; else &#123; t = leftAndRightRotate(t); &#125; &#125; &#125; else &#123; //若右子树删除后非空，则判断左右子树的高度差 //右子树自身也可能不平衡，故先平衡右子树，再考虑整体 AVLNode&lt;E&gt; k = t.right; //删除操作默认用右子树上最小节点（靠左）补删除的节点 if (k.left != null) &#123; if (height(k.right) - height(k.left) == 2) &#123; AVLNode&lt;E&gt; m = k.right; if (m.right != null) &#123; //右子树存在，按正常情况单旋转 k = leftRotate(k); &#125; else &#123; //否则是右左情况，双旋转 k = rightAndLeftRotate(k); &#125; &#125; &#125; else &#123; if (height(k.right) - k.height == 2) &#123; AVLNode&lt;E&gt; m = k.right; if (m.right != null) &#123; //右子树存在，按正常情况单旋转 k = leftRotate(k); &#125; else &#123; //否则是右左情况，双旋转 k = rightAndLeftRotate(k); &#125; &#125; &#125; //左子树自身一定是平衡的，左右失衡的话单旋转可以解决问题 if (height(t.left) - height(t.right) == 2) &#123; t = rightRotate(t); &#125; &#125; return t; &#125; /** * 右旋转 * * @param t 需要调整的树 * @return 调整后的树 */ private AVLNode&lt;E&gt; rightRotate(AVLNode&lt;E&gt; t) &#123; AVLNode newTree = t.left; t.left = newTree.right; newTree.right = t; t.height = Math.max(height(t.left), height(t.right)) + 1; newTree.height = Math.max(height(newTree.left), height(newTree.right)) + 1; return newTree; &#125; /** * 左旋转 */ private AVLNode&lt;E&gt; leftRotate(AVLNode t) &#123; AVLNode&lt;E&gt; newTree = t.right; t.right = newTree.left; newTree.left = t; t.height = Math.max(height(t.left), height(t.right)) + 1; newTree.height = Math.max(height(newTree.left), height(newTree.right)) + 1; return newTree; &#125; /** * 先左旋后右旋 */ private AVLNode&lt;E&gt; leftAndRightRotate(AVLNode&lt;E&gt; t) &#123; t.left = leftRotate(t.left); return rightRotate(t); &#125; /** * 先右旋后左旋 */ private AVLNode&lt;E&gt; rightAndLeftRotate(AVLNode&lt;E&gt; t) &#123; t.right = rightRotate(t.right); return leftRotate(t); &#125; /** * 获取指定树的高度 */ private int height(AVLNode&lt;E&gt; t) &#123; return t == null ? -1 : t.height; &#125; public void printTree() &#123; printTree(root); &#125; private void printTree(AVLNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return; &#125; System.out.print(tree.element + \" \"); printTree(tree.left); printTree(tree.right); &#125; private static class AVLNode&lt;E&gt; &#123; E element; AVLNode&lt;E&gt; left; AVLNode&lt;E&gt; right; int height; public AVLNode(E element) &#123; this(element, null, null); &#125; public AVLNode(E element, AVLNode&lt;E&gt; left, AVLNode&lt;E&gt; right) &#123; this.element = element; this.left = left; this.right = right; &#125; &#125;&#125; 测试拿一般的查找二叉树和avl树进行比较，从0到9插入10个数据，打印先序遍历： 1234567891011121314151617public static void main(String[] args) &#123; MySearchTree&lt;Integer&gt; searchTree = new MySearchTree&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; searchTree.insert(i); &#125; System.out.println(\"```\"); MyAVLTree&lt;Integer&gt; avlTree = new MyAVLTree&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; avlTree.insert(i); System.out.println(\"插入\"+i+\"后整颗树的高 \" + avlTree.height()); &#125; System.out.println(\"一般二叉查找树的先序遍历:\"); searchTree.printTree(); System.out.println(); System.out.println(\"AVL树的先序遍历:\"); avlTree.printTree();&#125; 根据这个遍历可以画出这个二叉树： 一般的二叉树就不用画了，根节点为0 ，一路向右走到底。超级不平衡！ 参考《数据结构与算法分析java版》 remove方法参考http://blog.csdn.net/liyong199012/article/details/29219261","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.miaolegewu.top/tags/数据结构/"},{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"}]},{"title":"查找二叉树的简单实现","date":"2017-07-07T01:33:56.000Z","path":"2017/07/07/查找二叉树的简单实现/","text":"查找二叉树首先也是个二叉树，符合二叉树的一切特点。 原文地址:http://blog.csdn.net/qq_25806863/article/details/74638590 简单介绍但是查找二叉树要求对树中的每个节点，这个节点的左子树中所有的值要小于自己，右子树中所有的值要大于自己。 下面是两个的区别： 查找二叉树： 不是查找二叉树： 简单实现主要是查询，插入和删除的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class MySearchTree&lt;E extends Comparable&lt;E&gt;&gt; &#123; private BinaryNode&lt;E&gt; root; public MySearchTree() &#123; root = null; &#125; public void makeEmpty() &#123; root = null; &#125; public boolean isEmpty() &#123; return root == null; &#125; public boolean contains(E x) &#123; return contains(x, root); &#125; public E findMin() &#123; return findMin(root).element; &#125; public E findMax() &#123; return findMax(root).element; &#125; public void insert(E x) &#123; root = insert(x, root); &#125; public void remove(E x) &#123; remove(x, root); &#125; public void printTree() &#123; printTree(root); &#125; /** * 如果这个树上的值就是要查找的x，返回true * 如果树为空，说明不存在这个值，返回false * 如果x小于这个树上的值，就在这个树的左子树上递归查找 * 如果x大于这个树上的值，就在这个树的右子树上递归查找 */ private boolean contains(E x, BinaryNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return false; &#125; int compareResult = x.compareTo(tree.element); if (compareResult &lt; 0) &#123; return contains(x, tree.left); &#125; else if (compareResult &gt; 0) &#123; return contains(x, tree.right); &#125; else &#123; return true; &#125; &#125; /** * 只要有左子树就一直往左找，左子树为空说明这个就是最小值 */ private BinaryNode&lt;E&gt; findMin(BinaryNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return null; &#125; else if (tree.left == null) &#123; return tree; &#125; else &#123; return findMin(tree.left); &#125; &#125; /** * 只要有右子树就一直往左找，右子树为空说明这个就是最大值 */ private BinaryNode&lt;E&gt; findMax(BinaryNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return null; &#125; else if (tree.right == null) &#123; return tree; &#125; else &#123; return findMax(tree.right); &#125; &#125; /** * 如果要插入的树是null，说明这个就是要插入的值该放的位置，new一个子树，绑定到对应的父亲上 * 如果树不为null，说明这个树上有值，拿x和这个值进行比较 * 如果两个值相等，说明已经有这个值了，可以进行一些处理 * 如果x小于树上的值，就往该树的左子树上递归插入 * 如果x大于树上的值，就往该树的右子树上递归插入 */ private BinaryNode&lt;E&gt; insert(E x, BinaryNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return new BinaryNode&lt;E&gt;(x, null, null); &#125; int compareResult = x.compareTo(tree.element); if (compareResult &lt; 0) &#123; tree.left= insert(x, tree.left); &#125; else if (compareResult &gt; 0) &#123; tree.right = insert(x, tree.right); &#125; else &#123; //说明已经有这个值了。 System.out.println(\"已经有这个值了\"); &#125; return tree; &#125; /** * 比较x和树的值 * 如果x小于树的值，在树的左子树中递归删除 * 如果x大于树的值，在树的右子树中递归删除 * 如果x等于树的值，那么这个值就是要删除的值。 * 因为删除一个值就要对树进行重新排列，所以这个位置上不能空。 * 如果这个树只有一个子树，那么就直接把这个子树放在这个位置上 * 如果这个树有两个子树，那么需要找到右子树的最小值，将这个最小值赋值在要删除的位置上， * 然后递归调用从右子树中删除刚刚找到的这个最小值 */ private BinaryNode&lt;E&gt; remove(E x, BinaryNode&lt;E&gt; tree) &#123; if (tree == null) &#123; //没有这个树 return tree; &#125; int compareResult = x.compareTo(tree.element); if (compareResult &lt; 0) &#123; tree.left = remove(x, tree.left); &#125; else if (compareResult &gt; 0) &#123; tree.right = remove(x, tree.right); &#125; else if (tree.left != null &amp;&amp; tree.right != null) &#123; tree.element = findMin(tree.right).element; tree.right = remove(tree.element, tree.right); &#125; else &#123; tree = (tree.left != null) ? tree.left : tree.right; &#125; return tree; &#125; private void printTree(BinaryNode&lt;E&gt; tree) &#123; if (tree == null) &#123; return; &#125; System.out.print(tree.element+\" \"); printTree(tree.left); printTree(tree.right); &#125; public static class BinaryNode&lt;E&gt; &#123; E element; BinaryNode&lt;E&gt; left; BinaryNode&lt;E&gt; right; public BinaryNode(E element) &#123; this(element, null, null); &#125; public BinaryNode(E element, BinaryNode&lt;E&gt; left, BinaryNode&lt;E&gt; right) &#123; this.element = element; this.left = left; this.right = right; &#125; &#125;&#125; 实现的缺点在代码中，注意remove方法中的一段代码： 123else if (tree.left != null &amp;&amp; tree.right != null) &#123; tree.element = findMin(tree.right).element; tree.right = remove(tree.element, tree.right); 这里对删除的处理是，找到右子树中的最小值，把这个最小值放在当前节点上，然后从右子树中删除这个值。 而在insert的时候，是根据比较而随机的插入在左右子树上的。 所以如果交叉调用insert和remove很多次的话，这个二叉树会变得很不平衡，即左右子树的高度差很大。 这种平衡的查找二叉树叫平衡查找树。 一个最古老的平衡查找树是AVL树。 参考《数据结构与算法分析java版》","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.miaolegewu.top/tags/数据结构/"},{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"}]},{"title":"ADB常用命令","date":"2017-06-27T02:06:46.000Z","path":"2017/06/27/ADB常用命令/","text":"一些用过的ADB命令，有些需要root。 可以直接在终端中输入使用。 也可以在APP中使用。 点击 x=600 y=600adb shell input tap 600 600 长按 x=600 y=600adb shell input touchscreen swipe 600 600 600 600 2000 滑动 从(500,500)滑动到(700,500)adb shell input swipe 500 500 700 500 查看apk的包名和启动页面名aapt dump badging xx.apk 查看手机启动的Activity和页面启动时间adb logcat -v time -s ActivityManager 比如打开设置页面，终端中会打印： 1234506-27 10:20:11.401 I/ActivityManager( 840): START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.android.settings/com.oppo.settings.SettingsActivity&#125; from pid 165506-27 10:20:11.401 E/ActivityManager( 840): START &#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.android.settings/com.oppo.settings.SettingsActivity u=0&#125; from pid 165506-27 10:20:11.711 I/ActivityManager( 840): Displayed com.android.settings/com.oppo.settings.SettingsActivity: +93ms (total +6s60ms) 启动页面如上面的页面 com.android.settings/com.oppo.settings.SettingsActivity adb shell am start com.android.settings/com.oppo.settings.SettingsActivity 通过包名卸载程序adb shell pm uninstall com.xxx.xxx 通过adb 无线调试真机 连USB线 adb tcpip 5555 可以拔线 adb connect xxx.xxx.x.xx xxx.xxx.x.xx是手机ip。可以调试了 断开： adb disconnect 或切换USB adb usb","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"Android解压中文乱码","date":"2017-06-23T08:40:32.000Z","path":"2017/06/23/Android解压中文乱码/","text":"在Android中内置有解压的工具，一般可以使用下面的方法解压： \u0003注意import的包： 因123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.zip.ZipEntry;import java.util.zip.ZipFile;/** * 解压缩一个文件 * * @param zipFile 压缩文件 * @param folderPath 解压缩的目标目录 * @throws IOException 当解压缩过程出错时抛出 */ public static void upZipFile(File zipFile, String folderPath) throws ZipException, IOException &#123; File desDir = new File(folderPath); if (!desDir.exists()) &#123; desDir.mkdirs(); &#125; ZipFile zf = new ZipFile(zipFile); for (Enumeration&lt;?&gt; entries = zf.entries(); entries.hasMoreElements();) &#123; ZipEntry entry = ((ZipEntry)entries.nextElement()); InputStream in = zf.getInputStream(entry); if(entry.getName().indexOf(\"__MACOSX\")&gt;=0)&#123; continue; &#125; String str = folderPath + File.separator + entry.getName(); str = new String(str.getBytes(\"8859_1\"), \"UTF-8\"); File desFile = new File(str); if (!desFile.exists()) &#123; File fileParentDir = desFile.getParentFile(); if (!fileParentDir.exists()) &#123; fileParentDir.mkdirs(); &#125; desFile.createNewFile(); &#125; OutputStream out = new FileOutputStream(desFile); byte buffer[] = new byte[BUFF_SIZE]; int realLength; while ((realLength = in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, realLength); &#125; in.close(); out.close(); &#125; &#125; 但是在解压遇到中文的时候，解压出来中文会变成乱码，把上面的编码改成啥都没用。 果这时候可以使用apache-ant-zip的解压包来解决： 先将apache-ant-zip.jar加入依赖，下载地址：http://download.csdn.net/detail/qq_25806863/9878967 然后使用这个包中的引用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.tools.zip.ZipEntry;import org.apache.tools.zip.ZipFile;public static void upZipFile(File zipFile, String folderPath) throws IOException &#123; OutputStream os = null; InputStream is = null; ZipFile zf = null; try &#123; zf = new ZipFile(zipFile,\"UTF-8\"); String directoryPath = \"\"; directoryPath = folderPath; Enumeration entryEnum = zf.getEntries(); if (null != entryEnum) &#123; ZipEntry zipEntry = null; while (entryEnum.hasMoreElements()) &#123; zipEntry = (ZipEntry) entryEnum.nextElement(); if (zipEntry.isDirectory()) &#123; //不处理文件夹 directoryPath = directoryPath + File.separator + zipEntry.getName(); System.out.println(directoryPath); continue; &#125; if (zipEntry.getSize() &gt; 0) &#123; File targetFile = new File(directoryPath+ File.separator + zipEntry.getName()); if (!targetFile.exists()) &#123; //如果不存在就创建 File fileParentDir = targetFile.getParentFile(); if (!fileParentDir.exists()) &#123; fileParentDir.mkdirs(); &#125; targetFile.createNewFile(); &#125; os = new BufferedOutputStream(new FileOutputStream(targetFile)); is = zf.getInputStream(zipEntry); byte[] buffer = new byte[4096]; int readLen = 0; while ((readLen = is.read(buffer, 0, 1024)) &gt;= 0) &#123; os.write(buffer, 0, readLen); &#125; os.flush(); os.close(); &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw ex; &#125; finally &#123; if (null != is) &#123; is.close(); &#125; if (null != os) &#123; os.close(); &#125; &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"通过轮廓简单实现一个圆图","date":"2017-06-23T07:26:13.000Z","path":"2017/06/23/通过轮廓简单实现一个圆图/","text":"实现圆图的方法有很多种，这是一种使用轮廓和剪切。 通过setOutLineProvider提供一个轮廓 通过setClipToOutLine(true)来让视图按轮廓剪切 代码很简单： 布局activity_main.xml，上面是原图，下面是圆图： 123456789101112131415161718&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#9f9\" android:orientation=\"vertical\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"150dp\" android:scaleType=\"centerInside\" android:src=\"@drawable/cat\" /&gt; &lt;ImageView android:id=\"@+id/iv1\" android:layout_width=\"match_parent\" android:layout_height=\"150dp\" android:src=\"@drawable/cat\"/&gt;&lt;/LinearLayout&gt; 代码： 1234567891011121314151617181920class MainActivity : AppCompatActivity() &#123; private val TAG = javaClass.simpleName override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) with(iv1) &#123; scaleType = ImageView.ScaleType.CENTER_INSIDE clipToOutline = true outlineProvider = object : ViewOutlineProvider() &#123; override fun getOutline(view: View?, outline: Outline) &#123; view as ImageView val radius = Math.min(view.width, view.height) / 2 val centerX = (view.right - view.left) / 2 val centerY = (view.bottom - view.top) / 2 outline.setOval(centerX - radius, centerY - radius, centerX + radius, centerY + radius) &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"Kotlin让属性只能被赋值一次且不能为空","date":"2017-06-15T03:32:48.000Z","path":"2017/06/15/Kotlin让属性只能被赋值一次且不能为空/","text":"有时候要求一个属性只能赋值一次，且不能为空，可以用下面的方法 本文地址： http://blog.csdn.net/qq_25806863/article/details/73277876 用get和set利用属性的get()和set()对值进行控制： 123456789101112131415class APP : Application() &#123; companion object &#123; var app: Application? = null set(value) &#123; field = if (field == null&amp;&amp; value!=null) value else throw IllegalStateException(\"不能设置为null，或已经有了\") &#125; get() &#123; return field ?: throw IllegalStateException(\"还没有被赋值\") &#125; &#125; override fun onCreate() &#123; super.onCreate() app = this &#125;&#125; 用委托实现自定义一个委托属性： 123456789class NotNUllSingleVar&lt;T&gt; : ReadWriteProperty&lt;Any?, T&gt; &#123; private var value: T? = null override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T &#123; return value ?: throw IllegalStateException(&quot;还没有被赋值&quot;) &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) &#123; this.value = if (this.value == null&amp;&amp;value!=null) value else throw IllegalStateException(&quot;不能设置为null，或已经有了&quot;) &#125;&#125; 然后对属性使用就行了： 123456789class APP : Application() &#123; companion object &#123; var app: Application? by NotNUllSingleVar() &#125; override fun onCreate() &#123; super.onCreate() app = this &#125;&#125; 这样所有需要实现这个需求的属性都可以用这个委托来实现。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.miaolegewu.top/tags/Kotlin/"}]},{"title":"对一个KotlinAPP的copy","date":"2017-06-14T01:40:39.000Z","path":"2017/06/14/对一个KotlinAPP的copy/","text":"最近看了下Kotlin。随便找了个简单的地址就开始了copy。真的是copy，代码结构，布局，图片等都是copy的。 本文地址： http://blog.csdn.net/qq_25806863/article/details/73209612 主要是为了体验一下Kotlin在Android开发中是什么样子的。 copy对象就是几百个Gank的其中一个：https://github.com/onlyloveyd/GankIOWithKotlin 也可以他博客看一下 http://blog.csdn.net/poorkick/article/details/72510645 非常感谢大神的分享，copy的结果就是：https://github.com/wangyisll/gankapplication/tree/master 图什么就不放了，跟原来那个一样，就是颜色变了一下 因为使用了Kotlin Android Extensions，所以我觉得没必要再用ButterKnife了，所以就删掉了。 哈哈，下面记录一下copy中感受到的不同，都只是一部分示例，更多的可以看代码进行比较。 这是大神的java版 https://github.com/onlyloveyd/GankIOClient 这是大神的kotlin版 https://github.com/onlyloveyd/GankIOWithKotlin 具体语法还是看官方语法文档吧。 1.Kotlin Android Extensions这是Kotlin官方的扩展，可以省去finViewById 如在activity_main.xml中有这样的布局： 123456789101112131415&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolBar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorPrimary\" android:fitsSystemWindows=\"true\" android:titleTextColor=\"@color/white\"/&gt; &lt;/LinearLayout&gt; 上面的id为toolBar，所以在代码中可以直接使用id来表示这个空间，跟ButterKnife一样。 先引入: 1import kotlinx.android.synthetic.main.activity_main.* 然后就能直接在代码中使用了： 1setSupportActionBar(toolBar) 2.对属性的引用在Kotlin中，控件的大部分get和set的属性都能直接向下面这样用： 123tvTitle.setText(\"a\")//写成tvTitle.text = \"a\" 3.单例在原来的额网络请求类单例是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class HttpMethods &#123; public static final String BASE_URL = \"http://gank.io/api/\"; private static final int DEFAULT_TIMEOUT = 5; private Retrofit retrofit; private ContentService contentService; private OkHttpClient mOkHttpClient; //构造方法私有 private HttpMethods() &#123; //手动创建一个OkHttpClient并设置超时时间 OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder(); httpClientBuilder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS); mOkHttpClient = httpClientBuilder.build(); retrofit = new Retrofit.Builder().client(mOkHttpClient) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(BASE_URL) .build(); contentService = retrofit.create(ContentService.class); &#125; //获取单例 public static HttpMethods getInstance() &#123; return SingletonHolder.INSTANCE; &#125; /** * 用于获取干货数据 * * @param subscriber 由调用者传过来的观察者对象 * @param category 类别 * @param pagesize 请求数据个数 * @param pagenum 页码 */ public void getData(Observer&lt;DataBean&gt; subscriber, String category, String pagesize, int pagenum) &#123; contentService.getContent(category, pagesize, pagenum) .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 。。。 //在访问HttpMethods时创建单例 private static class SingletonHolder &#123; private static final HttpMethods INSTANCE = new HttpMethods(); &#125;&#125; 在Kotlin中，单例直接这样写： 123456789101112131415161718192021222324252627object RetrofitClient &#123; private val retrofit: Retrofit private val api: RetrofitApiService private val baseUrl = \"http://gank.io/api/\" init &#123; val httpclient = OkHttpClient.Builder() httpclient.connectTimeout(10, TimeUnit.SECONDS) retrofit = Retrofit.Builder().client(httpclient.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(baseUrl) .build() api = retrofit.create(RetrofitApiService::class.java) &#125; /** * 获取干货数据 */ fun getData(subscriber: Observer&lt;TypeData&gt;, category: String, pageSize: String, pageNum: Int) &#123; api.getContent(category, pageSize, pageNum) .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .safeSubscribe(subscriber) &#125;&#125; class变成了object,然后下面这样使用就是单例的，那些方法就跟变成了static一样，直接调用： 1RetrofitClient.getData(...) 4.常量类的定义java中的常量类一般是这样的： 123456public class Constant &#123; public static final long ONE_SECOND = 1000; public static final long ONE_MINUTE = ONE_SECOND * 60; public static final long ONE_HOUR = ONE_MINUTE * 60; public static final long ONE_DAY = ONE_HOUR * 24;&#125; 在Kotlin中可以写成这样： 123456object Constant &#123; val ONE_SECOND: Long = 1000 val ONE_MINUTE = ONE_SECOND * 60 val ONE_HOUR = ONE_MINUTE * 60 val ONE_DAY = ONE_HOUR * 24&#125; 使用起来都是一样的 Constant.ONE_SECOND，但是省掉了好多public static final 5.集合的定义java中集合的初始化是这样的： 1234567891011121314151617181920212223242526public static HashMap&lt;String, Integer&gt; sTypeColor = new HashMap&lt;String, Integer&gt;() &#123; &#123; put(\"Android\", R.drawable.bg_android_tag); put(\"iOS\", R.drawable.bg_ios_tag); put(\"瞎推荐\", R.drawable.bg_rec_tag); put(\"拓展资源\", R.drawable.bg_res_tag); put(\"App\", R.drawable.bg_app_tag); put(\"福利\", R.drawable.bg_bonus_tag); put(\"前端\", R.drawable.bg_js_tag); put(\"休息视频\", R.drawable.bg_video_tag); &#125; &#125;; public static ArrayList&lt;String&gt; sCategoryList = new ArrayList&lt;String&gt;() &#123; &#123; add(\"all\"); add(\"Android\"); add(\"瞎推荐\"); add(\"iOS\"); add(\"前端\"); add(\"拓展资源\"); add(\"App\"); add(\"休息视频\"); add(\"福利\"); &#125; &#125;; 在Kotlin中也可以写成类似的： 1234567891011121314151617181920212223242526var sTypeColor: HashMap&lt;String, Int&gt; = object : HashMap&lt;String, Int&gt;() &#123; init &#123; put(\"Android\", R.drawable.bg_android_tag) put(\"iOS\", R.drawable.bg_ios_tag) put(\"瞎推荐\", R.drawable.bg_rec_tag) put(\"拓展资源\", R.drawable.bg_res_tag) put(\"App\", R.drawable.bg_app_tag) put(\"福利\", R.drawable.bg_bonus_tag) put(\"前端\", R.drawable.bg_js_tag) put(\"休息视频\", R.drawable.bg_video_tag) &#125; &#125; var sCategoryList: ArrayList&lt;String&gt; = object : ArrayList&lt;String&gt;() &#123; init &#123; add(\"all\") add(\"Android\") add(\"瞎推荐\") add(\"iOS\") add(\"前端\") add(\"拓展资源\") add(\"App\") add(\"休息视频\") add(\"福利\") &#125; &#125; 更可以写成下面的简单的： 12345678910var sTypeColor = mutableMapOf(\"Android\" to R.drawable.bg_android_tag, \"iOS\" to R.drawable.bg_ios_tag, \"瞎推荐\" to R.drawable.bg_rec_tag, \"拓展资源\" to R.drawable.bg_res_tag, \"App\" to R.drawable.bg_app_tag, \"福利\" to R.drawable.bg_bonus_tag, \"前端\" to R.drawable.bg_js_tag, \"休息视频\" to R.drawable.bg_video_tag) var sCategoryList = mutableListOf(\"all\", \"Android\", \"瞎推荐\", \"iOS\", \"前端\", \"拓展资源\", \"App\", \"休息视频\", \"福利\") 又省了好多代码…. 6.anko的startActivity启动一个Activity是很常用的，通过anko可以快速启动一个Activity： 先导入，一般都是自动引用 1import org.jetbrains.anko.startActivity 然后使用： 1startActivity&lt;OrderActivity&gt;() 也可以带参数： 123startActivity&lt;WebActivity&gt;(\"URL\" to data.url)//在WebActivity中接收参数，下面的intent其实就是getIntent()，extras其实就是getExtras()intent.extras.getString(\"URL\") 7.分支语句Kotlin中用when代替了switch 用法也是类似的： 12345678910111213override fun onOptionsItemSelected(item: MenuItem?): Boolean &#123; when(item?.itemId)&#123; R.id.refresh -&gt; wv.reload() R.id.share -&gt; url?.let &#123; share(it) &#125; R.id.openinbrowse -&gt; url?.let &#123; browse(it) &#125; R.id.copyurl -&gt; &#123; val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager clipboard.text = url Snackbar.make(wv,\"已复制到剪切板\",Snackbar.LENGTH_SHORT).show() &#125; &#125; return super.onOptionsItemSelected(item) &#125; 而且还能直接作为返回值： 12345678override fun getItem(position: Int): Fragment? &#123; return when (position) &#123; 0 -&gt; DailyFragment.getInstance() 1 -&gt; SortFragment.getInstance() 2 -&gt; MindFragment.getInstance() else -&gt; AboutFragment.getInstance() &#125;&#125; 8. let的使用和空判断经常会有这样的需求： 123if (dailyBean.getResults().getAndroid() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getAndroid()); &#125; 判断一个东西不为空，然后执行一段代码。一行可能看不出来，下面这样呢？ 1234567891011121314151617181920212223242526272829@Override public void onNext(DailyBean dailyBean) &#123; 。。。 if (dailyBean.getResults().getAndroid() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getAndroid()); &#125; if (dailyBean.getResults().getApp() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getApp()); &#125; if (dailyBean.getResults().getBonus() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getBonus()); &#125; if (dailyBean.getResults().getIOS() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getIOS()); &#125; if (dailyBean.getResults().getJs() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getJs()); &#125; if (dailyBean.getResults().getRec() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getRec()); &#125; if (dailyBean.getResults().getRes() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getRes()); &#125; if (dailyBean.getResults().getVideo() != null) &#123; mVisitableList.addAll(dailyBean.getResults().getVideo()); &#125; 。。。 &#125; 如果用let,会少很多,作用是一样的： 123456789101112override fun onNext(dailyData: DailyData) &#123; ... dailyData.results.android?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.app?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.bonus?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.ios?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.js?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.rec?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.res?.let &#123; mVisitableList.addAll(it) &#125; dailyData.results.video?.let &#123; mVisitableList.addAll(it) &#125; ... &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.miaolegewu.top/tags/Kotlin/"}]},{"title":"Android多线程-AsyncTask工作流程(源码)","date":"2017-05-31T02:19:18.000Z","path":"2017/05/31/Android多线程-AsyncTask工作流程-源码/","text":"AsyncTask的源码是很简单的，看着并不复杂。只是对Handler和ThreadPoolExecutor进行了一下封装。 基于api25（7.1）的代码， 使用起来也是很简单的，看上个就知道了。一般要继承AsyncTask并重写下面几个方法,这些方法的执行顺序一目了然： 原文地址 http://blog.csdn.net/qq_25806863/article/details/72820844 12345678910//任务执行前调用protected void onPreExecute() &#123;&#125;//执行后台任务protected abstract Result doInBackground(Params... params);//返回任务执行结果protected void onPostExecute(Result result) &#123;&#125;//返回任务执行进度protected void onProgressUpdate(Progress... values) &#123;&#125;//任务取消时调用protected void onCancelled() &#123;&#125; 只有doInBackground一个方法是抽象的，必须重写，其他的可以不用重写。 然后通常的调用方法是这样的： 1new MyAsyncTask().execute(); Handler和线程池既然是对Handler和线程池的封装，就先看看封装的什么用的Handler和线程池。都是定义在AsyncTask类中。 handler1234567891011121314151617181920212223242526272829private static InternalHandler sHandler;private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125;private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125; 首先有一个变量sHandler。 InternalHandler是一个静态内部类 在这个构造方法中可以看出，InternalHandler使用了主线程也就是UI线程的Looper来处理消息，所以这个Handler收到的消息会在主线程中处理。使用这个Handler就达到了跟主线程进行交互的目的。 然后提供了一个方法getHandler，用单例来获取唯一的一个InternalHandler。 线程池123456789101112131415161718192021222324252627282930313233343536373839404142public static final Executor THREAD_POOL_EXECUTOR;static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; &#125;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();//默认的线程池private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125;/** @hide */ public static void setDefaultExecutor(Executor exec) &#123; sDefaultExecutor = exec; &#125; 在这里可以看见连个线程池，THREAD_POOL_EXECUTOR和SERIAL_EXECUTOR,以及一个默认使用的线程池变量sDefaultExecutor。 这两个线程池关系到了为什么AsyncTask的任务是串行的。在ActivityThread中有这样一段代码： 1234//android.os.Build.VERSION_CODES.HONEYCOMB_MR1=12if (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123; AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);&#125; 看来只有当版本小于13的时候，才会将THREAD_POOL_EXECUTOR作为默认线程池，可以并行执行任务。 THREAD_POOL_EXECUTOR其中THREAD_POOL_EXECUTOR是在静态代码块中定义的，在类加载的时候就执行了，而且只会执行一次。 直接使用ThreadPoolExecutor的构造方法来构造了一个线程池，来看一下参数： 1private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); 核心线程数，其中CPU_COUNT = Runtime.getRuntime().availableProcessors()表示CPU数量。最低两个，最多四个。 1private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; 最大线程数，是CPU核心数的2倍+1. 1private static final int KEEP_ALIVE_SECONDS = 30; 空闲线程存活时间，30 。根据第四个参数TimeUnit.SECONDS知道是30秒。 1private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =new LinkedBlockingQueue&lt;Runnable&gt;(128); 使用了LinkedBlockingQueue，超过核心线程数量的任务会在队列中排队。 1234567private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125;&#125;; 这个只是给每个线程池中创建的额线程起了个名字，叫 AsyncTask # 数字，数字自增长。 然后设置语序核心线程空闲超时threadPoolExecutor.allowCoreThreadTimeOut(true) 。 这是一个中规中矩的线程池，然而默认使用的线程池并不是这个。而是下面的SERIAL_EXECUTOR SERIAL_EXECUTORSERIAL_EXECUTOR中维护了一个双端数组队列mTasks，里面存放的Runnable。 当调用他的execute方法执行Runnable时，他会把这个Runnable的run方法和scheduleNext()方法重新加工包装成一个新的Runnable放在队列中。 然后下面会判断mActive是不是空的，第一次肯定是空的，所以会执行scheduleNext()方法。 在这个方法中，会调用队列的poll方法取出一个Runnable,然后调用上面的线程池THREAD_POOL_EXECUTOR来执行任务。 因为每个任务经过加工都加上了scheduleNext()方法，所以队列中的任务都会按顺序执行完。 由此可见，这个队列仅仅起到一个排序功能，是各个任务依次执行，真正的执行还是交给了线程池SERIAL_EXECUTOR. AsyncTask的其他内部类状态StatusAsyncTask有一个枚举类定义了三个状态： 1234567891011121314151617public enum Status &#123; /** * Indicates that the task has not been executed yet. * 表明任务尚未执行 */ PENDING, /** * Indicates that the task is running. * 表明任务正在执行 */ RUNNING, /** * Indicates that &#123;@link AsyncTask#onPostExecute&#125; has finished. * 表明onPostExecute已经结束 */ FINISHED,&#125; 当然就有一个表示状态的变量,mStatus默认是Status.PENDING: 1private volatile Status mStatus = Status.PENDING; WorkerRunnable123private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125; 这个类就是个CallAble接口，里面增加了一个参数数组。 AsyncTaskResult这个类其实就是个存储类，保存了一个AsyncTask和Data[]. 123456789private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 运行过程上面的都准备好了，下面就能运行了。 看着调用方法： 1new MyAsyncTask().execute(); 先实现一个AsyncTask,这时要定义三个参数类型， 1AsyncTask&lt;Params, Progress, Result&gt; 先new一个，然后调用execute方法 new的时候肯定会调用构造方法 构造方法AsyncTask的构造方法中初始化了两个变量： 123456789101112131415161718192021222324252627282930313233343536373839private final WorkerRunnable&lt;Params, Result&gt; mWorker;private final FutureTask&lt;Result&gt; mFuture;private final AtomicBoolean mTaskInvoked = new AtomicBoolean();public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; mWorker前面看到了，是一个WorkerRunnable，所以要重写call方法。 这个任务其实才是后台任务，所以这个任务就是真正的AsyncTask的任务了。 然后就调用了doInBackground(mParams)，把参数穿了进去。 mFuture是个FutureTask，他把上面的mWorker又进行了一次包装，会先执行mWorker的call方法中的内容，再执行done()。 execute123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 这个方法是真正开始执行任务的方法，一般都会传入个参数Params。 里面直接调用了executeOnExecutor(sDefaultExecutor, params)方法，使用的线程池是默认的 ，也就是上面的SERIAL_EXECUTOR。串行执行任务。 onPreExecute1234567891011121314151617181920212223public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 这里先判断任务的状态mStatus，如果是正在运行或者说运行结束了，都会抛异常。所以一个任务只能执行一次executef方法，一个任务只能执行一次，不能重复执行。 当mStatus是PENDING的时候，先mStatus = Status.RUNNING表示任务正在执行了。 然后就调用到了onPreExecute()方法。 mWorker.mParams = params前面看见WorkerRunnable中有一个变量Params[] mParams，保存了传入的参数。 一直到这时候都还是在原来的线程中运行，并没有开启多线程。所以这个方法也是在原来的线程中运行的。 然后调用传入的线程池的execute方法，来执行构造方法中新建的mFuture。这个时候就使用线程池开新线程了。 doInBackgroundmFuture里有个mWorker,会执行他的call方法，这个方法中的内容都会在子线程中运行，其中包括了doInBackground，他的参数mParams是WorkerRunnable里的变量。： 1234567891011121314151617mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; ... result = doInBackground(mParams); ... &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125;&#125;; 首先把mTaskInvoked设置为true表示这个任务已经开始了。 然后调用重写过的doInBackground方法，运行咱们需要后台运行的任务。 doInBackground有一个返回值，也是个泛型。 出现异常时，将mCancelled设置为true,表示任务取消了。 最终都会调用postResult(result)方法。 这个方法也很简单： 123456private Result postResult(Result result) &#123; Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; getHandler()前面知道是通过单例获取到一个使用主线程Looper创建的Handler,就是InnerHandler,所以他对消息的处理会回到主线程中。 然后通过这个Handler发送消息，消息内容是new AsyncTaskResult&lt;Result&gt;(this, result)。前面也看了这是个载体，将这个AsyncTask本身和后台任务doInBackground的返回结果传了进去。 然后整个工作就完成了。 onProgressUpdate这个方法用来更新进度，不能直接调用，要通过publishProgress方法来调用。 在doInBackground，通常会手动调用publishProgress方法来更新进度 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 这个方法贤惠判断任务是否取消，如果取消了就什么都不做。 没取消就也用InnerHandler发送消息，内容是new AsyncTaskResult&lt;Progress&gt;(this, values)。传入当前的AsyncTask和进度信息values. 这些方法最终都是以通过Handler发送个消息结束，所以后面的就是Handler的事了 之前已经看过了这个类： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 在handleMessage中能看到，result是个AsyncTaskResult类型，在前面也知道这个里面保存了AsyncTask和要传递的数据。前面两个消息携带的信息也是这个类型。 当msg.what==MESSAGE_POST_PROGRESS的时候，表示要更新进度，就先从result中拿到里面的AsyncTask-&gt;result.mTask，然后调用他的onProgressUpdate方法，参数是result中的mData-&gt;result.mData。 如果重写过这个方法，就可以根据这个值更新进度。 onPostExecute当msg.what==MESSAGE_POST_RESULT的时候，表示有结果了，这是后台任务已经执行结束了。 调用里面的AsyncTask的finish方法，参数是消息里的mData。 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 里面也是先判断是否取消，取消了就调用取消的回调onCancelled，没取消就调用正常的回调onPostExecute，并最后把任务状态改为Status.FINISHED。 整个任务结束。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)","date":"2017-05-23T02:53:51.000Z","path":"2017/05/23/Android多线程-AsyncTask的使用和问题(取消，并行，屏幕切换)/","text":"AsyncTask是Android提供的一个执行异步工作的类，内部其实是运用了线程池和Handler来进行异步任务的执行和与主线程的交互。AsyncTask只是一个辅助类，适合执行时间短的异步任务。 本文基于Android7.0的代码来说的。 原文地址 http://blog.csdn.net/qq_25806863/article/details/72782050 示例AsyncTask的使用方法是很简单的。就做一个简单的进度条。 布局是这样的： 里面有一个进度条ProgressBar pb1,开始按钮Button btn1，停止按钮Button stop1 然后实现一个AsyncTask，通过构造方法接收一个ProgressBar和Button进行操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; &#123; private String TAG = this.getClass().getSimpleName(); Button btn; ProgressBar pb; public MyAsyncTask(Button btn, ProgressBar pb) &#123; this.btn = btn; this.pb = pb; &#125; @Override protected String doInBackground(String... params) &#123; String result = \"完成\"; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Log.i(TAG, \"doInBackground: \"+i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; publishProgress(i); &#125; return result; &#125; @Override protected void onPreExecute() &#123; Log.i(TAG, \"onPreExecute: 准备工作\"); &#125; @Override protected void onPostExecute(String s) &#123; btn.setText(s); Log.i(TAG, \"onPostExecute: 回调\"); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; pb.setProgress(values[0]); &#125;&#125; 然后给两个按钮添加点击事件： 1MyAsyncTask task1 1task1 = new MyAsyncTask(btn1, pb1); 1234567btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, \"onClick: 开始1\"); task1.execute(); &#125;&#125;); 1234567stop1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, \"onClick: 停止1\"); task1.cancel(true); &#125;&#125;); 1.构造参数AsyncTask定义了三个泛型参数，在继承的时候必须填写。例如上面的AsyncTask&lt;String, Integer, String&gt; 在源码中定义是： 参数含义在下面的方法中会具体用到，先大致了解一下： Params 启动任务的时候输入的参数类型，一般都是String类型，如填个网址啥的。 上面示例中就是String类型。 Progress 用来更新进度的类型。表示任务执行的进度的类型。 示例用的进度条，所以选择Integer类型。 Result 后台任务执行完后返回的结果， 示例中返回的也是String类型。 2.重写方法要使用AsyncTask最少需要重写方法doInBackground。因为只有这个方法是抽象方法。 这个方法是在后台线程执行的。可以看到使用的参数类型Params就是在构造时定义的第一个类型。而返回的类型Result就是定义的第三个类型。 初次之外一般为了对任务流程进行控制还会重写下面几个方法onPreExecute,onPostExecute,onProgressUpdate。 下面几个方法在AsyncTask中是空的,而且都要求在主线程中执行。 123@MainThreadprotected void onPreExecute() &#123;&#125; 123@MainThreadprotected void onPostExecute(Result result) &#123;&#125; 123@MainThreadprotected void onProgressUpdate(Progress... values) &#123;&#125; onPreExecute() 在异步任务开始前做的操作， onPostExecute(Result result) 后台任务执行完后，通过这个方法能拿到任务返回的结果，进行处理。 onProgressUpdate(Progress… values) 这个表示进度变化，参数类型是构造时的第二个类型Progress。进度应该是随着任务的执行实时更新的，但是这个方法要在主线程中运行，而doInBackground是在子线程中运行，所以不能直接在doInBackground中调用onProgressUpdate方法，而是通过调用publishProgress(Progress... values)来间接调用这个方法。 3.开始任务AsyncTask的开始有下面三种方法： 123execute(Params... params)executeOnExecutor(Executor exec,Params... params) execute(Runnable runnable) execute(Params… params) 这个就是在示例中使用的开始任务的方式，传入指定的参数，参数类型要和构造时定义的第一个参数类型Params一样。参数可以为空的，那么在方法doInBackground(Params... params)中的参数也是空的。使用默认的线程池执行任务，会按流程执行onPreExecute,doInBackground(Params... params),onPostExecute(Result result)等方法。 executeOnExecutor(Executor exec,Params… params) 如果默认的线程池不能满足你的要求，可以用这个方法用指定线程池来执行任务。流程跟上面是一样的。 execute(Runnable runnable) 这个方法传进来的是一个Runnable类型，方法中只有一行代码sDefaultExecutor.execute(runnable)就是用默认的线程池直接执行任务，就是使用线程池了，跟前面那些重写的方法没关系。 ​ 4.停止任务要停止任务可以调用下面的方法： 1234public final boolean cancel(boolean mayInterruptIfRunning) &#123; mCancelled.set(true); return mFuture.cancel(mayInterruptIfRunning);&#125; 下面是停止的演示： 取消也有一个回调方法可以重写,这里加上，也是运行在主线程中： 12345@Overrideprotected void onCancelled() &#123; Log.i(TAG, \"onCancelled: 取消任务\"); btn.setText(\"取消了\");&#125; 取消的问题当cancel方法被调用后，onPostExecute和onProgressUpdate方法都不会再调用了。而doInBackground方法却会一直执行下去，也就是后台任务会继续执行。 cancel(boolean mayInterruptIfRunning)这个参数mayInterruptIfRunning文档中表示是否应该立即终止doInBackground中的任务。 然而实际用起来就不是那样的了，无论我们传的是true还是false，而AsyncTask的cancle方法只是打上了一个取消的标记。并不是直接终止任务。如果是true，则会调用一下后台线程的interrupt方法。 当调用了cancle方法后，调用isCancelled方法会返回true。在doInBackground中应该调用isCancelled来检查当前任务是否被取消，以便及时终止任务。 AsyncTask设计成这样就是为了方便更新主线程界面的，所以对用户来说，在调用了cancle方法后，后台的任务就不会在影响到主线程的界面变化了，因为后续的跟主线程交互的方法都不会再执行了。，也可以说是取消了。 而真的要及时取消doInBackground的继续运行则需要在这个方法中进行一些判断。 不做处理不做处理也就是在doInBackground中不做判断，像下面这样。看一下输出的日志。当然界面的进度条都会停住，只要看doInBackground有没有在点击停止按钮后停下来。 12345678910111213protected String doInBackground(String... params) &#123; String result = \"完成\"; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Log.i(TAG, \"doInBackground: \"+i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; publishProgress(i); &#125; return result; &#125; cancle(true): cancle(false): 可以看到区别是，当值为true的时候，后台线程也会跑完。但是会调用子线程的interrupt方法，而这个现在正在sleep，所以会引发InterruptedException. 而值为false的时候，没有任何变化，后台线程继续跑完。 做处理1. 判断isCancelled在不同的运行节点判断这个方法的值： 123456789101112131415161718@Overrideprotected String doInBackground(String... params) &#123; String result = \"完成\"; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; if (isCancelled())&#123; Log.i(TAG, \"doInBackground: 被标记停止了\"); break; &#125; Log.i(TAG, \"doInBackground: \"+i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; publishProgress(i); &#125; return result;&#125; 这时调用cancle(false)： 调用cancle(true)只是会多打印一个异常，一样会停止。 2.抓异常因为调用cancle(true)的时候有可能会抛出异常，如这个例子中的InterruptedException，因此可以通过异常捕捉来实现。 12345678910111213141516@Overrideprotected String doInBackground(String... params) &#123; String result = \"完成\"; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Log.i(TAG, \"doInBackground: \"+i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Log.i(TAG, \"doInBackground: 捕捉到异常,退出\"); break; &#125; publishProgress(i); &#125; return result;&#125; 这时调用cancle(true)： 并行和串行据说AsyncTask的任务是并行还是串行执行在不同Android版本有所变化，但是从API13开始，AsyncTask的任务执行都是串行的。 何为串行，比如有下面的界面： 有两个task 12345678910111213141516171819202122232425262728293031323334353637383940414243private ProgressBar pb1;private ProgressBar pb2;private Button btn1;private Button btn2;private Button stop1;private Button stop2;private MyAsyncTask task1, task2;@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); task1 = new MyAsyncTask(btn1, pb1); task2 = new MyAsyncTask(btn2, pb2);java btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, \"onClick: 开始1\"); task1.execute(); &#125; &#125;); btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, \"onClick: 开始2\"); task2.execute(); &#125; &#125;); stop1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, \"onClick: 停止1 \"); task1.cancel(true); &#125; &#125;); stop2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.i(TAG, \"onClick: 停止2\"); task2.cancel(false); &#125; &#125;); &#125; 在上面的MyAstncTask中，后台任务要执行10秒。 这里为了区分，打印开始按钮的名字来区分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; &#123; private String TAG = this.getClass().getSimpleName(); Button btn; ProgressBar pb; String name; public MyAsyncTask(Button btn, ProgressBar pb) &#123; this.btn = btn; this.pb = pb; name = btn.getText().toString(); &#125; @Override protected String doInBackground(String... params) &#123; String result = \"完成\"; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Log.i(TAG, \"doInBackground: \"+name+\" \"+i); Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Log.i(TAG, \"doInBackground: 捕捉到异常,退出\"); break; &#125; publishProgress(i); &#125; return result; &#125; @Override protected void onPreExecute() &#123; Log.i(TAG, \"onPreExecute: 准备工作 \"+name); &#125; @Override protected void onPostExecute(String s) &#123; btn.setText(s); Log.i(TAG, \"onPostExecute: 回调 \"+name); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; pb.setProgress(values[0]); &#125; @Override protected void onCancelled() &#123; Log.i(TAG, \"onCancelled: 取消任务 \"+name); btn.setText(\"取消了\"); &#125;&#125; 在点击第一个开始按钮之后点击第二个开始按钮，效果： 打印日志: 虽然点击了开始2，但是依然等第一个任务完成了才开始第二个任务。 想要让任务并行执行怎么办呢？其实他之所以会串行执行任务，是因为内部默认的线程池中将任务进行了排队，保证他们一个一个来。只要我们换个满足要求的线程池来执行任务就行了。AstncTask内部就有一个线程池AsyncTask.THREAD_POOL_EXECUTOR可以使用。当然，用Executors来创建也行。 然后将开始任务的execute(Params... params)方法改为executeOnExecutor(Executor exec,Params... params).这里用AsyncTask.THREAD_POOL_EXECUTOR. 12task1.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);task2.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR); 效果： 日志： 屏幕横竖屏切换使用AsyncTask的时候，在屏幕切换也会出现问题。 画面是这样的： 日志是这样的，动图中也能看见： 虽然屏幕切换后，任务也在执行，也在不停地调用更新进度条的方法，最后也执行了onPostExecute方法，但是界面上就是什么变化都没有。 因为在横竖屏切换的时候，Activity会销毁重建，所以AsyncTask所持有的引用就不是新建的Activity的控件了，新的Activity就不会变化了。 其中一种解决方法很简单,加上这句就行了。 这时屏幕怎么切换都没事","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"Android纯的二维码扫描界面和功能-zxing","date":"2017-05-15T04:10:26.000Z","path":"2017/05/15/Android纯的二维码扫描界面和功能-zxing/","text":"这是一个只有一个二维码扫描界面的demo，方便之后集成使用。 原文地址 http://blog.csdn.net/qq_25806863/article/details/72139582 CSDN下载地址 http://download.csdn.net/detail/qq_25806863/9842656 demo的GitHub地址 https://github.com/wangyisll/QRDemo 效果图界面是下面这样的： 项目结构项目结构很简单： 使用1.复制文件使用也很简单，把上面选中的文件复制到对应位置就行，values中的文件可以跟自己项目的合并。 2.修改各个类的import引用直接运行的话，肯定会报错，一大堆import文件找不到的。 因为复制过去的import用的是我的引用地址，只要把它删掉，Androidstudio会自动加上正确的引用。 只修改引用，其他的就先不要改了。 3.修改布局文件然后修改布局文件activity_qrscanner.xml 布局文件是这样的： 同样是因为不同项目的包名不一样，需要修改一下ViewfinderView的地址。不然运行会报错，找不到这个控件。 4.设置权限要在AndroidManifest.xml文件中设置一些权限： 12345&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt; &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt; &lt;uses-feature android:name=&quot;android.hardware.camera.front&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; 5.修改布局样式和处理结果这个就改QRScannerActivity就行了。 对扫描结果的处理在他的handleDecode方法中： 123456789101112131415/** * 处理扫描结果 */ public void handleDecode(Result result) &#123; inactivityTimer.onActivity(); playBeepSoundAndVibrate(); String resultString = result.getText(); if (TextUtils.isEmpty(resultString)) &#123; Toast.makeText(QRScannerActivity.this, \"Scan failed!\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(QRScannerActivity.this, resultString, Toast.LENGTH_SHORT).show(); finish(); &#125; &#125; 完工然后应该就能运行成功了。 demo的GitHub地址","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"Java多线程-CompletionService","date":"2017-05-11T09:05:38.000Z","path":"2017/05/11/Java多线程-CompletionService/","text":"起原文地址 http://blog.csdn.net/qq_25806863/article/details/71743659 在之前说过，线程池ThreadPoolExecutor可以调用submit方法来获取返回值Future。像下面这样： 这里先定义三个Callable，之后都用这三个： 123456789101112131415161718192021Callable callable1 = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5000); return \"我是call1的返回值\"; &#125; &#125;; Callable callable2 = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(3000); return \"我是call2的返回值\"; &#125; &#125;; Callable callable3 = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(1000); return \"我是call3的返回值\"; &#125; &#125;; 直接使用ThreadPoolExecutor的submit获取结果的使用方法是这样的： 123456789101112//声明一个线程池ExecutorService executor = Executors.newFixedThreadPool(5);//提交三个任务Future future1 = executor.submit(callable1);Future future2 = executor.submit(callable2);Future future2 = executor.submit(callable2);//开始获取返回值System.out.println(\"两个任务提交完毕，开始获取结果 \"+getStringDate());System.out.println(future1.get()+\" \"+getStringDate());System.out.println(future2.get()+\" \"+getStringDate());System.out.println(future3.get()+\" \"+getStringDate());System.out.println(\"获取结果完毕 \"+getStringDate()); 根据之前的理解，get()方法是有阻塞性的，因为future1的任务执行时间是5秒，所以在future1.get()这行代码上会阻塞5秒，然后才会获取到结果，继续往下执行。而在5秒内future2和future3的任务已经执行完了，所以会立马得到结果。 真实输出也是这样： 明明future2和future3的任务早就执行完了，却被future1.get()方法阻塞了。 使用CompletionService可以作为一种解决方法。 CompletionService简介CompletionService的主要功能就是一边生成任务，一边获取任务的返回值。让两件事分开执行，任务之间不会互相阻塞。 CompletionService在提交任务之后，会根据任务完成顺序来获取返回值，也就是谁先完成就返回谁的返回值。 CompletionService是一个接口： 1234567public interface CompletionService&lt;V&gt; &#123; Future&lt;V&gt; submit(Callable&lt;V&gt; var1); Future&lt;V&gt; submit(Runnable var1, V var2); Future&lt;V&gt; take() throws InterruptedException; Future&lt;V&gt; poll(); Future&lt;V&gt; poll(long var1, TimeUnit var3) throws InterruptedException;&#125; CompletionService只有一个实现类，就是ExecutorCompletionService 我这里有两个是因为用的AndroidStudio，一个是java的SDK的一个是Android的SDK的。 ExecutorCompletionService的使用CompletionService接口一共也就定义了那么几个方法，submit方法和ExecutorService的submit没什么不同。 下面主要分析一下take()方法和poll()方法 构造方法ExecutorCompletionService的构造方法有两个： 12public ExecutorCompletionService(Executor var1)ExecutorCompletionService(Executor var1, BlockingQueue&lt;Future&lt;V&gt;&gt; var2) 由此可见，CompletionService对任务的各种操作还是通过Executor来实现的，一般就是ThreadPoolExecutor。 下面是一个简单例子： 还是用一开始的三个Callable，这次用CompletionService来提交任务并获取结果。 1234567891011121314//新建一个线程池executorExecutorService executor = Executors.newFixedThreadPool(5);//用线程池executor新建一个CompletionServiceCompletionService completionService = new ExecutorCompletionService(executor);//用CompletionService提交任务completionService.submit(callable1);completionService.submit(callable2);completionService.submit(callable3);//用CompletionService获取结果System.out.println(\"两个任务提交完毕，开始获取结果 \"+getStringDate());System.out.println(completionService.take().get()+\" \"+getStringDate());System.out.println(completionService.take().get()+\" \"+getStringDate());System.out.println(completionService.take().get()+\" \"+getStringDate());System.out.println(\"获取结果完毕 \"+getStringDate()); 可以看下输出： 虽然提交的顺序是1，2，3，但是获取结果的时候是按任务完成顺序来获取的，所以结果是3，2，1. take()方法其实take()方法也是一个阻塞方法，调用这个方法时，他会一直等待直到线程池中返回一个结果，哪个任务先完成，就返回哪个任务的结果。 在上面的例子中，由于callable3是最先完成的，所以最先拿到的值就是callable3的返回值。 因为刚好提交了3个任务，调用了3次take()方法，因此刚好能拿到全部的任务的结果。 如果在调用一次take()方法，那么就会因为等不到有任务返回结果而阻塞在那里： 例如值提交一个任务，而调用两次take()方法，那么程序就会阻塞在第二个take()方法那里等待一个结果 123456789ExecutorService executor = Executors.newFixedThreadPool(5); CompletionService completionService = new ExecutorCompletionService(executor); completionService.submit(callable1); System.out.println(&quot;两个任务提交完毕，开始获取结果 &quot;+getStringDate()); System.out.println(completionService.take().get()+&quot; &quot;+getStringDate()); System.out.println(completionService.take().get()+&quot; &quot;+getStringDate()); System.out.println(&quot;获取结果完毕 &quot;+getStringDate()); 结果会一直是这样 poll()方法和poll(long var1, TimeUnit var3)方法Poll()方法也是获取返回值，使用方法也跟take()一样。 而poll()方法和take()方法的区别就是，poll()方法不会阻塞的去等结果，而是如果调用poll()方法的时候没有结果可以获取就直接返回一个null，然后程序继续往下运行。 这时如果调用poll().get()可能会引发空指针异常java.lang.NullPointerException 例子： 依旧是一开始那三个任务，在循环中连续调用8次poll()方法，每次间隔1秒钟： 1234567891011121314151617ExecutorService executor = Executors.newFixedThreadPool(5);CompletionService completionService = new ExecutorCompletionService(executor);completionService.submit(callable1);completionService.submit(callable2);completionService.submit(callable3);System.out.println(&quot;两个任务提交完毕，开始获取结果 &quot;+getStringDate());for (int i = 0; i &lt; 8; i++) &#123; Future future = completionService.poll(); if (future!=null)&#123; //如果future为空，会引发 NullPointerException System.out.println(future.get() + getStringDate()); &#125;else &#123; System.out.println(future+&quot; &quot;+getStringDate()); &#125; Thread.sleep(1000); &#125; System.out.println(&quot;获取结果完毕 &quot;+getStringDate()); 输出： 每次调用都是立马返回，毫不犹豫。所以没有结果的时候就返回空。 而poll(long var1, TimeUnit var3)方法就相当于给他强制设置了一个等待时间，你如果拿不到结果就等这么久，等这么久还拿不到再返回null。 把上面的循环改成这样： 12345678for (int i = 0; i &lt; 8; i++) &#123; Future future = completionService.poll(1, TimeUnit.SECONDS); if (future!=null)&#123; System.out.println(future.get() + getStringDate()); &#125;else &#123; System.out.println(future+&quot; &quot;+getStringDate()); &#125;&#125; 不在睡眠了，每次调用poll()方法个体1秒的等待时间。 这里第一次调用就等了1秒，然后在1秒内等到了call3的返回值，就返回call3的返回值。 第二次循环又等了一秒，一秒内没有获得结果，返回null。","tags":[{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"Java多线程-线程池ThreadPoolExecutor的submit返回值Future","date":"2017-05-05T02:09:45.000Z","path":"2017/05/05/Java多线程-线程池ThreadPoolExecutor的submit返回值Future/","text":"起原文地址 http://blog.csdn.net/qq_25806863/article/details/71214033 一般使用线程池执行任务都是调用的execute方法，这个方法定义在Executor接口中：123public interface Executor &#123; void execute(Runnable command);&#125; 这个方法是没有返回值的，而且只接受Runnable。 那么像得到线程的返回值怎嘛办呢？ 在ExecutorService接口中能找到这个方法： 123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); 这个方法接收两种参数，Callable和Runnable。返回值是Future。 下面具体看一下这些是什么东西。 Callable和Runnable先看一下两个接口的定义： Callable 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; Runnable 123interface Runnable &#123; public abstract void run();&#125; 和明显能看到区别： Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值 Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。 Future返回值Future也是一个接口，通过他可以获得任务执行的返回值。 定义如下： 1234567891011public interface Future&lt;V&gt; &#123; boolean cancel(boolean var1); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException;&#125; 其中的get方法获取的就是返回值。 来个例子 submit(Callable task)12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executor = Executors.newFixedThreadPool(2); //创建一个Callable，3秒后返回String类型 Callable myCallable = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(3000); System.out.println(&quot;calld方法执行了&quot;); return &quot;call方法返回值&quot;; &#125; &#125;; System.out.println(&quot;提交任务之前 &quot;+getStringDate()); Future future = executor.submit(myCallable); System.out.println(&quot;提交任务之后，获取结果之前 &quot;+getStringDate()); System.out.println(&quot;获取返回值: &quot;+future.get()); System.out.println(&quot;获取到结果之后 &quot;+getStringDate()); &#125; public static String getStringDate() &#123; Date currentTime = new Date(); SimpleDateFormat formatter = new SimpleDateFormat(&quot;HH:mm:ss&quot;); String dateString = formatter.format(currentTime); return dateString; &#125;&#125; 通过executor.submit提交一个Callable，返回一个Future，然后通过这个Future的get方法取得返回值。 看一下输出： 12345提交任务之前 12:13:01提交任务之后，获取结果之前 12:13:01calld方法执行了获取返回值: call方法返回值获取到结果之后 12:13:04 get()方法的阻塞性通过上面的输出可以看到，在调用submit提交任务之后，主线程本来是继续运行了。但是运行到future.get()的时候就阻塞住了，一直等到任务执行完毕，拿到了返回的返回值，主线程才会继续运行。 这里注意一下，他的阻塞性是因为调用get()方法时，任务还没有执行完，所以会一直等到任务完成，形成了阻塞。 任务是在调用submit方法时就开始执行了，如果在调用get()方法时，任务已经执行完毕，那么就不会造成阻塞。 下面在调用方法前先睡4秒，这时就能马上得到返回值。 1234567System.out.println(&quot;提交任务之前 &quot;+getStringDate());Future future = executor.submit(myCallable);System.out.println(&quot;提交任务之后 &quot;+getStringDate());Thread.sleep(4000);System.out.println(&quot;已经睡了4秒,开始获取结果 &quot;+getStringDate());System.out.println(&quot;获取返回值: &quot;+future.get());System.out.println(&quot;获取到结果之后 &quot;+getStringDate()); 123456提交任务之前 12:36:04提交任务之后 12:36:04calld方法执行了已经睡了4秒,开始获取结果 12:36:08获取返回值: call方法返回值获取到结果之后 12:36:08 可以看到吗，因为睡了4秒，任务已经执行完毕，所以get方法立马就得到了结果。 同样的原因，submit两个任务时，总阻塞时间是最长的那个。 例如，有两个任务，一个3秒，一个5秒。 12345678910111213141516171819202122232425Callable myCallable = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5000); System.out.println(\"calld方法执行了\"); return \"call方法返回值\"; &#125;&#125;;Callable myCallable2 = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(3000); System.out.println(\"calld2方法执行了\"); return \"call2方法返回值\"; &#125;&#125;;System.out.println(\"提交任务之前 \"+getStringDate()); Future future = executor.submit(myCallable); Future future2 = executor.submit(myCallable2); System.out.println(\"提交任务之后 \"+getStringDate()); System.out.println(\"开始获取第一个返回值 \"+getStringDate()); System.out.println(\"获取返回值: \"+future.get()); System.out.println(\"获取第一个返回值结束，开始获取第二个返回值 \"+getStringDate()); System.out.println(\"获取返回值2: \"+future2.get()); System.out.println(\"获取第二个返回值结束 \"+getStringDate()); 输出 123456789提交任务之前 14:14:47提交任务之后 14:14:48开始获取第一个返回值 14:14:48calld2方法执行了calld方法执行了获取返回值: call方法返回值获取第一个返回值结束，开始获取第二个返回值 14:14:53获取返回值2: call2方法返回值获取第二个返回值结束 14:14:53 获取第一个结果阻塞了5秒，所以获取第二个结果立马就得到了。 submit(Runnable task)因为Runnable是没有返回值的，所以如果submit一个Runnable的话，get得到的为null： 1234567891011121314Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; run time: &quot; + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;Future future = executor.submit(myRunnable); System.out.println(&quot;获取的返回值： &quot;+future.get()); 输出为： 12pool-1-thread-1 run time: 1493966762524获取的返回值： null submit(Runnable task, T result)虽然submit传入Runnable不能直接返回内容，但是可以通过submit(Runnable task, T result)传入一个载体，通过这个载体获取返回值。这个其实不能算返回值了，是交给线程处理一下。 先新建一个载体类Data： 1234567891011121314151617181920public static class Data &#123; String name; String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 然后在Runnable的构造方法中传入： 12345678910111213141516171819static class MyThread implements Runnable &#123; Data data; public MyThread(Data name) &#123; this.data = name; &#125; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(&quot;线程 执行:&quot;); data.setName(&quot;新名字&quot;); data.setSex(&quot;新性别&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后调用： 1234Data data = new Data();Future&lt;Data&gt; future = executor.submit(new MyThread(data), data);System.out.println(&quot;返回的结果 name: &quot; + future.get().getName()+&quot;, sex: &quot;+future.get().getSex());System.out.println(&quot;原来的Data name: &quot; + data.getName()+&quot;, sex: &quot;+data.getSex()); 输出： 123线程 执行:返回的结果 name: 新名字, sex: 新性别原来的Data name: 新名字, sex: 新性别 发现原来的data也变了。 get(long var1, TimeUnit var3)前面都是用的get()方法获取返回值，那么因为这个方法是阻塞的，有时需要等很久。所以有时候需要设置超时时间。 get(long var1, TimeUnit var3)这个方法就是设置等待时间的。 如下面的任务需要5秒才能返回结果： 1234567Callable myCallable = new Callable() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5000); return &quot;我是结果&quot;; &#125;&#125;; 使用get: 1234Future future1 = executor.submit(myCallable);System.out.println(&quot;开始拿结果 &quot;+getStringDate());System.out.println(&quot;返回的结果是： &quot;+future1.get()+ &quot; &quot;+getStringDate());System.out.println(&quot;结束拿结果 &quot;+getStringDate()); 输出是： 123开始拿结果 16:00:43返回的结果是： 我是结果 16:00:48结束拿结果 16:00:48 现在要求最多等3秒，拿不到返回值就不要了，所以用get(long var1, TimeUnit var3)这个方法 方法的第一个参数是长整形数字，第二个参数是单位，跟线程池ThreadPoolExecutor的构造方法里一样的。 123456789Future future1 = executor.submit(myCallable);System.out.println(&quot;开始拿结果 &quot;+getStringDate());try &#123; System.out.println(&quot;返回的结果是： &quot;+future1.get(3, TimeUnit.SECONDS)+ &quot; &quot;+getStringDate());&#125; catch (TimeoutException e) &#123; e.printStackTrace(); System.out.println(&quot;超时了 &quot;+getStringDate());&#125;System.out.println(&quot;结束拿结果 &quot;+getStringDate()); 然后输出是 过了三秒就抛出超时异常了，主线程继续运行，不会再继续阻塞。 异常使用submit方法还有一个特点就是，他的异常可以在主线程中catch到。 而使用execute方法执行任务是捕捉不到异常的。 用下面这个Runnable来说,这个 里面一定会抛出一个异常 123456Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; executor.execute(null); &#125;&#125;; 使用execute这里如果捕捉到异常，只打印一行异常信息。 123456try &#123; executor.execute(myRunnable); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;抓到异常 &quot;+e.getMessage()); &#125; 输出 并没有出现抓到异常哪行日志。而且这个异常输出是在线程pool-1-thread-1中，并不是在主线程中。说明主线程的catch不能捕捉到这个异常。 使用submit1234567try &#123; Future future1= executor.submit(myCallable); future1.get(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;抓到异常 &quot;+e.getMessage()); &#125; 输出 这个就能抓到异常了。","tags":[{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"java多线程-ThreadPoolExecutor的拒绝策略","date":"2017-05-04T08:11:03.000Z","path":"2017/05/04/java多线程-ThreadPoolExecutor的拒绝策略/","text":"概述原文地址 http://blog.csdn.net/qq_25806863/article/details/71172823 在分析ThreadPoolExecutor的构造参数时，有一个RejectedExecutionHandler参数。 RejectedExecutionHandler是一个接口： 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 里面只有一个方法。当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。 可以自己实现这个接口，实现对这些超出数量的任务的处理。 ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是CallerRunsPolicy,AbortPolicy,DiscardPolicy,DiscardOldestPolicy 这四个拒绝策略其实一看实现方法就知道很简单。 AbortPolicyThreadPoolExecutor中默认的拒绝策略就是AbortPolicy。直接抛出异常。 12private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 下面是他的实现： 12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125; 很简单粗暴，直接抛出个RejectedExecutionException异常，也不执行这个任务了。 测试先自定义一个Runnable,给每个线程起个名字，下面都用这个Runnable 123456789101112131415static class MyThread implements Runnable &#123; String name; public MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程:\"+Thread.currentThread().getName() +\" 执行:\"+name +\" run\"); &#125; &#125; 然后构造一个核心线程是1，最大线程数是2的线程池。拒绝策略是AbortPolicy 1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 0, TimeUnit.MICROSECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.AbortPolicy()); 123456789for (int i = 0; i &lt; 6; i++) &#123; System.out.println(\"添加第\"+i+\"个任务\"); executor.execute(new MyThread(\"线程\"+i)); Iterator iterator = executor.getQueue().iterator(); while (iterator.hasNext())&#123; MyThread thread = (MyThread) iterator.next(); System.out.println(\"列表：\"+thread.name); &#125;&#125; 输出是： 分析一下过程。 添加第一个任务时，直接执行，任务列表为空。 添加第二个任务时，因为采用的LinkedBlockingDeque，，并且核心线程正在执行任务，所以会将第二个任务放在队列中，队列中有 线程2. 添加第三个任务时，也一样会放在队列中，队列中有 线程2，线程3. 添加第四个任务时，因为核心任务还在运行，而且任务队列已经满了，所以胡直接创建新线程执行第四个任务，。这时线程池中一共就有两个线程在运行了，达到了最大线程数。任务队列中还是有线程2， 线程3. 添加第五个任务时，再也没有地方能存放和执行这个任务了，就会被线程池拒绝添加，执行拒绝策略的rejectedExecution方法，这里就是执行AbortPolicy的rejectedExecution方法直接抛出异常。 最终，只有四个线程能完成运行。后面的都被拒绝了。 CallerRunsPolicyCallerRunsPolicy在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。 下面说他的实现： 12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; 也很简单，直接run。 测试1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.AbortPolicy()); 按上面的运行，输出 注意在添加第五个任务，任务5 的时候，同样被线程池拒绝了，因此执行了CallerRunsPolicy的rejectedExecution方法，这个方法直接执行任务的run方法。因此可以看到任务5是在main线程中执行的。 从中也可以看出，因为第五个任务在主线程中运行，所以主线程就被阻塞了，以至于当第五个任务执行完，添加第六个任务时，前面两个任务已经执行完了，有了空闲线程，因此线程6又可以添加到线程池中执行了。 这个策略的缺点就是可能会阻塞主线程。 DiscardPolicy这个策略的处理就更简单了，看一下实现就明白了： 12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; 这个东西什么都没干。 因此采用这个拒绝策略，会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。 测试1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.DiscardPolicy()); 输出： 可以看到 后面添加的任务5和6根本不会执行，什么反应都没有，直接丢弃。 DiscardOldestPolicyDiscardOldestPolicy策略的作用是，当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。 123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 在rejectedExecution先从任务队列总弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。 测试1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.DiscardOldestPolicy()); 输出是： 可以看到， 在添加第五个任务时，会被线程池拒绝。这时任务队列中有 任务2，任务3 这时，拒绝策略会让任务队列中最先加入的任务弹出，也就是任务2. 然后把被拒绝的任务5添加人任务队列，这时任务队列中就成了 任务3，任务5. 添加第六个任务时会因为同样的过程，将队列中的任务3抛弃，把任务6加进去，任务队列中就成了 任务5，任务6 因此，最终能被执行的任务只有1，4，5，6. 任务2和任务3倍抛弃了，不会执行。 自定义拒绝策略通过看前面的系统提供的四种拒绝策略可以看出，拒绝策略的实现都非常简单。自己写亦一样 比如现在想让被拒绝的任务在一个新的线程中执行，可以这样写： 123456static class MyRejectedExecutionHandler implements RejectedExecutionHandler &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; new Thread(r,&quot;新线程&quot;+new Random().nextInt(10)).start(); &#125;&#125; 然后正常使用： 1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new MyRejectedExecutionHandler()); 输出： 发现被拒绝的任务5和任务6都在新线程中执行了。","tags":[{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"AndroidStudio运行java的main方法","date":"2017-05-04T07:26:31.000Z","path":"2017/05/04/AndroidStudio运行java的main方法/","text":"要做AndroidStudio上运行java的main方法很简单。 原文地址 http://blog.csdn.net/qq_25806863/article/details/71171321 直接新建一个java文件 ​ 在java文件中写main方法，输入psvm就行 12345public class Demo &#123; public static void main(String[] args) &#123; System.out.println(\"ok\"); &#125;&#125; 类文件上邮件，点击 就能看到打印出的OK ​","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://blog.miaolegewu.top/tags/工具/"}]},{"title":"Java多线程-线程池Executors","date":"2017-05-03T09:46:29.000Z","path":"2017/05/03/Java多线程-线程池Executors/","text":"概览博客地址 http://blog.csdn.net/qq_25806863 原文地址 http://blog.csdn.net/qq_25806863/article/details/71159452 通过上一篇对ThreadPoolExecutor的构造方法分析可以感受到，通过ThreadPoolExecutor来创建线程池是比较复杂的，参数比较多，考虑因素也多。因此java自己提供了一个工厂类Executors，里面提供了一些方法，用来创建常用的几种ThreadPoolExecutor线程池。 下面是方法概览： 1234567891011121314151617181920212223public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; 分析FixedThreadPoolFixedThreadPool调用的是ThreadPoolExecutor的构造方法。有下面两种使用方式： 12345678910111213//不带工厂的public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;//带工厂的public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; 通过对ThreadPoolExecutor构造参数的分析可以看出来，这个线程池的最大线程数就是核心线程数，也就是没有非核心线程的存在。这些线程都是核心线程，即使在闲置状态也不会被回收，除非线程池关闭了，所以超时机制并没有用。他的任务队列是无界的LinkedBlockingQueue，因此超过核心线程数量的任务会放在队列中排队。 这样的线程池优点很明显，只会创建固定数量的线程，然后这些线程一直存活重用，不会有额外的创建和销毁线程的开销，能更快的执行任务。 测试12345678910111213141516ExecutorService executor = Executors.newFixedThreadPool(2);Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; run time: &quot;+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;for (int i = 0; i &lt; 6; i++) &#123; executor.execute(myRunnable);&#125; 创建一个固定大小为2的FixedThreadPool，然后添加6个任务，输出是： 123456pool-1-thread-2 run time: 1493863106021pool-1-thread-1 run time: 1493863106021pool-1-thread-2 run time: 1493863108022pool-1-thread-1 run time: 1493863108022pool-1-thread-1 run time: 1493863110026pool-1-thread-2 run time: 1493863110027 可以看到这个线程池只会创建2个线程，其他的都在排队。 线程工厂12345678910111213141516171819202122232425262728public static void main(String[] args) throws InterruptedException &#123; ExecutorService executor = Executors.newFixedThreadPool(2,new MyFactory()); Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; run time: &quot;+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; for (int i = 0; i &lt; 6; i++) &#123; executor.execute(myRunnable); &#125; &#125;static class MyFactory implements ThreadFactory&#123; @Override public Thread newThread(@NonNull Runnable r) &#123; Thread thread = new Thread(r); thread.setName(&quot;哈哈&quot;+ UUID.randomUUID().toString().substring(0,3)); return thread; &#125; &#125; 创建一个工厂，自定义设置线程名字，然后在newFixedThreadPool时传入工厂，看输出 123456哈哈fea run time: 1493863498244哈哈491 run time: 1493863498244哈哈fea run time: 1493863500250哈哈491 run time: 1493863500250哈哈fea run time: 1493863502253哈哈491 run time: 1493863502253 下面的工厂参数都是这样，就不在写了。 CachedThreadPoolCachedThreadPool也是用的ThreadPoolExecutor的构造方法 12345678910public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1, threadFactory));&#125; 分析这个参数可以看出，这个线程池没有核心线程，所有的线程都会在限制60秒后被回收。而且最大线程数为Integer.MAX_VALUE，相当于无限大。因为任务队列是SynchronousQueue，不会保存任何任务，所以当有新任务时，如果当前线程都在活动着，就会新建一个线程来执行任务。 这样的线程池的特点就是，适合执行大量的耗时短的任务。而且当所有任务执行完后，闲置超过60秒就会全部回收，这是线程池里就没有任何线程，不会占用系统资源。 测试12345678910111213141516171819202122232425ExecutorService executor = Executors.newCachedThreadPool(); Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; run time: &quot;+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;for (int i = 0; i &lt; 3; i++) &#123; executor.execute(myRunnable);&#125;Thread.sleep(30000);System.out.println(&quot;睡眠30秒后&quot;);for (int i = 0; i &lt; 3; i++) &#123; executor.execute(myRunnable);&#125;Thread.sleep(65000);System.out.println(&quot;再睡眠65秒后&quot;);for (int i = 0; i &lt; 3; i++) &#123; executor.execute(myRunnable);&#125; 先运行三个任务，30秒后再添加3个任务，再过65秒再添加3个任务。 1234567891011pool-1-thread-1 run time: 1493864065635pool-1-thread-2 run time: 1493864065635pool-1-thread-3 run time: 1493864065639睡眠30秒后pool-1-thread-3 run time: 1493864095637pool-1-thread-2 run time: 1493864095637pool-1-thread-1 run time: 1493864095637再睡眠65秒后pool-1-thread-5 run time: 1493864160643pool-1-thread-4 run time: 1493864160643pool-1-thread-6 run time: 1493864160643 可以看到一开始创建了3个线程，30秒后重用了这三个线程。但是再过65秒后，者三个线程就因为超时被回收了，所以新建了三个线程。 SingleThreadExecutorSingleThreadExecutor使用new FinalizableDelegatedExecutorService来创建线程池。但是其实通过一个委托调用了ThreadPoolExecutor的构造方法 1234567891011121314public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125; 从ThreadPoolExecutor的构造参数依然可以看出，这个线程池仅有一个核心线程，其他的任务都在任务队列中排队。 这样的线程池会让所有的任务都在同一个线程中执行，避免的同步问题。 测试123456789101112131415161718192021ExecutorService executor = Executors.newSingleThreadExecutor(); Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; run time: &quot;+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;for (int i = 0; i &lt; 3; i++) &#123; executor.execute(myRunnable);&#125;Thread.sleep(65000);System.out.println(&quot;睡眠65秒后&quot;);for (int i = 0; i &lt; 3; i++) &#123; executor.execute(myRunnable);&#125; 1234567pool-1-thread-1 run time: 1493864476076pool-1-thread-1 run time: 1493864478078pool-1-thread-1 run time: 1493864480082睡眠65秒后pool-1-thread-1 run time: 1493864541080pool-1-thread-1 run time: 1493864543083pool-1-thread-1 run time: 1493864545087 自始至终都只有一个线程。而且不会被回收。 ScheduledThreadPoolScheduledThreadPool使用new ScheduledThreadPoolExecutor来创建 12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 看一下具体使用的构造参数： 123456public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue(), threadFactory);&#125; 可以看到，这个线程池的核心线程数是固定的，但是总线程数是无限的，然而因为DelayedWorkQueue是个无界队列，所以这个值没有意义，超过核心线程的任务都会放在队列中。 ScheduledThreadPoolExecutor主要是用来执行定时任务和有周期性的重复任务。 这里就举个不恰当的例子，不是ScheduledThreadPoolExecutor的用法 123456789101112131415ExecutorService executor = Executors.newScheduledThreadPool(3); Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; run time: &quot;+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;for (int i = 0; i &lt; 6; i++) &#123; executor.execute(myRunnable);&#125; 123456pool-1-thread-3 run time: 1493866372444pool-1-thread-1 run time: 1493866372444pool-1-thread-2 run time: 1493866372444pool-1-thread-2 run time: 1493866374450pool-1-thread-1 run time: 1493866374450pool-1-thread-3 run time: 1493866374450 设置的是3，就只会创建3个线程。","tags":[{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"Java多线程-线程池ThreadPoolExecutor构造方法和规则","date":"2017-05-02T07:44:16.000Z","path":"2017/05/02/Java多线程-线程池ThreadPoolExecutor构造方法和规则/","text":"[TOC] 为什么用线程池博客地址 http://blog.csdn.net/qq_25806863 原文地址 http://blog.csdn.net/qq_25806863/article/details/71126867 有时候，系统需要处理非常多的执行时间很短的请求，如果每一个请求都开启一个新线程的话，系统就要不断的进行线程的创建和销毁，有时花在创建和销毁线程上的时间会比线程真正执行的时间还长。而且当线程数量太多时，系统不一定能受得了。使用线程池主要为了解决一下几个问题： 通过重用线程池中的线程，来减少每个线程创建和销毁的性能开销。 对线程进行一些维护和管理，比如定时开始，周期执行，并发数控制等等。 ExecutorExecutor是一个接口，跟线程池有关的基本都要跟他打交道。下面是常用的ThreadPoolExecutor的关系。 Executor接口很简单，只有一个execute方法。 ExecutorService是Executor的子接口，增加了一些常用的对线程的控制方法，之后使用线程池主要也是使用这些方法。 AbstractExecutorService是一个抽象类。ThreadPoolExecutor就是实现了这个类。 ThreadPoolExecutor构造方法ThreadPoolExecutor是线程池的真正实现，他通过构造方法的一系列参数，来构成不同配置的线程池。常用的构造方法有下面四个： 12345ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 构造方法参数说明 corePoolSize 核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true。 maximumPoolSize 线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。 keepAliveTime 非核心线程的闲置超时时间，超过这个时间就会被回收。 unit 指定keepAliveTime的单位，如TimeUnit.SECONDS。当将allowCoreThreadTimeOut设置为true时对corePoolSize生效。 workQueue 线程池中的任务队列 常用的有三种队列，SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。 threadFactory 线程工厂，提供创建新线程的功能。ThreadFactory是一个接口，只有一个方法 123public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; 通过线程工厂可以对线程的一些属性进行定制。 默认的工厂： 12345678910111213141516171819202122232425static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager var1 = System.getSecurityManager(); this.group = var1 != null?var1.getThreadGroup():Thread.currentThread().getThreadGroup(); this.namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; public Thread newThread(Runnable var1) &#123; Thread var2 = new Thread(this.group, var1, this.namePrefix + this.threadNumber.getAndIncrement(), 0L); if(var2.isDaemon()) &#123; var2.setDaemon(false); &#125; if(var2.getPriority() != 5) &#123; var2.setPriority(5); &#125; return var2; &#125;&#125; RejectedExecutionHandler RejectedExecutionHandler也是一个接口，只有一个方法 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable var1, ThreadPoolExecutor var2);&#125; 当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution方法。 线程池规则线程池的线程执行规则跟任务队列有很大的关系。 下面都假设任务队列没有大小限制： 如果线程数量&lt;=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中。 如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是LinkedBlockingDeque的时候，超过核心线程数量的任务会放在任务队列中排队。 如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是SynchronousQueue的时候，线程池会创建新线程执行任务，这些任务也不会被放在任务队列中。这些线程属于非核心线程，在任务完成后，闲置时间达到了超时时间就会被清除。 如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是LinkedBlockingDeque，会将超过核心线程的任务放在任务队列中排队。也就是当任务队列是LinkedBlockingDeque并且没有大小限制时，线程池的最大线程数设置是无效的，他的线程数最多不会超过核心线程数。 如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是SynchronousQueue的时候，会因为线程池拒绝添加任务而抛出异常。 任务队列大小有限时 当LinkedBlockingDeque塞满时，新增的任务会直接创建新线程来执行，当创建的线程数量超过最大线程数量时会抛异常。 SynchronousQueue没有数量限制。因为他根本不保持这些任务，而是直接交给线程池去执行。当任务数量超过最大线程数时会直接抛异常。 规则验证前提所有的任务都是下面这样的，睡眠两秒后打印一行日志： 123456789101112Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \" run\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;; 所有验证过程都是下面这样，先执行三个，再执行三个，8秒后，各看一次信息 12345678910111213141516171819executor.execute(myRunnable);executor.execute(myRunnable);executor.execute(myRunnable);System.out.println(&quot;---先开三个---&quot;);System.out.println(&quot;核心线程数&quot; + executor.getCorePoolSize());System.out.println(&quot;线程池数&quot; + executor.getPoolSize());System.out.println(&quot;队列任务数&quot; + executor.getQueue().size());executor.execute(myRunnable);executor.execute(myRunnable);executor.execute(myRunnable);System.out.println(&quot;---再开三个---&quot;);System.out.println(&quot;核心线程数&quot; + executor.getCorePoolSize());System.out.println(&quot;线程池数&quot; + executor.getPoolSize());System.out.println(&quot;队列任务数&quot; + executor.getQueue().size());Thread.sleep(8000);System.out.println(&quot;----8秒之后----&quot;);System.out.println(&quot;核心线程数&quot; + executor.getCorePoolSize());System.out.println(&quot;线程池数&quot; + executor.getPoolSize());System.out.println(&quot;队列任务数&quot; + executor.getQueue().size()); 验证1 核心线程数为6，最大线程数为10。超时时间为5秒 1ThreadPoolExecutor executor = new ThreadPoolExecutor(6, 10, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数6线程池线程数3队列任务数0---再开三个---核心线程数6线程池线程数6队列任务数0pool-1-thread-1 runpool-1-thread-6 runpool-1-thread-5 runpool-1-thread-3 runpool-1-thread-4 runpool-1-thread-2 run----8秒之后----核心线程数6线程池线程数6队列任务数0 可以看到每个任务都是是直接启动一个核心线程来执行任务，一共创建了6个线程，不会放入队列中。8秒后线程池还是6个线程，核心线程默认情况下不会被回收，不收超时时间限制。 验证2 核心线程数为3，最大线程数为6。超时时间为5秒,队列是LinkedBlockingDeque 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 6, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数3队列任务数3pool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 runpool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 run----8秒之后----核心线程数3线程池线程数3队列任务数0 当任务数超过核心线程数时，会将超出的任务放在队列中，只会创建3个线程重复利用。 验证3 核心线程数为3，最大线程数为6。超时时间为5秒,队列是SynchronousQueue 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 6, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数6队列任务数0pool-1-thread-2 runpool-1-thread-3 runpool-1-thread-6 runpool-1-thread-4 runpool-1-thread-5 runpool-1-thread-1 run----8秒之后----核心线程数3线程池线程数3队列任务数0 当队列是SynchronousQueue时，超出核心线程的任务会创建新的线程来执行，看到一共有6个线程。但是这些线程是费核心线程，收超时时间限制，在任务完成后限制超过5秒就会被回收。所以最后看到线程池还是只有三个线程。 验证4 核心线程数是3，最大线程数是4，队列是LinkedBlockingDeque 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数3队列任务数3pool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 runpool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 run----8秒之后----核心线程数3线程池线程数3队列任务数0 LinkedBlockingDeque根本不受最大线程数影响。 但是当LinkedBlockingDeque有大小限制时就会受最大线程数影响了 4.1 比如下面，将队列大小设置为2. 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2)); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数4队列任务数2pool-1-thread-2 runpool-1-thread-1 runpool-1-thread-4 runpool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 run----8秒之后----核心线程数3线程池线程数3队列任务数0 首先为三个任务开启了三个核心线程1，2，3，然后第四个任务和第五个任务加入到队列中，第六个任务因为队列满了，就直接创建一个新线程4，这是一共有四个线程，没有超过最大线程数。8秒后，非核心线程收超时时间影响回收了，因此线程池只剩3个线程了。 4.2 将队列大小设置为1 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(1)); 12345678910111213141516171819Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.sunlinlin.threaddemo.Main$1@677327b6 rejected from java.util.concurrent.ThreadPoolExecutor@14ae5a5[Running, pool size = 4, active threads = 4, queued tasks = 1, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at com.sunlinlin.threaddemo.Main.main(Main.java:35) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)---先开三个---核心线程数3线程池线程数3队列任务数0pool-1-thread-1 runpool-1-thread-2 runpool-1-thread-3 runpool-1-thread-4 runpool-1-thread-1 run 直接出错在第6个execute方法上。因为核心线程是3个，当加入第四个任务的时候，就把第四个放在队列中。加入第五个任务时，因为队列满了，就创建新线程执行，创建了线程4。当加入第六个线程时，也会尝试创建线程，但是因为已经达到了线程池最大线程数，所以直接抛异常了。 验证5 核心线程数是3 ，最大线程数是4，队列是SynchronousQueue 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 123456789101112131415161718Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.sunlinlin.threaddemo.Main$1@14ae5a5 rejected from java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 4, active threads = 4, queued tasks = 0, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at com.sunlinlin.threaddemo.Main.main(Main.java:34) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)---先开三个---核心线程数3线程池线程数3队列任务数0pool-1-thread-2 runpool-1-thread-3 runpool-1-thread-4 runpool-1-thread-1 run 这次在添加第五个任务时就报错了，因为SynchronousQueue各奔不保存任务，收到一个任务就去创建新线程。所以第五个就会抛异常了。","tags":[{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.miaolegewu.top/tags/多线程/"}]},{"title":"View动画执行过程和插值器作用","date":"2017-04-27T08:02:22.000Z","path":"2017/04/27/View动画执行过程和插值器作用/","text":"示例补间动画的使用很简单，如下面代码,让图片旋转360度： 123animation = new RotateAnimation(0,360);animation.setDuration(3000);iv.startAnimation(animation); 那么补间动画说怎么执行的，插值器又是怎么用上的能？ 动画的启动 View从动画启动开始吧，看View的startAnimation方法： /frameworks/base/core/java/android/view/View.java: 123456789101112public void startAnimation(Animation animation) &#123; animation.setStartTime(Animation.START_ON_FIRST_FRAME); setAnimation(animation); invalidateParentCaches(); invalidate(true);&#125;public void setAnimation(Animation animation) &#123; mCurrentAnimation = animation; if (animation != null) &#123; ...... &#125;&#125; 这里面没几行代码，首先把动画设置给内部的一个变量，然后调用invalidate(true)方法。 这个方法会引起View的draw()方法的执行，并且是整个View的重绘。 /frameworks/base/core/java/android/view/View.java: 12345678910111213141516171819202122public Animation getAnimation() &#123; return mCurrentAnimation; &#125;boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; Transformation transformToApply = null; boolean concatMatrix = false; //拿到动画 final Animation a = getAnimation(); //动画不为空，说明有动画要执行 if (a != null) &#123; more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); concatMatrix = a.willChangeTransformationMatrix(); if (concatMatrix) &#123; mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; &#125; //获取Transformation,里面包换透明度和矩阵，这个Transformation的值在上面已经设置好了 transformToApply = parent.getChildTransformation(); &#125; else &#123; &#125; //根据Transformation进行绘制。 return more; &#125; 调用本类的applyLegacyAnimation方法。 /frameworks/base/core/java/android/view/View.java: 123456789101112131415161718192021222324252627282930private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired) &#123; Transformation invalidationTransform; final int flags = parent.mGroupFlags; final boolean initialized = a.isInitialized(); if (!initialized) &#123; //初始化动画 a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight()); a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop); if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler); onAnimationStart(); &#125; //注意这里也是通过这个方法拿到一个Transformation。 final Transformation t = parent.getChildTransformation(); //获取动画的变化值，并返回是否还有下一帧。 boolean more = a.getTransformation(drawingTime, t, 1f); if (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != 1f) &#123; if (parent.mInvalidationTransformation == null) &#123; parent.mInvalidationTransformation = new Transformation(); &#125; invalidationTransform = parent.mInvalidationTransformation; a.getTransformation(drawingTime, invalidationTransform, 1f); &#125; else &#123; invalidationTransform = t; &#125; if (more) &#123; //如果有下一帧，就继续刷新绘制 &#125; return more; &#125; 动画的动画值计算设置/frameworks/base/core/java/android/view/animation/Animation.java: 1234567891011121314151617181920212223public boolean getTransformation(long currentTime, Transformation outTransformation) &#123; if (mStartTime == -1) &#123; mStartTime = currentTime; &#125; //转化为标准时间 final long startOffset = getStartOffset(); final long duration = mDuration; float normalizedTime; if (duration != 0) &#123; normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration; &#125; if ((normalizedTime &gt;= 0.0f || mFillBefore) &amp;&amp; (normalizedTime &lt;= 1.0f || mFillAfter)) &#123; ...... //通过标准时间，用插值器计算插值器转换之后的值 final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime); //调用子类实现的方法， applyTransformation(interpolatedTime, outTransformation); &#125; return mMore; &#125;protected void applyTransformation(float interpolatedTime, Transformation t) &#123;&#125; 首先计算标准时间。标准时间是0到1的值，表示时间的进度。通过这个进度计算动画的进度。计算方法是，先用开始时间和延迟开始时间计算动画真正的开始时间，然后用当前时间减去动画真正开始的时间，算出动画已经运行的时间。用这个时间除以动画的总运行时间久得到当前动画的进度。 插值器插值器改变的就是改变不同时间进度上的值，时间的流逝是线性的，速度是不变的，但是插值器通过改变不同时间上动画的值，达到控制动画的目的。 默认是加速加速插值器，里面是一个余弦曲线，随着标准时间从0到1，返回的数值是先加速再减速的,动画就会先变快在变慢，第一个效果图中看的很明显。 /frameworks/base/core/java/android/view/animation/AccelerateDecelerateInterpolator.java: 123public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125; 下面可以看一下线性插值器，他就原原本本的返回了标准时间，不做任何改变，所以动画就会匀速执行： /frameworks/base/core/java/android/view/animation/LinearInterpolator.java 123public float getInterpolation(float input) &#123; return input;&#125; Animation的子类实现applyTransformation方法Animation的applyTransformation方法是一个空方法，需要子类去实现。下面看一啊AlphaAnimation的实现，现获取透明度总共要变化的值，然后通过传进来的插值器计算出的进度值，算出这个时间点上透明度应该是多少，然后设置给Transformation： /Users/sunlinlin/Documents/AndroidSourcePart/frameworks/base/core/java/android/view/animation/AlphaAnimation.java 12345@Overrideprotected void applyTransformation(float interpolatedTime, Transformation t) &#123; final float alpha = mFromAlpha; t.setAlpha(alpha + ((mToAlpha - alpha) * interpolatedTime));&#125; AlphaAnimation里给传进来的Transformation设置了alpha值。Transformation主要有两个量，一个透明度，一个是矩阵。绘制时根据这个类里面存储的量来绘制，达到动画的效果。 例如旋转动画RotateAnimation,改变的就是矩阵，先算出动画一共要旋转的角度，然后根据插值器计算的进度值算出当前时间点上应该旋转到什么角度，然后设置给Transformation。 /frameworks/base/core/java/android/view/animation/RotateAnimation.java 12345678910@Overrideprotected void applyTransformation(float interpolatedTime, Transformation t) &#123; float degrees = mFromDegrees + ((mToDegrees - mFromDegrees) * interpolatedTime); float scale = getScaleFactor(); if (mPivotX == 0.0f &amp;&amp; mPivotY == 0.0f) &#123; t.getMatrix().setRotate(degrees); &#125; else &#123; t.getMatrix().setRotate(degrees, mPivotX * scale, mPivotY * scale); &#125;&#125; 这时，回到上面View的draw()方法里，就会根据后面对Transformation的设置进行画面的绘制，一帧一帧的绘制就成了动画。 这也能解释为什么补间动画不会改变控件的真正位置了，因为这个动画只是重新对空间进行了draw，改变的只是看起来的样子，所以点击事件还得点击原来的地方。 简单的自定义插值器插值器前面说的作用就是，在决定不同时间进度上的动画进度。时间进度是从0到1，而动画进度不一定非要从0到1. 比如，就已开始设置那个动画，3秒时间从0度旋转到360度，那么正常的他的动画进度就是：时间从0到3秒，角度从0到360. 动画的进度是可以再插值器中随便设置的，大于1也没可以。 下面是例子 自定义一个插值器 123456public class MyInterpolator implements Interpolator &#123; @Override public float getInterpolation(float input) &#123; return 2*input; &#125;&#125; 传进来的标准时间是0到1 ，返回的动画进度从0到2. 写的是转到360度，但是动画会从0转到720度，转两圈,速度是匀速。 1234animation = new RotateAnimation(0,360);animation.setDuration(3000);animation.setInterpolator(new MyInterpolator());iv.startAnimation(animation);","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"SystemServer的产生和启动","date":"2017-04-26T10:21:22.000Z","path":"2017/04/26/SystemServer的产生和启动/","text":"概括基于Android7.1源码。 结合一些文章想看一下Android的SystemServer的产生和启动，发现7.1的代码和文章上的不太一样，只玩的源码我也没看过，不知道什么时候开始变得。就做一个记录。大致流程就是 12345678910st=&gt;start: Starte=&gt;end: Endop1=&gt;operation: 系统的第一个用户进程Init进程启动op2=&gt;operation: 解析init.rc文件op3=&gt;operation: 从init进程中fork出zygote进程，也就是app_main.cpp文件op4=&gt;operation: zygote进程调用AppRuntime的start方法启动ZygoteInit，进入javaop5=&gt;operation: ZygoteInit中从zygote进程fork一个system_server进程op6=&gt;operation: ZygoteInit调用RuntimeInit.zygoteInit方法，找到SystemServer类和他的main方法op7=&gt;operation: 由ZygoteInit执行SystemServer的main方法st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;op7-&gt;e init进程init是Android系统中用户级的第一个进程。通过ps命令可以看到，进程ID是1. 。 既然整个用户系统都是从init开始的，那么SystemService肯定也是从这里创建了。 init进程的入口是main()方法 /system/core/init/init.cpp： 123int main(int argc, char** argv) &#123; parser.ParseConfig(\"/init.rc\");&#125; 要解析一个init.rc文件 /system/core/rootdir/init.rc: 1import /init.$&#123;ro.zygote&#125;.rc 在这个文件夹下还有这些文件： 以init.zygote64.rc为例 /system/core/rootdir/init.zygote64.rc 12345678910service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks 通过解析这个文件，会从init进程中fork出zygote进程。 zygote进程zygote对应的源文件是app_main.cpp,这个进程把自己的名字重命名为zygote。 /frameworks/base/cmds/app_process/app_main.cpp： 1234567891011121314151617181920212223242526static const char ZYGOTE_NICE_NAME[] = \"zygote64\";int main(int argc, char* const argv[])&#123; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; &#125; //重命名进程名字 if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 看到最后又一句runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);，把事情交给runtime去做。runtime是AppRuntime，AppRuntime是继承AndroidRuntime的： /frameworks/base/cmds/app_process/app_main.cpp： 12345678910111213141516171819202122232425class AppRuntime : public AndroidRuntime&#123; public:AppRuntime(char* argBlockStart, const size_t argBlockLength) : AndroidRuntime(argBlockStart, argBlockLength) , mClass(NULL)&#123;&#125; void setClassNameAndArgs(const String8&amp; className, int argc, char * const *argv) &#123; ...... &#125; virtual void onVmCreated(JNIEnv* env)&#123; ...... &#125; virtual void onStarted()&#123; ...... &#125; virtual void onZygoteInit()&#123; ...... &#125; virtual void onExit(int code)&#123; ...... &#125;&#125; AppRuntime并没有start方法，因此start方法是AndroidRuntime的： /frameworks/base/core/jni/AndroidRuntime.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; //设置ANDROID_ROOT环境变量 const char* rootDir = getenv(\"ANDROID_ROOT\"); if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1); &#125; //启动虚拟机 if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); //注册Android的JNI函数 if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; //用数组保存类名和参数 stringClass = env-&gt;FindClass(\"java/lang/String\"); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); classNameStr = env-&gt;NewStringUTF(className); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; //找到这个类，并执行这个类的main方法，前面调用时传入的是`com.android.internal.os.ZygoteInit` char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //找到main方法 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //通过JNI执行main方法,com.android.internal.os.ZygoteInit是一个java类 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); &#125; //zygote退出 if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(\"Warning: unable to detach main thread\\n\"); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(\"Warning: VM did not shut down cleanly\\n\");&#125; 这个start方法启动AndroidRuntime，先启动虚拟机，然后注册JNI函数，最后通过传进来的第一个参数找到相应的类，并执行他的main()方法。 这时，从native进入java层了。 进入Java代码 ZygoteInit.java下面就是ZygoteInit的main方法: /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String argv[]) &#123; try &#123; RuntimeInit.enableDdms(); // 开始 zygote 初始化. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; &#125; //注册一个服务端的socket供zygote使用 registerZygoteSocket(socketName); //预加载，包括类，资源，等等 preload(); // 结束zygote 初始化. SamplingProfilerIntegration.writeZygoteSnapshot(); // 进行一次垃圾回收 gcAndFinalize(); if (startSystemServer) &#123; //启动system_server进程 startSystemServer(abiList, socketName); &#125; &#125; catch (MethodAndArgsCaller caller) &#123; ...... &#125; &#125;static void preload() &#123; Log.d(TAG, \"begin preload\"); beginIcuCachePinning(); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); endIcuCachePinning(); warmUpJcaProviders(); Log.d(TAG, \"end preload\"); &#125; ZygoteInit的main方法中调用startSystemServer(abiList, socketName)算是启动了system_server进程。 system_server进程的产生system_server是Android系统Service运行的进程,这个进程死了后，会导致zygote进程重新启动. startSystemServer也是ZygoteInit的方法： /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java: 123456789101112131415161718192021222324252627282930313233343536private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; /* 硬编码命令行启动系统服务器 */ String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", //进程名system_server \"--runtime-args\", \"com.android.server.SystemServer\",//启动类 SystemServer &#125;; ZygoteConnection.Arguments parsedArgs = null; try &#123; //把上面的命令转为Arguments对象 parsedArgs = new ZygoteConnection.Arguments(args); /* 从Zygote进程中fork一个system server 子进程 */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs); &#125; return true; &#125; 从Zygote进程中fork一个system server 子进程，那么Zygote.forkSystemServer做了什么，怎么启动SystemServer的呢？ /frameworks/base/core/java/com/android/internal/os/Zygote.java: 123456789101112131415public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; VM_HOOKS.preFork(); int pid = nativeForkSystemServer( uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities); // Enable tracing as soon as we enter the system_server. if (pid == 0) &#123; Trace.setTracingEnabled(true); &#125; VM_HOOKS.postForkCommon(); return pid; &#125;native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities); 调用了native方法nativeForkSystemServe，这个方位定义在com_android_internal_os_Zygote.cpp中 /frameworks/base/core/jni/com_android_internal_os_Zygote.cpp： 12345678910111213141516171819202122232425262728static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) &#123; pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, permittedCapabilities, effectiveCapabilities, MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL, NULL, NULL); if (pid &gt; 0) &#123; gSystemServerPid = pid; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; RuntimeAbort(env, __LINE__, \"System server process has died. Restarting Zygote!\"); &#125; &#125; return pid;&#125;static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; pid_t pid = fork(); return pid;&#125; system_server进程的执行上面fork了一个进程后，返回了pid,在回到ZygoteInit的startSystemServer方法： /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java: 1234567891011121314151617private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; /* 硬编码命令行启动系统服务器 */ try &#123; //把上面的命令转为Arguments对象 parsedArgs = new ZygoteConnection.Arguments(args); /* 从Zygote进程中fork一个system server 子进程 */ pid = Zygote.forkSystemServer( ); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; if (pid == 0) &#123; handleSystemServerProcess(parsedArgs); &#125; return true; &#125; 通过Zygote.forkSystemServer方法之后，system_server进程就产生了。下面就该这个进程干活了。 system_server进程生成后，执行了handleSystemServerProcess(parsedArgs)方法： /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java: 123456789101112131415private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; if (parsedArgs.invokeWith != null) &#123; &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createSystemServerClassLoader(systemServerClasspath,parsedArgs.targetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; /* 将参数传递给SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; &#125; 下面是RuntimeInit.zygoteInit： /frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader); &#125;private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; nativeSetExitWithoutCleanup(true); // 将参数传递给类的主方法 main()，也就是com.android.server.SystemServer的main方法。 invokeStaticMain(args.startClass, args.startArgs, classLoader); &#125;private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className,ex); &#125; Method m; try &#123; //找到main方法 m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; //然后并没哟着这里执行，而是抛出了异常。 throw new ZygoteInit.MethodAndArgsCaller(m, argv); &#125; 上面说是执行main方法，但是真正功能只是找到了main方法，然后并没有执行，而是抛出了一个异常ZygoteInit.MethodAndArgsCaller。这是ZygoteInit内部定义的一个异常。 /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java: 1234567891011121314151617181920212223242526public static class MethodAndArgsCaller extends Exception implements Runnable &#123; /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125; &#125; 这个异常会一直向上抛，一直到ZygoteInit的main方法里才会捕捉处理： /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java: 12345678910111213public static void main(String argv[]) &#123; try &#123; if (startSystemServer) &#123; startSystemServer(abiList, socketName); &#125; &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (Throwable ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125; &#125; 看到上面的caller.run()，结合上面的MethodAndArgsCaller，这里才是真正执行SystemServer.main()方法的地方。 SystemServer.main()这下终于进入SystemServer了 直接看进入的main方法,就一句： /frameworks/base/services/java/com/android/server/SystemServer.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private static final long SNAPSHOT_INTERVAL = 60 * 60 * 1000; // 1hrpublic static void main(String[] args) &#123; new SystemServer().run(); &#125;public SystemServer() &#123; // Check for factory test mode. mFactoryTestMode = FactoryTest.getMode(); &#125;private void run() &#123; try &#123; // 调整系统时间 if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123; Slog.w(TAG, \"System clock is before 1970; setting to 1970.\"); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); &#125; //这里系统已经欢迎我们来到Android system server了。！。 // Here we go! Slog.i(TAG, \"Entered the Android system server!\"); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis()); // 性能采样分析，输出到文件.一小时执行一次 if (SamplingProfilerIntegration.isEnabled()) &#123; SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() &#123; @Override public void run() &#123; SamplingProfilerIntegration.writeSnapshot(\"system_server\", null); &#125; &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); &#125; //这里开启了一个Looper android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper(); System.loadLibrary(\"android_servers\"); performPendingShutdown(); //初始化系统Context createSystemContext(); // 创建SystemServiceManager mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; // 启动一些系统服务. try &#123; startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"******************************************\"); Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125;private void createSystemContext() &#123; //创建系统的Context是在ActivityThread中完成的。 ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(DEFAULT_SYSTEM_THEME); &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://blog.miaolegewu.top/tags/源码/"}]},{"title":"AndroidStudio JNI CMake","date":"2017-04-25T04:04:05.000Z","path":"2017/04/25/AndroidStudio-JNI-CMake/","text":"从AndroidStudio2.2开始，AS就整合了CMake来使用NDK。这种方式比之前用过的简单多了。这里记录一下简单使用。 当然，这些东西要先装好： 在新项目中使用创建在创建新项目时可以直接选中增加JNI。 然后一路next 点击finish完成创建。这时，AS就生成了ndk开发环境. 和不带JNI的项目新的区别 首先看目录结构，多了个cpp文件夹和cpp文件，多了个CMakeLists.txt文件 下面是native-lib.cpp文件,返回Hello from C++： 1234567891011#include &lt;jni.h&gt;#include &lt;string&gt;extern \"C\"JNIEXPORT jstring JNICALLJava_com_sunlinlin_jniapp_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str());&#125; 下面是CMakeLists.txt： 123456789101112131415161718192021cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp )find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 然后是构建文件的配置 使用在Activity中就正常使用： 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; // Used to load the 'native-lib' library on application startup. static &#123; System.loadLibrary(\"native-lib\"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(stringFromJNI()); &#125; /** * A native method that is implemented by the 'native-lib' native library, * which is packaged with this application. */ public native String stringFromJNI();&#125; 直接运行就是下图： 在现有项目上增加jni其实就是照猫画虎，手动加上上面的那些文件就行了。 在Java中定义载入库的名字和native方法名： 123456789101112131415public class MainActivity extends AppCompatActivity &#123; static&#123; System.loadLibrary(\"myjni\"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(strFromJNI()); &#125; public native String strFromJNI();&#125; 新建myjin.cpp文件在src/main/cpp/myjni.cpp,里面实现strFromJNI这个方法。 方法名是Java_包名_方法名,把包名的.改成_。 1234567891011#include &lt;jni.h&gt;#include &lt;string&gt;extern \"C\"JNIEXPORT jstring JNICALLJava_com_sunlinlin_myapp_MainActivity_strFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = \"Hello from MYJNI\"; return env-&gt;NewStringUTF(hello.c_str());&#125; 在app目录下建立CMakeLists.txt文件,必须说这个名字 12345678910111213cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. myjni # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/myjni.cpp )target_link_libraries( myjni android log) 然后在app的build.gradle文件中配置 然后运行就能得到下图： 增加cpp文件要增加一个hisjni.cpp ,就在cpp文件夹中建立hisjni.cpp： 1234567891011#include &lt;jni.h&gt;#include &lt;string&gt;extern \"C\"JNIEXPORT jstring JNICALLJava_com_sunlinlin_myapp_MainActivity_strFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = \"Hello from MYJNI\"; return env-&gt;NewStringUTF(hello.c_str());&#125; 然后在CMakeLists.txt中增加配置： 1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. myjni # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/myjni.cpp )target_link_libraries( myjni android log)add_library( # Sets the name of the library. hisjni # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/hisjni.cpp )target_link_libraries( hisjni android log) 就能在Java中使用了： 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; static&#123; System.loadLibrary(\"myjni\"); System.loadLibrary(\"hisjni\"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(strFromHisJNI()); &#125; public native String strFromJNI(); public native String strFromHisJNI();&#125; 更多配置。上面只是简单的使用，在build.gradle中还能有更多的灵活的配置，参考官方文档","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"数组和链表的区别","date":"2017-04-24T08:01:22.000Z","path":"2017/04/24/数组和链表的区别/","text":"数组和链表是两种基本的数据结构，他们在内存存储上的表现不一样，所以也有各自的特点。 大致总结一下特点和区别，拿几个人一起去看电影时坐座位为例。 数组的特点 在内存中，数组是一块连续的区域。 拿上面的看电影来说，这几个人在电影院必须坐在一起。 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 比如看电影时，为了保证10个人能坐在一起，必须提前订好10个连续的位置。这样的好处就是能保证10个人可以在一起。但是这样的缺点是，如果来的人不够10个，那么剩下的位置就浪费了。如果临时有多来了个人，那么10个就不够用了，这时可能需要将第11个位置上的人挪走，或者是他们11个人重新去找一个11连坐的位置，效率都很低。如果没有找到符合要求的作为，那么就没法坐了。 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 比如原来去了5个人，然后后来又去了一个人要坐在第三个位置上，那么第三个到第五个都要往后移动一个位子，将第三个位置留给新来的人。 当这个人走了的时候，因为他们要连在一起的，所以他后面几个人要往前移动一个位置，把这个空位补上。 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。 并且不利于扩展，数组定义的空间不够时要重新定义数组。 链表的特点 在内存中可以存在任何地方，不要求连续。 在电影院几个人可以随便坐。 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。 第一个人知道第二个人的座位号，第二个人知道第三个人的座位号…… 增加数据和删除数据很容易。 再来个人可以随便坐，比如来了个人要做到第三个位置，那他只需要把自己的位置告诉第二个人，然后问第二个人拿到原来第三个人的位置就行了。其他人都不用动。 查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。 要找到第三个人，必须从第一个人开始问起。 不指定大小，扩展方便。链表大小不用定义，数据随意增删。 各自的优缺点数组的优点 随机访问性强 查找速度快 数组的缺点 插入和删除效率低 可能浪费内存 内存空间要求高，必须有足够的连续内存空间。 数组大小固定，不能动态拓展 链表的优点 插入删除速度快 内存利用率高，不会浪费内存 大小没有固定，拓展很灵活。 链表的缺点 不能随机查找，必须从第一个开始遍历，查找效率低 - 数组 链表 读取 O(1) O(n) 插入 O(n) O(1) 删除 O(n) O(1)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.miaolegewu.top/tags/数据结构/"}]},{"title":"开源项目收集","date":"2017-04-24T03:35:55.000Z","path":"2017/04/24/开源项目收集/","text":"https://juejin.im/post/58f61bb55c497d006ca294bb一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 底部弹出视图 底部弹出视图 底部Tab组件 底部Tab组件 进度条 进度条 日志打印工具 日志打印工具 https://github.com/orhanobut/logger 支持自定义样式的toast 吐司 支持自定义样式的toast 吐司 自定义时间线，物流线等流程图自定义时间线，物流线等流程图 自定义角标，徽章[自定义角标，徽章","tags":[]},{"title":"GitHub Permission denied(publickey)","date":"2017-04-24T03:01:01.000Z","path":"2017/04/24/GitHub-Permission-denied-publickey/","text":"问题Mac系统 每次系统重新启动后，再git说提交都会提示12Permission denied (publickey).fatal: Could not read from remote repository. 我本地已经在 .ssh/文件夹里有公钥和私钥，而且公钥也已经在GitHub上设置好了，但提交时就是会提示上面的错误。 解决： 方法一：重新生成公钥和私钥，重新子啊GitHub上设置 方法二：运行命令 ssh-add 私钥文件名。 如我的 ssh-add ~/.ssh/wangyisll-GitHub。需要输入私钥密码。，然后有提示 Identity added: /Users/sunlinlin/.ssh/wangyisll-GitHub (/Users/sunlinlin/.ssh/wangyisll-GitHub) 就成功了。 觉得下面的方便点。","tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://blog.miaolegewu.top/tags/版本控制/"}]},{"title":"java集合的交集，并集，差集","date":"2017-04-21T01:45:52.000Z","path":"2017/04/21/java集合的交集，并集，差集/","text":"今天要用到差集，突然懵逼了,然后脑子一抽写出了下面的代码123456789Set&lt;String&gt; set1 = new HashSet&lt;&gt;();Set&lt;String&gt; set2 = new HashSet&lt;&gt;();set1.add(\"a\");set1.add(\"b\");set1.add(\"c\");set2.add(\"c\");set2.add(\"d\");set2.add(\"e\");System.out.println(set1 &amp; set2); 在有些语言中这样是可以求出交集的，但是在java中&amp;是一个位运算符，不能这样用。 交集就是两个集合都有的部分，java的集合也提供了对应的方法，retainAll 求交集，并集这些还是用set集合合适点 交集123456789101112131415Set&lt;String&gt; set1 = new HashSet&lt;&gt;(); Set&lt;String&gt; set2 = new HashSet&lt;&gt;(); set1.add(&quot;a&quot;); set1.add(&quot;b&quot;); set1.add(&quot;c&quot;); set2.add(&quot;c&quot;); set2.add(&quot;d&quot;); set2.add(&quot;e&quot;); //交集 set1.retainAll(set2); System.out.println(&quot;交集是 &quot;+set1); 并集1set1.addAll(set2); 差集1set1.removeAll(set2);","tags":[{"name":"java","slug":"java","permalink":"http://blog.miaolegewu.top/tags/java/"}]},{"title":"图解算法笔记","date":"2017-04-19T01:38:49.000Z","path":"2017/04/19/图解算法笔记/","text":"[TOC] 大O表示法 log都指 $log_2$ 大O表示算法的速度有多快，但并不是以秒为单位的速度。而是操作数增加时，算法运行时间的增速。 表示最糟糕情况下的运行时间 除了最糟糕情况下运行时间，还有平均运行时间 从快到慢的常用大O： O(log n) O(n) O(n*log n) O($n^2$) O(n!) 总时间和常量（固定时间量）有关。影响有时很大有时很小。 平均情况和最糟情况，如快读排序可能因为基准数的选择而遇到最坏情况和最糟情况。  二分查找的速度比简单查找快得多。 O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。  算法运行时间并不以秒为单位。 算法运行时间是从其增速的角度度量的。 算法运行时间用大O表示法表示。 内存存储的基本方式 数组和链表 两种最基本的数据结构——数组和链表 观众席座位，写便签安排事件顺序表，上菜顺序 数组 查询读取 随机访问 数组在内存中是相连的 不预留空间的话，增加新数据很麻烦，后面的都要向后挪。 数组要事前申请一定的内存空间，但可能自己用不了，别人也不能用，浪费内存。 超过申请空间大小，还是要挪。 如果空间不够，可能会需要将整个数组全部复制到另一块内存中。 数组知道每一个元素的地址，随机读取效率高，能迅速找到数组中的任何元素 链表 插入 删除 顺序访问 可以存储在内存任何地方，每一个元素存储了下一个元素的内存地址，从而串在一起。 增加数据很容易 删除元素很容易 如果需要读取最后一个元素，需要从第一个元素开始访问，然后依次获取下一个元素的内存地址，直至访问到最后一个元素。 需要读所有元素时，链表效率很高：读取第一个元素，然后根据地址读取第二个元素。 如果需要跳跃，效率很低。 数组下标索引从0开始 表 - 数组 链表 读取 O(1) O(n) 插入 O(n) O(1) 删除 O(n) O(1) O(n)=线性时间 O(1)=常量时间 链表删除时，只有能一次就访问到的时候时间才是O(1)，链表能直接访问到底额元素是第一个元素和最后一个元素。 选择排序 计算机内存犹如一大堆抽屉。  需要存储多个元素时，可使用数组或链表。  数组的元素都在一起。  链表的元素是分开的，其中每个元素都存储了下一个元素的地址。  数组的读取速度很快。  链表的插入和删除速度很快。  在同一个数组中，所有元素的类型都必须相同(都为int、double等)。 递归 递归和循环作用相同，递归更清晰。 循环性能可能更好，递归可能更清晰 递归要防止死循环 基线条件-&gt;跳出递归 递归条件-&gt;递归调用自己 递归调用栈 栈不能用于查找 每调用一次方法，系统就会将该方法调用涉及的所有变量存储到内存中。 调用栈可能会占用大量的内存，如果栈很高，可能意味着计算机存储了大量的调用栈这时：1.改用循环。 2.尾递归 每个程序分配的栈空间有限，超出会引发栈溢出异常。  递归指的是调用自己的函数。  每个递归函数都有两个条件:基线条件和递归条件。  栈有两种操作:压入和弹出。  所有函数调用都进入调用栈。  调用栈可能很长，这将占用大量的内存。 分而治之-递归式问题解决方案 土地分方块 原理： 找出简单的基线条件 确定如何缩小问题规模，使其符合基线条件 快速排序 选一个基准，进行分区排序  D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元 素的数组。  实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。  大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。  比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。 散列表 最有用的基本数据结构之一 散列表的内部机制:实现、冲突和散列函数 散列函数 不管给他什么数据，都返还给你一个数字 “将输入映射到数字” 散列函数满足的要求： 它必须是一致的。同样的额输入获得同样的数字。 它应该讲不同的输入映射到不同的数字。这个数字为存储数组的下标，然而这样的函数几乎不可能写出。 散列表用数组来存储数据，因此 获取元素的速度跟数组一样快 散列函数知道数组有多大，只会返回合法的数组下标 散列表里面由键和值组成，键被散列函数变为一个数字作为数组下标，这个下标的值就是值 平均情况下，散列表的插入删除速度跟链表一样快，查找速度跟数组一样快。O(1) 最糟情况下，散列表的这些速度都是 O(n) 作用 散列表被用于大海捞针式的查找 如DNS解析 在插入数据前先查询，防止重复插入。速度非常快  模拟映射关系;  防止重复;  缓存/记住数据，以免服务器再通过处理来生成它们。 冲突 理想状态是 散列函数总是将不同的键映射到数组的不同位置。 但实际上，几乎不可能编写出这样的散列函数 当多个数据分配到同一个下标的时候，就在这个下标上存储一个链表， 散列函数很重要，如果链表很长，那么性能会急剧下降。好的散列函数不会产生很长的链表。 性能 简单查找 O(n) 线性时间 二分查找 O(log n) 对数时间 散列查找 O(1) 常量时间 避免冲突就能避开最糟情况： 较低的填装因子 良好的散列函数 填装因子=元素数/位置数 可以理解为平均每一个位置要存多少个元素。填装因子1，则一个位置不止一个元素。 一般填装因子&gt;0.7就考虑调整数组长度，减少填装因子。 良好的散列函数就是散列函数尽量将不同的键映射到数组的不同位置，让数组中的值均匀分布 SHA函数  你可以结合散列函数和数组来创建散列表。  冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。  散列表的查找、插入和删除速度都非常快。  散列表适合用于模拟映射关系。  一旦填装因子超过0.7，就该调整散列表的长度。  散列表可用于缓存数据(例如，在Web服务器上)。  散列表非常适合用于防止重复。 广度优先搜索 图算法 图由节点和边组成，一个节点可能与多个节点直接连接，叫邻居 广度优先搜索。找一个东西，朋友没有，从朋友的朋友找，从朋友的朋友的朋友找，直到找到 先搜索一度关系，在搜索二度关系 排队，先进先出 有向图 无向图 最短路径算法（非加权图 段数最少） 建立一个队列，先把一度关系加入队列中，然后从第一个人开始，查找不到就把这个人的二度关系加入队列，然后取出队列的第二个人开始搜索。直到找到或队列为空。 避免重复检查，陷入死循环 运行时间 = 人数加边数 =O(V+E) V为顶点 E为边数 拓扑排序  广度优先搜索指出是否有从A到B的路径。  如果有，广度优先搜索将找出最短路径。  面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。  有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约会，而rachel也与ross约会”。  队列是先进先出(FIFO)的。  栈是后进先出(LIFO)的。  你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。  对于检查过的人，务必不要再去检查，否则可能导致无限循环。 狄克斯特拉算法 加权图 不能将狄克斯特拉算法用于包含负权边的图 最短路径算法（加权图 权重最少） 这里重述一下，狄克斯特拉算法包含4个步骤。 (1) 找出最便宜的节点，即可在最短时间内前往的节点。 (2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。(下一节再介绍!) 每条边上的数字叫权重 带权重的叫加权图 最短路径用狄克斯特拉算法 不带数字的叫非加权图 最短路径用广度优先搜索 两个节点互相指向对方，就成了一个环 无向图中，每条边都是一个环 狄克斯特拉算法只适用于有向无环图 实现狄克斯特拉算法 广度优先搜索用于在非加权图中查找最短路径。  狄克斯特拉算法用于在加权图中查找最短路径。  仅当权重为正时狄克斯特拉算法才管用。  如果图中包含负权边，请使用贝尔曼福德算法。 贪婪算法 贪婪策略 贪婪算法优点：简单易行 每步都采取最优的做法，每步都选择局部最优解，最终得打全局最优解 易于实现，但并非都有效 贪婪算法可以得到与正确解相近的解，而且更容易得到 近似算法 获取精准解需要的时间太长时，可以使用。 优劣标准如下 速度有多快 得到的近似解与最优解的接近程度 NP完全问题 旅行商问题 线路有n!条 需要计算出所有解，并从中选出最小/最短的那个 NP完全问题 是以难解著称的问题  元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。  涉及“所有组合”的问题通常是NP完全问题。  不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。  如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能就是NP完全问题。  如果问题涉及集合(如广播台集合)且难以解决，它可能就是NP完全问题。  如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。  贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。  对于NP完全问题，还没有找到快速解决方案。  面临NP完全问题时，最佳的做法是使用近似算法。  贪婪算法易于实现、运行速度快，是不错的近似算法。 动态规划 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当 每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。 最长公共子串 启示：  动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必 须在背包容量给定的情况下，偷到价值最高的商品。  在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 贴士：  每种动态规划解决方案都涉及网格。  单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。  每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网 格的坐标轴。 实际应用：  生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相 似。最长公共序列还被用来寻找多发性硬化症治疗方案。  你使用过诸如git diff等命令吗?它们指出两个文件的差异，也是使用动态规划实现的。 前面讨论了字符串的相似程度。编辑距离(levenshtein distance)指出了两个字符串的相 似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。  你使用过诸如Microsoft Word等具有断字功能的应用程序吗?它们如何确定在什么地方断 字以确保行长一致呢?使用动态规划!  需要在给定约束条件下优化某种指标时，动态规划很有用。  问题可分解为离散子问题时，可使用动态规划来解决。  每种动态规划解决方案都涉及网格。  单元格中的值通常就是你要优化的值。  每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。  没有放之四海皆准的计算动态规划解决方案的公式。 K最近邻算法 (k-nearest neighbours，KNN) 距离公式 回归 机器学习 推荐系统  KNN用于分类和回归，需要考虑最近的邻居。  分类就是编组。  回归就是预测结果(如数字)。  特征抽取意味着将物品(如水果或用户)转换为一系列可比较的数字。 5  能否挑选合适的特征事关KNN算法的成败。 十一树 二叉查找树 平均查找时间为O(log n) 最糟为 O(n) 最糟情况比有序数组要慢，但是二叉查找树的插入和删除速度很快 二叉查找树不能随机访问 。如果二叉查找树处于平衡状态，那么平均访问时间也是 O(log n) B树 红黑树 堆 伸展树 反向索引 一个散列表，将单词映射到包含它的页面 这种数据结构叫做反向索引 常用于创建搜索引擎 傅里叶变换 如果能够将歌曲分解为不同的频率，就可强化 你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音 乐。 并行算法 并行提升的速度并不是线性的，双核并行计算并不能让算法的速度提高一倍。因为 并行性管理开销： 假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之 间分配这项任务呢?如果让每个内核对其中500个元素进行排序，再将两个排好序的数组 合并成一个有序数组，那么合并也是需要时间的 负载均衡： 假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核 A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意 味着有那么50秒，内核B在忙死忙活，而内核A却闲得很!你如何均匀地分配工作，让两 个内核都一样忙呢? MapReduce MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。 当并行算法只需要几个内核时，一台计算机就能运行了。如果需要大量的内核时，可让算法在多个计算机上运行。 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理 念:映射(map)函数和归并(reduce)函数。 映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理 归并是将一个数组转换为一个元素 布隆过滤器和HyperLogLog 给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用散列表。 如果数据集很大，散列表很大，需要占用大量的存储空间，可以使用布隆过滤器。 布隆过滤器是一种概率型数据结构。提供的答案有可能不对，但很可能说正确的。 可能出现报错的情况，但不可能出现漏报的情况。有就一定有，但可能会找到错误的。没有就一定没有，不可能返回有。 占用的存储空间很少，适合不要去答案绝对准确的情况。 HyperLogLog是一种类似于布隆过滤器的概率型算法，也不能给出准确答案，但占用存储空间少得多。 SHA 安全散列算法 SHA将一个字符串生成另一个字符串，然后根据生成的字符串生成数组索引，存储生成的字符串，索引说安全的。 判断两个文件是否相同，计算SHA值 检查密码。数据库存储散列值。 SHA-0,SHA-1,SHA-2,SHA-3,bcrypt 局部敏感的散列算法 SHA短发说局部不敏感的。这很安全，没法根据相似程度来破解 局部敏感的意思是，如果两个字符串的差别很细微，那么生成的散列值的差别哦也很细微。 局部敏感能通过比较散列值来判断两个字符串的相似程度。 Simhash是局部敏感的 Diffie-Hellman算法 密钥交换 双方无需知道加密算法。不必会面协商要使用的加密算法 要破解加密的消息比登天还难 使用公钥和私钥。 公钥是公开的，将其发布出去，别人向你发送消息时用公钥加密，然后自己受到消息用私钥解密，只有自己哟私钥，所以只有自己才能解密 线性规划 用于在给定约束条件下最大限度地改善指定的指标。 利润最大化","tags":[{"name":"读书","slug":"读书","permalink":"http://blog.miaolegewu.top/tags/读书/"}]},{"title":"Android动画-属性动画-ViewPropertyAnimator","date":"2017-04-18T02:44:57.000Z","path":"2017/04/18/Android动画-属性动画-ViewPropertyAnimator/","text":"想想之前使用组合动画的时候，是不是这样的：123456ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow, \"translationX\", 0, 300);ObjectAnimator objectAnimator1 = ObjectAnimator.ofFloat(btnShow, \"rotation\", 0, 360);AnimatorSet animatorSet = new AnimatorSet();animatorSet.setDuration(2000);animatorSet.play(objectAnimator).with(objectAnimator1);animatorSet.start(); 或者这样的： 123456 ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow, \"translationX\", 0, 300);ObjectAnimator objectAnimator1 = ObjectAnimator.ofFloat(btnShow, \"rotation\", 0, 360);AnimatorSet animatorSet = new AnimatorSet();animatorSet.setDuration(2000);animatorSet.playTogether(objectAnimator,objectAnimator1);animatorSet.start(); 达到的效果是： 初见然而，还能用下面的方法实现这个效果： 12345btnShow.animate() .setDuration(2000) .translationX(300) .rotation(360) .start(); 简单了很多有没有 ！ 概述平常所做的动画大部分是针对View的，而View经常会需要集中动画混合在一起做，因此提供了一个ViewPropertyAnimator类来快速的实现多个动画的混合。 ViewPropertyAnimator对同时进行多个动画进行了性能优化，虽然有多个动画同时进行，但是一次只刷新一次ui，不会让每个动画都去刷新ui。而且很明显他的写法非常简单。 获取ViewPropertyAnimator只能通过View.animate()获取ViewPropertyAnimator。 常用方法这里把能链式调用的全列举出来，感受一下他的方便之处： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566btnShow.animate() .setDuration(5000) //透明度 .alpha(0) .alphaBy(0) //旋转 .rotation(360) .rotationBy(360) .rotationX(360) .rotationXBy(360) .rotationY(360) .rotationYBy(360) //缩放 .scaleX(1) .scaleXBy(1) .scaleY(1) .scaleYBy(1) //平移 .translationX(100) .translationXBy(100) .translationY(100) .translationYBy(100) .translationZ(100) .translationZBy(100) //更改在屏幕上的坐标 .x(10) .xBy(10) .y(10) .yBy(10) .z(10) .zBy(10) //监听及其他设置 .setInterpolator(new BounceInterpolator()) .setStartDelay(1000) .setListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;) .setUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; &#125; &#125;) .withEndAction(new Runnable() &#123; @Override public void run() &#123; Log.i(TAG, \"run: end\"); &#125; &#125;) .withStartAction(new Runnable() &#123; @Override public void run() &#123; Log.i(TAG, \"run: start\"); &#125; &#125;) .start(); 动画的方法名和ObjectAnimator中药填写的属性名是一样的，很容易明白。 每个动画都有一个By的后缀的方法。加上By的意思是，继续动画这么多数值。不加By的意思是动画到这个数值。 也可以设置插值器和Animator.AnimatorListener监听以及ValueAnimator.AnimatorUpdateListener监听 可以直接设置动画开始和结束时的回调方法。 但是好像没有重复动画的功能 关于By下面用旋转来演示一下By的区别。 按钮初始旋转角度已经旋转了90， 当点击按钮执行的动画是下面这样的时候，表示旋转到180： 1234btnShow.animate() .setDuration(2000) .rotation(180) .start(); 第一次点击会从90旋转到180，再次点击会从180旋转到180，因为已经是180了，所以看着没动。 如果是By呢？： 1234btnShow.animate() .setDuration(2000) .rotationBy(180) .start();","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"Android动画-属性动画-AnimatorSet","date":"2017-04-18T02:44:31.000Z","path":"2017/04/18/Android动画-属性动画-AnimatorSet/","text":"AnimatorSet是对属性动画的一个集合，可以让很多动画按一定顺序或者 同时进行。 概览先看一下属性动画的结构，View动画的基类是Animation，属性动画的基类是Animator ValueAnimator：这个动画是针对属性的值进行动画的 ，不会对UI造成改变，不能直接实现动画效果。需要通过对动画的监听去做一些操作，在监听中将这个值设置给对应的属性，对应的属性才会改变。 ObjectAnimator：直接动画所给的对象,他会调用对象对应属性的get/set方法吧属性的值设置给对象的属性，直接实现动画效果。 简单使用AnimatorSet主要就是方便整合一大堆动画的，这里先定义两个动画 12ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"translationX\",0,300);ObjectAnimator objectAnimator1 = ObjectAnimator.ofFloat(btnShow,\"alpha\",0.1f,1f); 然后使用AnimatorSet整合起来： 12345AnimatorSet animatorSet = new AnimatorSet();animatorSet.playSequentially(objectAnimator,objectAnimator1);animatorSet.setDuration(2000);animatorSet.setInterpolator(new BounceInterpolator());animatorSet.start(); 里面其他方法跟一般的动画没什么区别，Duration可以单独设置也可以一起设置,都设置以AnimatorSet的为准。同样，animatorSet.setTarget也是以AnimatorSet的为准。如果加上一句animatorSet.setTarget(btnStart);那么动画的就是btnStart了，而不是btnShow。 主要是看playSequentially方法，这个方法参数就是要执行的属性动画 ，playSequentially表示按顺序执行这些动画： 如果调用animatorSet.playTogether(objectAnimator,objectAnimator1);表示这些动画一起执行： AnimatorSet.BuilderAnimatorSet有一个内部类AnimatorSet.Builder，AnimatorSet只提供了playSequentially和playTogether两种方式，而AnimatorSet.Builder可以自由组合各种方式。 AnimatorSet.Builder有四个方法： 方法 解释 after(long delay) 在一定时间后执行play里的动画 after(Animator anim) 先执行after里的动画，再执行play里的动画 before(Animator anim) 先执行play里的动画，再执行after里的动画 with(Animator anim) 一起执行 AnimatorSet.Builder通过调用AnimatorSet的play方法获取。 下面定义两个动画，用after： 123456ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow, \"translationX\", 0, 300);ObjectAnimator objectAnimator1 = ObjectAnimator.ofFloat(btnShow, \"rotation\", 0, 360);AnimatorSet animatorSet = new AnimatorSet();animatorSet.setDuration(2000);animatorSet.play(objectAnimator).after(objectAnimator1);animatorSet.start(); before: 1animatorSet.play(objectAnimator).before(objectAnimator1); with: 1animatorSet.play(objectAnimator).with(objectAnimator1); 对AnimatorSet的监听AnimatorSet内部有一个私有的监听AnimatorSetListener，这个用来他自己处理内部动画。 自己加监听一般是Animator.AnimatorListener 123456789101112131415161718animatorSet.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; Log.i(TAG, \"onAnimationStart: \"); &#125; @Override public void onAnimationEnd(Animator animation) &#123; Log.i(TAG, \"onAnimationEnd: \"); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Log.i(TAG, \"onAnimationCancel: \"); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Log.i(TAG, \"onAnimationRepeat: \"); &#125; &#125;); 这个时候，AnimatorSet中的所有动画成了一个整体，onAnimationEnd是在所有动画完成后才会调用，不管是顺序执行还是同时执行。 XML表示AnimatorSet在XML中的标签也是&lt;set&gt;，但是也是要把文件定义在res/animator中 如 res/animator/anim_set: 1234567891011&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:ordering=\"together\"&gt; &lt;objectAnimator android:valueFrom=\"0\" android:valueTo=\"360\" android:propertyName=\"rotation\"/&gt; &lt;objectAnimator android:valueFrom=\"0\" android:valueTo=\"360\" android:propertyName=\"translationX\"/&gt;&lt;/set&gt; java中： 1234AnimatorSet animatorSet = (AnimatorSet) AnimatorInflater.loadAnimator(context,R.animator.anim_set); animatorSet.setTarget(btnShow); animatorSet.setDuration(2000); animatorSet.start(); android:orderinandroid:orderin有两个值，sequentially和together，分别对应playSequentially和playTogether两个方法的效果。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"Android动画-属性动画-ObjectAnimator","date":"2017-04-17T03:40:53.000Z","path":"2017/04/17/Android动画-属性动画-ObjectAnimator/","text":"ObjectAnimator是最常用的属性动画，他能直接作用在对象上实现动画。 概览先看一下属性动画的结构，View动画的基类是Animation，属性动画的基类是Animator ValueAnimator：这个动画是针对属性的值进行动画的 ，不会对UI造成改变，不能直接实现动画效果。需要通过对动画的监听去做一些操作，在监听中将这个值设置给对应的属性，对应的属性才会改变。 ObjectAnimator：直接动画所给的对象,他会调用对象对应属性的get/set方法吧属性的值设置给对象的属性，直接实现动画效果。 TimeAnimator：这个也不直接实现动画效果，只是提供一个监听回调，返回动画执行的总时间，距离上次动画执行的时间等。 由图可以看出，ObjectAnimator是从ValueAnimator中继承出来的，因此ValueAnimator的属性方法他都有。 在ValueAnimator中需要在动画变化监听中手动更改对象的属性，是动画的使用有一种分裂的感觉。用动画肯定是像让眼睛能看见的界面动起来的，而不仅仅是让看不见的数值动。ObjectAnimator就把这个过程整合在了一起。 基本使用ObjectAnimator的初始化也是通过一系列ofXXX()方法来进行，但是参数有所变化，他的这些方法都要求传入一个Object对象，然后就会在这个对象上执行动画。这个没毛病，不给他对象他怎么知道给哪个对象动画呢？ 先看一个最简单的方法ofInt(Object target, String propertyName, int... values): 有这样的布局： 12345678910111213&lt;Button android:id=\"@+id/btn_start\" android:text=\"开始动画\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:id=\"@+id/btn_show\" android:layout_below=\"@+id/btn_start\" android:text=\"展示\" android:textSize=\"20sp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 然后执行属性动画： 12345678910final ObjectAnimator objectAnimator = ObjectAnimator.ofInt(btnShow,\"textColor\",0xffffffff,0xffff0000); objectAnimator.setDuration(3000); objectAnimator.setRepeatCount(Animation.INFINITE); objectAnimator.setRepeatMode(ValueAnimator.REVERSE); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; objectAnimator.start(); &#125; &#125;); 效果,图片无限循环的闪烁： 属性动画有些可以链式调用，如下面直接开始动画： 123ObjectAnimator.ofFloat(btnShow, \"translationX\", 0, 1, 0, 1) .setDuration(3000) .start(); 这是一个属性动画最简单的用法，默认的插值器也是加速减速插值器，具体插值器可以看插值器简单示例 分析一下ofInt(Object target, String propertyName, int... values)参数： 参数 解释 target 对象，指定要改变谁的属性 propertyName 属性名，指定要改变对象的什么属性，这个属性名要求在兑现中必须有对应的public的PsetPropertyName的方法。如上面的textColor就要求Button中必须有setTextColor方法才行。 values 一系列这个属性将会到达的值。 从这里可以看到这个属性动画也是名副其实，只要这个对象里设置有对应属性的set方法，就能用属性动画改变这个属性。 常用的属性动画因为属性动画可以改变提供了set方法的任意属性，所以就不像ViewAnimation一样仅仅局限于旋转，平移，缩放，渐变这四种动画了。 下面是常用的属性动画 ObjectAnimator第二个参数的属性 对应的set方法 效果 alpha public void setAlpha(float alpha) 改变透明度 translationX setTranslationX 沿X轴平移 translationY setTranslationY 沿Y轴平移Y scaleX setScaleX 沿X轴缩放 scaleY setScaleY 沿Y轴缩放 rotationX setRotationX 绕X轴旋转 rotationY setRotationY 绕Y轴旋转 rotation setRotation 绕Z轴旋转 旋转 绕Z轴旋转,Z轴就是垂直于屏幕的那个轴 123ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"rotation\",0,360);objectAnimator.setDuration(3000);objectAnimator.start(); 绕X轴旋转 123ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"rotationX\",0,360);objectAnimator.setDuration(3000);objectAnimator.start(); 绕Y轴旋转 123456789101112131415ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"rotationY\",0,360);objectAnimator.setDuration(3000);objectAnimator.start();``` ![](http://privateimage.oss-cn-hongkong.aliyuncs.com/donghua/objdonghua5.gif)## 透明```java ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(btnShow,\"alpha\",0,1,0,1); objectAnimator.setDuration(3000); objectAnimator.start(); 平移 沿X轴平移 123ObjectAnimator.ofFloat(btnShow, \"translationX\",0,200) .setDuration(3000) .start(); 沿Y轴平移 123ObjectAnimator.ofFloat(btnShow, \"translationY\",0,200) .setDuration(3000) .start(); 缩放 沿X轴缩放 123ObjectAnimator.ofFloat(btnShow, \"scaleX\",0,1) .setDuration(3000) .start(); 沿Y轴平移 123ObjectAnimator.ofFloat(btnShow, \"scaleY\",0,1) .setDuration(3000) .start(); 改变两个属性动画上面都是一次改变一个属性的，有没有错同事改变两个属性的方法呢？ ObjectAnimator提供有对应的方法ofFloat (Object target,String xPropertyName,String yPropertyName, Path path).Path定义两个属性要经过的值。 比如要向右下角平移，要同时改变translationX和translationY。Path的moveTo是定义初始值，默认是（0，0）。lineTo定义经过的值。下面是先平移到(500,500)，再平移到(300,600)： 1234567Path path = new Path(); path.moveTo(0,0); path.lineTo(500,500); path.lineTo(300,600); ObjectAnimator.ofFloat(btnShow,\"translationX\", \"translationY\",path) .setDuration(3000) .start(); 也可以改变连个不一样的值，比如让按钮平移的同时进行放大： 123456Path path = new Path(); path.moveTo(0,1); path.lineTo(300,3); ObjectAnimator.ofFloat(btnShow,\"translationX\", \"scaleY\",path) .setDuration(3000) .start(); 对动画的监听ObjectAnimator继承自ValueAnimator，所以对他的监听方法很ValueAnimator是一样的， Android动画-属性动画-ValueAnimato 对动画过程的控制 XML表示ObjectAnimator当然也恶意用XML来写，对应的标签是&lt;objectAnimator&gt; ,以缩放为例： 在res/animator中建立文件anim_obj.xml,这几个属性应该一看就只带是什么意思了，基本上所有的动画这些属性的意思都是一样的： 12345678910&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:valueType=\"floatType\" android:valueFrom=\"1\" android:valueTo=\"3\" android:startOffset=\"0\" android:duration=\"2000\" android:interpolator=\"@android:anim/linear_interpolator\" android:propertyName=\"scaleY\" android:repeatCount=\"1\" android:repeatMode=\"reverse\"/&gt; 然后在代码中调用： 123ObjectAnimator objectAnimator = (ObjectAnimator) AnimatorInflater.loadAnimator(context,R.animator.anim_obj); objectAnimator.setTarget(btnShow); objectAnimator.start(); 这里必须调用setTarget方法，不然动画的效果看不出来。这个方法告诉动画要改变谁的属性值。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"Android动画-属性动画-ValueAnimator","date":"2017-04-14T09:32:35.000Z","path":"2017/04/14/Android动画-属性动画-ValueAnimator/","text":"ValueAnimator是针对值进行动画，支持整形，浮点型，颜色，对象等类型。 PropertyAnimation，属性动画。 View动画顾名思义，只是对View进行动画，而且动画效果只有旋转，平移，缩放，透明度的动画。最关键的是View动画没有改变锁动画的View的真正位置。例如当一个按钮已经从左边平移到右边的时候，点击右边看得见的按钮是没效果的，还得点击按钮原来的位置，即使现在来开是一片空白。 而属性动画几乎什么都可以动画，是更强大的动画，可以通过属性动画让任何对象的属性都跟着时间的改变进行变化，任何对象哦，不仅仅是View。 概览先看一下属性动画的结构，View动画的基类是Animation，属性动画的基类是Animator ValueAnimator：这个动画是针对属性的值进行动画的 ，不会对UI造成改变，不能直接实现动画效果。需要通过对动画的监听去做一些操作，在监听中将这个值设置给对应的属性，对应的属性才会改变。 ObjectAnimator：直接动画所给的对象,他会调用对象对应属性的get/set方法吧属性的值设置给对象的属性，直接实现动画效果。 TimeAnimator：这个也不直接实现动画效果，只是提供一个监听回调，返回动画执行的总时间，距离上次动画执行的时间等。 基本使用之前说了，这个动画只对值进行动画，不会对UI产生实质性的改变，需要手动在监听事件中进行改变，下面是java代码的一个例子： 1234567891011121314btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Log.i(TAG, \"onAnimationUpdate: \" + animation.getAnimatedValue()); &#125; &#125;); valueAnimator.setDuration(3000); valueAnimator.start(); &#125; &#125;); 在一个按钮的点击事件中执行上面代码，就会在日志中看见一长串数字，从1到100，画成图是这样的： 可以看到数值变化并不是线性的，这是因为属性动画同样可以使用View动画的插值器，插值器前面已经简单介绍过一些了。因为ValueAnimator的默认插值器是加速减速插值器AccelerateDecelerateInterpolator，先加速后减速，所以图形是那样的。如果改成LinearInterpolator,就成一条直线了： 1valueAnimator.setInterpolator(new LinearInterpolator()); 首先创建ValueAnimator，一般是通过调用ValueAnimator的ofXXX方法进行的 ValueAnimator提供有ofInt(int... values),ofFloat(float... values),ofArgb(int... values),ofPropertyValuesHolder(PropertyValuesHolder... values).ofObject(TypeEvaluator evaluator, Object... values)。 后面两个牵扯到其他类先不说，常用的是前三个，因为比较简单。 里面的参数是可变参数，比如ofInt(1,100)表示从1动画到100.ofInt(1,100,50)表示从1动画到100再动画到50. 获取动画当前的值，进行操作。 只让值动画是没什么意义的，我们要根据值进行一些操作。因此要增加值变化的监听。ValueAnimator提供了AnimatorUpdateListener来监听，在onAnimationUpdate方法中调用animation.getAnimatedValue()获取动画最近的值，然后根据值进行操作。 123456valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Log.i(TAG, \"onAnimationUpdate: \" + animation.getAnimatedValue()); &#125; &#125;); 为动画增加动画时间等设置,然后调用start开始动画。 常用的设置有，这些和View动画差不多的： 方法 含义 valueAnimator.setDuration(); 设置动画时间 valueAnimator.setRepeatCount(); 设置重复次数 valueAnimator.setInterpolator(); 设置插值器 valueAnimator.setRepeatMode(); 设置重复模式 12valueAnimator.setDuration(3000);valueAnimator.start(); ofInt 和ofFloat以ofInt举个例子，ofFloat也是一样的，只是值类型不一样。进度条用动画来改变并不合理，只是个例子。再布局中增加一个进度条 1234567&lt;ProgressBar android:id=\"@+id/pg\" style=\"@style/Base.Widget.AppCompat.ProgressBar.Horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/btn\" android:max=\"100\" /&gt; 然后执行ValueAnimator,3秒从0到100,再到50，再到100： 123456789101112131415btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 100,50,100); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Log.i(TAG, \"onAnimationUpdate: \" + animation.getAnimatedValue()); pg.setProgress((Integer) animation.getAnimatedValue()); &#125; &#125;); valueAnimator.setDuration(3000); valueAnimator.start(); &#125; &#125;); onArgb点击按钮，让背景颜色由白变红再变蓝： 123456789101112131415btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ValueAnimator valueAnimator = ValueAnimator.ofArgb(0xffffffff,0xffff0000,0xff0000ff); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Log.i(TAG, \"onAnimationUpdate: \" + animation.getAnimatedValue()); btn.setBackgroundColor((Integer) animation.getAnimatedValue()); &#125; &#125;); valueAnimator.setDuration(3000); valueAnimator.start(); &#125; &#125;); 对动画过程的控制前面已经通过addUpdateListener设置ValueAnimator.AnimatorUpdateListener来对动画的值进行了监听，。 还有一个监听是通过valueAnimator.addListener设置Animator.AnimatorListener监听。 这个监听提供了start,end,cancel,repeat的监听: 1234567891011121314151617181920212223242526272829303132333435363738394041@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; initView(); initAnim(); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; valueAnimator.start(); &#125; &#125;); btnEnd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; valueAnimator.end(); &#125; &#125;); btnCancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; valueAnimator.cancel(); &#125; &#125;); btnPause.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; valueAnimator.pause(); &#125; &#125;); btnResume.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; valueAnimator.resume(); &#125; &#125;); &#125; 1234567891011121314151617181920212223242526272829303132private void initAnim() &#123; valueAnimator = ValueAnimator.ofInt(0, 100, 50, 100); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; pg.setProgress((Integer) animation.getAnimatedValue()); &#125; &#125;); valueAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; Toast.makeText(context, \"动画开始\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onAnimationEnd(Animator animation) &#123; Toast.makeText(context, \"动画结束\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Toast.makeText(context, \"动画取消\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Toast.makeText(context, \"动画重复\", Toast.LENGTH_SHORT).show(); &#125; &#125;); valueAnimator.setDuration(5000); valueAnimator.setRepeatCount(1); &#125; 除此之外，还提供了暂停和继续的方法 下面看一下正常的动画流程，开始-重复-结束： 下面看暂停和继续： 下面是结束和取消： 结束和取消的区别是，结束会直接让动画定位到结束的位置，而取消会让动画停在当前执行的位置。 用XML实现虽然属性动画用java代码实现更方便，也推荐用代码来写。但是也可以通过XML文件来写动画。 ValueAnimator对应的XML标签是&lt;animator&gt; 在res目录下建立文件夹animator 在在res目录下建立文件夹animator中新建anim_test.xml文件: 12345678910&lt;animator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"2000\" android:interpolator=\"@android:anim/linear_interpolator\" android:repeatCount=\"0\" android:repeatMode=\"restart\" android:startOffset=\"1000\" android:valueFrom=\"1\" android:valueTo=\"100\" android:valueType=\"intType\" /&gt; 在java代码中引用，上面的initAnim()方法改成这样： 1234567891011121314151617181920212223242526272829private void initAnim() &#123; valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(context,R.animator.anim_test); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; pg.setProgress((Integer) animation.getAnimatedValue()); &#125; &#125;); valueAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; Toast.makeText(context, \"动画开始\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onAnimationEnd(Animator animation) &#123; Toast.makeText(context, \"动画结束\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onAnimationCancel(Animator animation) &#123; Toast.makeText(context, \"动画取消\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onAnimationRepeat(Animator animation) &#123; Toast.makeText(context, \"动画重复\", Toast.LENGTH_SHORT).show(); &#125; &#125;); 然后执行动画： xml中属性 属性 含义 android:duration 动画执行时间 android:interpolator 插值器 android:repeatCount 重复次数 android:repeatMode 重复模式，reverse：倒着重放动画。restart：正着重放动画 android:startOffset 延迟开始动画时间 android:valueFrom 值得开始值，int float color android:valueTo 值得目标值 int float color android:valueType= 值得类型 intType floatType","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"Android动画-View动画的使用场景","date":"2017-04-14T02:50:37.000Z","path":"2017/04/14/Android动画-View动画的使用场景/","text":"View动画的一个特点就是，他的动画仅仅是动的View的绘制地方，View真正的位置并没有一起动画。 View除了会用作直接作用页面中的View外，通常还用用在下面一些地方 PopupWindow的动画原效果先做一个PopupWindow,这个PopupWindow的View只有一个背景图片，一只大猫。： 12345private void initWindow() &#123; View view = new View(this); view.setBackground(getDrawable(R.drawable.xiaomao)); popupWindow = new PopupWindow(view, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; 然后给按钮的点击事件设置为显示PopupWindow： 12345678910btnRun.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (popupWindow.isShowing()) &#123; popupWindow.dismiss(); &#125; else &#123; popupWindow.showAsDropDown(btnRun); &#125; &#125; &#125;); 这时的效果是这样的： 加动画那么现在加上一个动画，首先要定义动画。 进入的动画： 12345678910111213&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"100%\" android:toYDelta=\"0\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" android:duration=\"2000\" /&gt;&lt;/set&gt; 消失的动画： 12345678910111213&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"0\" android:toYDelta=\"100%\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration=\"2000\" /&gt;&lt;/set&gt; 做成一个style,在res/values/styles.xml文件里加上： 1234&lt;style name=\"pop_anim\"&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/pop_in&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/pop_out&lt;/item&gt; &lt;/style&gt; 设置动画 这一步就很简单，就加一行代码 123456private void initWindow() &#123; View view = new View(this); view.setBackground(getDrawable(R.drawable.xiaomao)); popupWindow = new PopupWindow(view, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); popupWindow.setAnimationStyle(R.style.pop_anim); &#125; 这时效果就成下面那样了： Activity过场动画通过overridePendingTransition这种方法写着简单但是不好用，通过overridePendingTransition，他的两个参数分别是新Activity进入时的动画和旧Activity退出时的动画.如果设置为0则没有动画。 这个方法必须跟在startActivity()或finish()后面才会生效。 还是先定义两个动画： 进入时的动画： 12345678910111213&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"100%\" android:toYDelta=\"0\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" android:duration=\"2000\" /&gt;&lt;/set&gt; 退出时的动画: 12345678910111213&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"0\" android:toYDelta=\"-100%\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration=\"2000\" /&gt;&lt;/set&gt; 跳转时调用： 12startActivity(new Intent(MainActivity.this,SecondActivity.class));overridePendingTransition(R.anim.activity_in,R.anim.activity_out); 效果： 也是通过style首先看res/values/styles.xml。定义了一个叫ActivityAnim的style，里面有四个属性，分表代表下面的含义 属性 含义 activityOpenEnterAnimation 打开一个新的Activity时，要显示的新的Activit执行的动画 activityOpenExitAnimation 打开一个新的Activity时，当前的旧的Activit执行的动画 activityCloseEnterAnimation 关闭一个activity时，要显示的上一个Activity执行的动画 activityCloseExitAnimation 关闭一个activity时，被关闭的Activity执行的动画 这四个动画可以针对需要只设置需要的。 把ActivityAnim设置给APP要用的主题AppTheme的android:windowAnimationStyle属性 1234567891011121314&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@style/ActivityAnim&lt;/item&gt; &lt;/style&gt; &lt;style name=\"ActivityAnim\"&gt; &lt;item name=\"android:activityOpenEnterAnimation\"&gt;@anim/activity_in&lt;/item&gt; &lt;item name=\"android:activityOpenExitAnimation\"&gt;@anim/activity_out&lt;/item&gt; &lt;item name=\"android:activityCloseEnterAnimation\"&gt;@anim/activity_close_in&lt;/item&gt; &lt;item name=\"android:activityCloseExitAnimation\"&gt;@anim/activity_close_out&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在后再清单文件里引用这个主题: 123456789101112131415161718&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.sunlinlin.animademo\"&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".SecondActivity\"&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 上面的四个动画分别是： activity_in： 123456789101112&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"100%\" android:toYDelta=\"0\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" android:duration=\"2000\" /&gt;&lt;/set&gt; activity_out: 123456789101112&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"0\" android:toYDelta=\"-100%\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration=\"2000\" /&gt;&lt;/set&gt; activity_close_in: 123456789101112&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"-100%\" android:toYDelta=\"0\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" android:duration=\"2000\" /&gt;&lt;/set&gt; activity_close_out: 123456789101112&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"0\" android:toYDelta=\"100%\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration=\"2000\" /&gt;&lt;/set&gt; 最终的效果是： 给ViewGroup的子控件加进场动画LayoutAnimation是作用于ViewGroup的，用来指定ViewGroup的子控件出现的动画 先做一个子控件出现的动画,从之前随便选个activity_in.xml： 123456789101112&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"0\" android:toXDelta=\"0\" android:fromYDelta=\"100%\" android:toYDelta=\"0\" android:duration=\"2000\" /&gt; &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" android:duration=\"2000\" /&gt;&lt;/set&gt; 准备好了动画，接下来有两种方法，也是xml和java 通过XML然后新建一个动画文件,这里叫anim_layout.xml,这里有三个属性： 属性 作用 android:delay 可以取值为数值，百分数，或百分数p。表示两个子控件执行出场动画的间隔时间，为0时，所有控件的动画没有延迟全部开始执行；为1时表示等上一个控件动画执行完毕才开始执行下一个；为0.5时表示等上一个控件动画执行一半开始执行下一个。可以大于1。。。当这个值为百分数时，如50%，表示这个延迟时间是当前动画执行时间的50%。。。当这个值是百分数p的时候，如50%p,表示这个延迟时间是父View的动画时间的50%。 android:animationOrder 有三个值：：normal表示按正常顺序出现。random表示乱序出现。reverse表示反序出现。 android:animation 指定出现时要执行的动画 anim_layout.xml文件代码,设置上一个动画执行五分之一时开始下一个动画，倒序执行： 12345&lt;layoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\" android:delay=\"0.2\" android:animationOrder=\"reverse\" android:animation=\"@anim/activity_in\"&gt;&lt;/layoutAnimation&gt; 然后在Activity的布局文件中，将一个LinearLayout通过android:layoutAnimation加上了这个动画： 12345678910111213&lt;LinearLayout android:id=\"@+id/ll\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_below=\"@+id/btn_back\" android:layoutAnimation=\"@anim/anim_layout\" android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"哈哈\" /&gt; ... &lt;/LinearLayout&gt; 然后进入这个Activity时就会看到这个效果： 通过java这里不需要建新的文件了。觉得比上面的方便许多，效果跟上图是一样的。 123456ll = (LinearLayout) findViewById(R.id.ll);Animation animation = AnimationUtils.loadAnimation(this,R.anim.activity_in);LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.2f);controller.setOrder(LayoutAnimationController.ORDER_REVERSE);ll.setLayoutAnimation(controller);","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"Android动画-补间动画,插值器","date":"2017-04-13T07:16:38.000Z","path":"2017/04/13/Android动画-补间动画,插值器/","text":"补间动画又叫View动画。Android中的补间动画分四种，渐变、缩放、平移，旋转。还有个set是他们的组合， 在XML文件中的标签对应是 &lt;alpha&gt;,&lt;scale&gt;,&lt;translate&gt;,&lt;rotate&gt; 对应的四个类是AlphaAnimation,ScaleAnimation,TranslateAnimation,RotateAnimation四个类。 这四个类都继承Animation类，Animation是个抽象类。Java类 | XML标签 | 效果—|—|—AlphaAnimation | &lt;alpha&gt; | 让透明度渐变，ScaleAnimation | &lt;scale&gt; | 放大或缩小TranslateAnimation | &lt;translate&gt; | 移动位置RotateAnimation | &lt;rotate&gt; | 绕某一点旋转 使用View动画是作用在View上的。使用有两种方式,以一个简单的旋转动画为例： 在res中新建anim文件夹，在这个文件夹里写上xml动画文件。如res/anim/anim_test.xml. 在java文件中用这个xml文件生成Animation类。 调用View的startAnimation来启动动画。 xml文件： 1234567&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:fromDegrees=\"0\" android:toDegrees=\"180\" android:duration=\"2000\" android:pivotX=\"50%\" android:pivotY=\"50%\" /&gt; java activity： 123456789btnRun = (Button) findViewById(R.id.btn_run);ivIc = (ImageView) findViewById(R.id.iv_ic);final Animation animation = AnimationUtils.loadAnimation(this,R.anim.anim_test);btnRun.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ivIc.startAnimation(animation); &#125;&#125;); 直接在Java文件中new一个Animation的子类，然后调用View的startAnimation来启动动画。 12345678final RotateAnimation animation = new RotateAnimation(0,180,50,50); animation.setDuration(2000); btnRun.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ivIc.startAnimation(animation); &#125; &#125;); 应该能发现这两个动画并不一样。因为在xml文件中`pivotX=&quot;50% pivotY=&quot;50%&quot;&quot;指的是在要动画的view的高宽的50%为动画中心，也就是View的正中心。这里是旋转，就是旋转中心了。 而在Java中设置的两个50，意思是从这个View的左上角向右偏移50像素，向下偏移50像素为动画中心。 一般推荐用XML来写View动画，有以下好处： xml文件以配置的形式，让动画看起来更直观，可读性强。 一个动画文件可以被多个View使用，重用性强。 便于更换动画。更换一个View的动画只要更换load的xml文件就行，不需要修改其他代码。 既然xml以配置的形式来定义动画，那么只要弄明白这些属性的意义就能灵活实现自己需要的动画了。 Animation的属性这四个子类独有的属性并不多，大部分都是继承自父类Animation的。所以先看看Animation的属性。 Animation的属性 含义 android:detachWallpaper 针对Window的动画属性。当一个window在桌面上动画时，是否让桌面壁纸跟着动画。默认是false android:duration 动画执行的时间 android:fillAfter 如果为true，那么动画执行完就会定格在执行完的那个画面,也就是动画的最后一帧，不会恢复到原位。比如上面的旋转转完就回去了。 android:fillBefore 只有当android:fillEnabled设为true时，这个值才有效。否则就假定这个值为true android:fillEnabled 是否考虑android:fillBefore的值。只要为true时，android:fillBefore的值才会被考虑。 不过这个属性跟上个属性我咋设置都没啥用，渣渣呀！谁能给个能出效果的例子。。。 android:interpolator 设置插值器，来控制动画在不同时间段的速度。默认是加速减速插值器。 android:repeatCount 动画重复的次数，所以总共会运行的动画次数是这个重复次数+1； android:repeatMode 动画重复的方式，有两个值，reverse 和 restart。reverse表示动画会正反轮流执行；restart android:startOffset 动画延迟执行的时间，单位是毫秒 android:zAdjustment 可以取三个值，normal:0，top:1，bottom:-1。代表可以在动画过程中调整z轴的顺序，也就是显示层次。0表示维持当前层次，1表示放在其他内容上面，-1表示放在其他内容下面。但是我渣还是没实现过这个属性，怎么搞都没用呀？ android:repeatMode reverse 12345678&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"2000\" android:fromDegrees=\"0\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:repeatCount=\"2\" android:repeatMode=\"reverse\" android:toDegrees=\"360\" /&gt; restart 12345678&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"2000\" android:fromDegrees=\"0\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:repeatCount=\"2\" android:repeatMode=\"restart\" android:toDegrees=\"360\" /&gt; AlphaAnimation的独有属性 AlphaAnimation的独有属性 含义 android:fromAlpha 动画开始时的透明度 从0.0-1.0 0.0表示完全透明，1.0表示完全不透明 android:toAlpha 动画结束时的透明度 5秒从全透变成完全不透 从0-1；1234567&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;5000&quot;&gt; &lt;alpha android:fromAlpha=&quot;0&quot; android:toAlpha=&quot;1&quot; /&gt;&lt;/set&gt; ScaleAnimation独有属性 ScaleAnimation独有属性 含义 android:pivotX float,缩放起点，或缩放原点的X轴坐标。缩放围绕这个点运行。 这个坐标默认是View的左上角，（0，0） android:pivotY float,同上 Y轴坐标. 在XML中的值有三种写法：数值：50；百分数：50%；百分数p:50%p。如果是数值，表示以View的左上角为(0,0)，然后加上写的数值，以这个点作为缩放中心。如果为百分数，如50%，表示总左上角(0,0)加上自身高度的50%，作为缩放点。如果是百分数p，如50%p,表示总左上角(0,0)加上父控件高度的50%，作为缩放点。 android:fromXScale float 动画开始时，X轴上缩放的比例。1表示本身大小。 android:fromYScale float 动画开始时，Y轴上缩放的比例。1表示本身大小。 android:toXScale float Y动画结束时，X轴上缩放的比例。1表示本身大小。 android:toYScale float Y动画结束时，Y轴上缩放的比例。1表示本身大小。 从图片的右下角开始缩放，宽高各从从原来的2倍缩放到原来的十分之一： 1234567891011&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\"&gt; &lt;scale android:pivotX=\"100%\" android:pivotY=\"100%\" android:fromXScale=\"2\" android:fromYScale=\"2\" android:toXScale=\"0.1\" android:toYScale=\"0.1\" /&gt;&lt;/set&gt; TranslateAnimation独有属性 TranslateAnimation独有属性 含义 android:fromXDelta 动画开始时View左上角的X坐标，也有三种写法，同pivotX android:fromYDelta 动画开始时View左上角的Y坐标，也有三种写法，同pivotX android:toXDelta 动画结束时View左上角的X坐标，也有三种写法，同pivotX android:toYDelta 动画结束时View左上角的Y坐标，也有三种写法，同pivotXY 从自身的左上角移到自身的右下角： 123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\"&gt; &lt;translate android:fromXDelta=\"-100%\" android:fromYDelta=\"-100%\" android:toXDelta=\"100%\" android:toYDelta=\"100%\" /&gt;&lt;/set&gt; RotateAnimation独有属性 RotateAnimation独有属性 含义 android:pivotX 旋转动画的中心的X坐标，旋转围绕这个点进行，也有三种写法，同pivotX android:pivotY 旋转动画的中心的Y坐标，旋转围绕这个点进行，也有三种写法，同pivotX android:fromDegrees 动画开始时的旋转角度。角度顺时针转增加，逆时针转减少。所以根据开始角度和结束角度来判断是顺时针还是逆时针。360度为一圈。 android:toDegrees 动画结束时的旋转角度。 从360度转到-90度： 123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\"&gt; &lt;rotate android:pivotX=\"50%\" android:pivotY=\"50%\" android:fromDegrees=\"360\" android:toDegrees=\"-90\" /&gt;&lt;/set&gt; AnimationSetAnimationSet代表动画的集合，在XML文件中的标签是&lt;set&gt;，前面已经出现过了。 影这个标签可以把不同的动画组合起来作用在同一个View上。 使用AndroidStudio时发现只有在&lt;set&gt;标签里面，才能自动提示出来Animation的属性，在&lt;alpha&gt;等标签里只提示他自己独有的那几个属性，不知道有没有解决办法。 例如要同时缩放旋转，并改变透明度： 123456789101112&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\"&gt; &lt;rotate android:pivotX=\"50%\" android:pivotY=\"50%\" android:fromDegrees=\"360\" android:toDegrees=\"-90\" /&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0.2\"/&gt;&lt;/set&gt; 还能用同一种动画拼成一个连续动画，只是这样做好像有点low： 12345678910111213141516171819202122232425262728293031323334&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;-100%&quot; android:toXDelta=&quot;-100%&quot; android:duration=&quot;2000&quot; /&gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;200%&quot; android:duration=&quot;2000&quot; android:startOffset=&quot;2000&quot;/&gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;200%&quot; android:duration=&quot;2000&quot; android:startOffset=&quot;4000&quot;/&gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;-200%&quot; android:duration=&quot;2000&quot; android:startOffset=&quot;6000&quot;/&gt; &lt;translate android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100%&quot; android:toYDelta=&quot;-100%&quot; android:duration=&quot;2000&quot; android:startOffset=&quot;8000&quot;/&gt;&lt;/set&gt; android:shareInterpolatorAnimationSet也有个属性android:shareInterpolator.值为true或flase。表示集合中的动画是佛共享同一个插值器。 插值器InterpolatorInterpolator继承自TimeInterpolator，用来定义动画在不同的时间有不同的速度。也叫插补器。 插值器可以通过在xml文件中用android:interpolator设置，也可以在java中通过animation.setInterpolator()来设置. 在java中设置可以传一些参数，对插值器进行更详细的设置，比较灵活。 插值器 XML中的值 作用 AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator 加速减速插值器 动画先加速再减速 AccelerateInterpolator @android:anim/accelerate_interpolator 加速插值器 动画速度越来越快 DecelerateInterpolator @android:anim/decelerate_interpolator 减速插值器 动画速度越来越慢 BounceInterpolator @android:anim/bounce_interpolator 回弹插值器 动画结束会回弹几下 CycleInterpolator @android:anim/cycle_interpolator 圆插值器，动画会重复几次，动画的速度沿着正弦曲线变化 LinearInterpolator @android:anim/linear_interpolator 线性插值器 动画速度保持匀速 AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator 预期预期超调插值器。先往前甩一定的值，然后开始动画，结束时往后甩一定的值，结束动画。 AnticipateInterpolator @android:anim/anticipate_interpolator 预期插值器，动画开始时会往前甩一下 OvershootInterpolator @android:anim/overshoot_interpolator 超调插值器 动画结束时往后甩一下 下面以让一个图片顺时针旋转360度为例，其他动画都类似的作用： AccelerateDecelerateInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; AccelerateInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/accelerate_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; DecelerateInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/decelerate_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; BounceInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/bounce_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; CycleInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/cycle_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; LinearInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/linear_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; AnticipateOvershootInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/anticipate_overshoot_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; AnticipateInterpolator123456789&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;3000&quot; android:interpolator=&quot;@android:anim/anticipate_interpolator&quot;&gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;360&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot;/&gt;&lt;/set&gt; OvershootInterpolator123456789&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"3000\" android:interpolator=\"@android:anim/overshoot_interpolator\"&gt; &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\"/&gt;&lt;/set&gt; 对View动画的监听Animation里有一个AnimationListener类提供了对动画开始，重复，和结束的监听。 12345678910111213141516animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; Log.i(TAG, \"动画开始时做操作: \"); &#125; @Override public void onAnimationEnd(Animation animation) &#123; Log.i(TAG, \"动画重复时做操作: \"); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; Log.i(TAG, \"动画结束时做操作: \"); &#125; &#125;);","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"Android点击缩略图查看大图的缩放动画","date":"2017-04-13T03:39:11.000Z","path":"2017/04/13/Android点击缩略图查看大图的缩放动画/","text":"来自官方培训课程https://developer.android.com/training/animation/zoom.html#animate 其实点击小图显示大图非常简单的一种实现方式就是，在布局中加一个全屏的ImageView，然后隐藏。点击小图就把图片设置给大图，然后大图显示。 这个文章里也是这么做的，不过这边课程的重心在于讲从缩略图到大图的动画过程。动画的目的是让过程看起来像是从小的缩略图的边界开始放大到最终的大图的。 布局在布局文件里设置两张小的ImageView，和一个全屏的ImageView。还要注意根布局。 123456789101112131415161718192021222324252627282930313233343536RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"10dp\" tools:context=\"com.sunlinlin.zoomingview.MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/imageView1\" android:layout_width=\"159dp\" android:layout_height=\"116dp\" app:srcCompat=\"@drawable/xiaomao\" /&gt; &lt;ImageView android:id=\"@+id/imageView2\" android:layout_width=\"159dp\" android:layout_height=\"116dp\" app:srcCompat=\"@mipmap/ic_launcher\"/&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=\"@+id/expanded_image\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00000000\" android:scaleType=\"centerCrop\" android:visibility=\"invisible\" /&gt;&lt;/RelativeLayout&gt; Activity然后在Activit中进行一些简单的设置，两张小图的点击事件是通过动画显示大图。 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity &#123; // 持有这个动画的引用，让他可以在动画执行中途取消 private Animator mCurrentAnimator; private int mShortAnimationDuration; private View imageView1; private View imageView2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); imageView1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; zoomImageFromThumb(imageView1,R.drawable.xiaomao); &#125; &#125;); imageView2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; zoomImageFromThumb(imageView2,R.mipmap.ic_launcher); &#125; &#125;); // 系统默认的短动画执行时间 200 mShortAnimationDuration = getResources().getInteger( android.R.integer.config_shortAnimTime); &#125; private void initView() &#123; imageView1 = (ImageView) findViewById(R.id.imageView1); imageView2 = (ImageView) findViewById(R.id.imageView2); &#125;&#125; 缩放动画都在注释里. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113private void zoomImageFromThumb(final View thumbView, int imageResId) &#123; // 如果有动画正在运行，取消这个动画 if (mCurrentAnimator != null) &#123; mCurrentAnimator.cancel(); &#125; // 加载显示大图的ImageView final ImageView expandedImageView = (ImageView) findViewById( R.id.expanded_image); expandedImageView.setImageResource(imageResId); // 计算初始小图的边界位置和最终大图的边界位置。 final Rect startBounds = new Rect(); final Rect finalBounds = new Rect(); final Point globalOffset = new Point(); // 小图的边界就是小ImageView的边界，大图的边界因为是铺满全屏的，所以就是整个布局的边界。 // 然后根据偏移量得到正确的坐标。 thumbView.getGlobalVisibleRect(startBounds); findViewById(R.id.container).getGlobalVisibleRect(finalBounds, globalOffset); startBounds.offset(-globalOffset.x, -globalOffset.y); finalBounds.offset(-globalOffset.x, -globalOffset.y); // 计算初始的缩放比例。最终的缩放比例为1。并调整缩放方向，使看着协调。 float startScale=0; if ((float) finalBounds.width() / finalBounds.height() &gt; (float) startBounds.width() / startBounds.height()) &#123; // 横向缩放 float startWidth = startScale * finalBounds.width(); float deltaWidth = (startWidth - startBounds.width()) / 2; startBounds.left -= deltaWidth; startBounds.right += deltaWidth; &#125; else &#123; // 竖向缩放 float startHeight = startScale * finalBounds.height(); float deltaHeight = (startHeight - startBounds.height()) / 2; startBounds.top -= deltaHeight; startBounds.bottom += deltaHeight; &#125; // 隐藏小图，并显示大图 thumbView.setAlpha(0f); expandedImageView.setVisibility(View.VISIBLE); // 将大图的缩放中心点移到左上角。默认是从中心缩放 expandedImageView.setPivotX(0f); expandedImageView.setPivotY(0f); //对大图进行缩放动画 AnimatorSet set = new AnimatorSet(); set.play(ObjectAnimator.ofFloat(expandedImageView, View.X, startBounds.left, finalBounds.left)) .with(ObjectAnimator.ofFloat(expandedImageView, View.Y, startBounds.top, finalBounds.top)) .with(ObjectAnimator.ofFloat(expandedImageView, View.SCALE_X, startScale, 1f)) .with(ObjectAnimator.ofFloat(expandedImageView, View.SCALE_Y, startScale, 1f)); set.setDuration(mShortAnimationDuration); set.setInterpolator(new DecelerateInterpolator()); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; mCurrentAnimator = null; &#125; @Override public void onAnimationCancel(Animator animation) &#123; mCurrentAnimator = null; &#125; &#125;); set.start(); mCurrentAnimator = set; // 点击大图时，反向缩放大图，然后隐藏大图，显示小图。 final float startScaleFinal = startScale; expandedImageView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mCurrentAnimator != null) &#123; mCurrentAnimator.cancel(); &#125; AnimatorSet set = new AnimatorSet(); set.play(ObjectAnimator .ofFloat(expandedImageView, View.X, startBounds.left)) .with(ObjectAnimator .ofFloat(expandedImageView, View.Y,startBounds.top)) .with(ObjectAnimator .ofFloat(expandedImageView, View.SCALE_X, startScaleFinal)) .with(ObjectAnimator .ofFloat(expandedImageView, View.SCALE_Y, startScaleFinal)); set.setDuration(mShortAnimationDuration); set.setInterpolator(new DecelerateInterpolator()); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; thumbView.setAlpha(1f); expandedImageView.setVisibility(View.GONE); mCurrentAnimator = null; &#125; @Override public void onAnimationCancel(Animator animation) &#123; thumbView.setAlpha(1f); expandedImageView.setVisibility(View.GONE); mCurrentAnimator = null; &#125; &#125;); set.start(); mCurrentAnimator = set; &#125; &#125;); &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"动画","slug":"动画","permalink":"http://blog.miaolegewu.top/tags/动画/"}]},{"title":"用过的Intent的用法","date":"2017-04-12T07:09:33.000Z","path":"2017/04/12/搜罗到的Intent的各种用法/","text":"突然看到之前的一篇笔记，就补充一下发上来。Intent是什么就先不说了。列表可以看一下目录。 所有用法均在小米max手机上亲测，android6.0。有些权限在6.0上要动态获取。 以后如果用到新功能了再补充，没用过的先不写了。 打电话使用ACTION_CALL需要android.permission.CALL_PHONE权限 123456Intent intent=new Intent();intent.setAction(Intent.ACTION_VIEW);//intent.setAction(Intent.ACTION_CALL);//intent.setAction(Intent.ACTION_DIAL);intent.setData(Uri.parse(\"tel:12212212212\"));startActivity(intent); 发短信 1 12345Intent intent= new Intent();intent.setData(Uri.parse(&quot;smsto:10086&quot;));intent.setAction(Intent.ACTION_SENDTO);intent.putExtra(&quot;sms_body&quot;, &quot;填信息内容&quot;);startActivity(intent); 2 12345Intent intent= new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setType(&quot;vnd.android-dir/mms-sms&quot;); intent.putExtra(&quot;sms_body&quot;, &quot;填信息内容&quot;); startActivity(intent); 发邮件 弹出选择器 123456789101112Intent intent=new Intent(); intent.setAction(Intent.ACTION_SEND); //收件人 String[] tos=&#123;&quot;wangyisll@163.com&quot;&#125;; //抄送人 String[] ccs=&#123;&quot;1212121@qq.com&quot;&#125;; intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_CC, ccs); intent.putExtra(Intent.EXTRA_TEXT, &quot;邮件内容 2333&quot;); intent.putExtra(Intent.EXTRA_SUBJECT, &quot;邮件主题&quot;); intent.setType(&quot;message/rfc822&quot;); startActivity(Intent.createChooser(intent, &quot;选择客户端发送&quot;)); 直接启动邮件客户端 12345678910111213Intent intent=new Intent(); intent.setData(Uri.parse(&quot;mailto:&quot;)); intent.setAction(Intent.ACTION_SENDTO); //收件人 String[] tos=&#123;&quot;wangyisll@163.com&quot;&#125;; //抄送人 String[] ccs=&#123;&quot;1212121@qq.com&quot;&#125;; intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_CC, ccs); intent.putExtra(Intent.EXTRA_TEXT, &quot;邮件内容 2333&quot;); intent.putExtra(Intent.EXTRA_SUBJECT, &quot;邮件主题&quot;); //intent.setType(&quot;message/rfc822&quot;); startActivity(intent); 启动相机 单纯启动相机 12Intent intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);startActivity(intent); 以录像模式启动相机 12Intent intent = new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA);startActivity(intent); 获取拍照返回的缩略图 需要android.permission.CAMERA权限 12Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);startActivityForResult(intent,0); 然后在 12345@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); Bitmap bitmap = data.getParcelableExtra(&quot;data&quot;); &#125; 回到桌面，HOME1234Intent intent = new Intent(); intent.setAction(&quot;android.intent.action.MAIN&quot;); intent.addCategory(&quot;android.intent.category.HOME&quot;); startActivity(intent); 从联系人选择电话号码123Intent intent = new Intent(Intent.ACTION_PICK); intent.setType(ContactsContract.CommonDataKinds.Phone.CONTENT_TYPE); startActivityForResult(intent,0); 然后再12345678910@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); Uri uri = data.getData(); String[] names = new String[]&#123;ContactsContract.CommonDataKinds.Phone.NUMBER&#125;; Cursor cursor = getContentResolver().query(uri, names,null, null, null); int index = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER); String number = cursor.getString(index); Log.i(TAG, &quot;onActivityResult: &quot;+number); &#125; 插入新的联系人,跳到新建联系人页面并自动填好信息。123456Intent intent = new Intent(Intent.ACTION_INSERT);intent.setType(ContactsContract.Contacts.CONTENT_TYPE);intent.putExtra(ContactsContract.Intents.Insert.NAME, &quot;aaa&quot;);intent.putExtra(ContactsContract.Intents.Insert.EMAIL, &quot;wandjnfdjkn&quot;);intent.putExtra(ContactsContract.Intents.Insert.PHONE, &quot;100200100&quot;);startActivity(intent); 安装apk文件1234String fileName = Environment.getExternalStorageDirectory() + &quot;/a.apk&quot; ;Intent intent = new Intent(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(new File(fileName)), &quot;application/vnd.android.package-archive&quot;);startActivity(intent); 启动QQ，并打开指定的聊天窗口12String url = &quot;mqqwpa://im/chat?chat_type=wpa&amp;uin=1492571688&quot;;startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url))); 打开手机上的地图软件，如百度地图。传入的坐标如果在范围内会直接点位到所传的坐标123Uri uri = Uri.parse(&quot;geo:40.2268400000,88.1141060000&quot;); Intent intent = new Intent(Intent.ACTION_VIEW,uri); startActivity(intent); 打开系统各各个设置页面如WiFi12Intent intent = new Intent(Settings.ACTION_WIFI_SETTINGS);startActivity(intent); 其他如1234567891011121314ACTION_SETTINGSACTION_WIRELESS_SETTINGSACTION_AIRPLANE_MODE_SETTINGSACTION_WIFI_SETTINGSACTION_APN_SETTINGSACTION_BLUETOOTH_SETTINGSACTION_DATE_SETTINGSACTION_LOCALE_SETTINGSACTION_INPUT_METHOD_SETTINGSACTION_DISPLAY_SETTINGSACTION_SECURITY_SETTINGSACTION_LOCATION_SOURCE_SETTINGSACTION_INTERNAL_STORAGE_SETTINGSACTION_MEMORY_CARD_SETTINGS 用浏览器打开网页123Uri webpage = Uri.parse(&quot;http://www.baidu.com&quot;);Intent intent = new Intent(Intent.ACTION_VIEW, webpage);startActivity(intent); 打开录音机12Intent intent = new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION);startActivity(intent);","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"Android设计模式-总结+索引","date":"2017-04-11T03:00:04.000Z","path":"2017/04/11/Android设计模式-总结-索引/","text":"通过《Android源码设计模式解析与实战》，对23种设计模式总算有了个初步的了解。书中对设计模式的介绍并不深奥，也没有很深究这些设计模式，但是对于之前没看过设计模式的我来说，让我对每一种设计模式都有了一种概念。 设计模式这种东西，我觉得有个概念，然后在开发中可能就会在遇到某些情况时想到一些设计模式。至于深入研究设计模式，应该是要有一定的使用基础的。 笔记中只对设计模式的基本概念和结构进行了一下了解，有时也会结合源码看一下，其实看完后面的前面的就忘得差不多了。实践才能记忆吧。做个分类好找吧： 创建型模式 5个 工厂方法模式 抽象工厂模式 单例模式,Singleton Builder模式，建造者模式 原型模式 行为型模式 11个 策略模式 模板方法模式 观察者模式 迭代器模式，游标模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式，调解者模式，调停者模式 解释器模式 结构型模式 7个 适配器模式 装饰模式，包装模式 代理模式，委托模式 外观模式，门面模式 桥接模式，桥梁模式 组合模式，部分整体模式 享元模式","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（二十三）-桥接模式","date":"2017-04-11T00:37:38.000Z","path":"2017/04/11/Android设计模式（二十三）-桥接模式/","text":"桥接模式也叫桥梁模式，和生活中一样，桥梁就是用来连接河道两岸的主要建筑。桥接模式也是起着连接两边的作用，连接的两边就是抽象部分和实现部分，这就需要在程序设计的时候划分好抽象部分和实现部分了。 定义将抽象部分与实现部分分离，使他们都可以独立地进行变化。 使用场景 一个类存在两个独立维度的变化，且两个维度都需要进行拓展。 一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免两个层次之间建立静态的继承联系，可以用桥接模式使他们在抽象层建立一个关联关系。 不想使用继承或使用继承会导致生成一大堆类的时候。 UML Abstraction: 抽象部分，抽象部分保持对实现部分的引用，抽象部分的方法要调用实现部分的对象来实现。一般为抽象类。 RefinedAbstraction: 优化的抽象部分，一般是对抽象部分的方法进行完善和拓展，是抽象部分的具体实现 Implementor：实现部分，可以是接口和抽象类，方法不一定要和抽象部分保持一致。一般情况下由实现部分提供基本的操作，而抽象部分定义基于这些操作的业务方法。 ConcreteImplementorA,B: 具体的实现部分。 模板代码： 实现部分的接口：123public interface Implementor&#123; void operationImpl();&#125; 具体的实现部分：1234567891011121314public class ConcreteImplementorA implements Implementor&#123; @Override public void operationImpl() &#123; //具体的实现 &#125;&#125;public class ConcreteImplementor implements Implementor&#123; @Override public void operationImpl() &#123; //具体的实现 &#125;&#125; 抽象部分：1234567891011public abstract class Abstraction&#123; private Implementor mImplementor; public Abstraction(Implementor mImplementor) &#123; this.mImplementor = mImplementor; &#125; public void operation()&#123; //调用实现部分的具体方法 mImplementor.operationImpl(); &#125;&#125; 优化的抽象部分：123456789101112public class RefinedAbstraction extends Abstraction&#123; public RefinedAbstraction(Implementor mImplementor) &#123; super(mImplementor); &#125; //可以增加拓展其他方法，也可以重写父类的方法，也能调用父类的方法 @Override public void refinedperation() &#123; //对抽象的父类的方法进行拓展 &#125;&#125; 简单实现拿书中举得例子。这里用桥接模式来建立两个维度之间的联系。对咖啡来说，可以分为两个维度，杯子大小是一个维度，加不加糖又是一个维度。这两个没有谁是抽象部分谁是具体部分。就拿杯子大小作为抽象部分来做一个简单实现： 抽象的糖，相当于实现部分的接口：123public abstract class CoffeeSugar &#123; public abstract void makeSugar();&#125; 两种实现部分的实现，加不加糖：123456789101112public class AddSugar extends CoffeeSugar &#123; @Override public void makeSugar() &#123; System.out.println(&quot;加糖的&quot;); &#125;&#125;public class NoSugar extends CoffeeSugar &#123; @Override public void makeSugar() &#123; System.out.println(&quot;不加糖的&quot;); &#125;&#125; 杯子的抽象，相当于抽象部分,持有一个糖的引用：1234567891011public abstract class CoffeeCup &#123; protected CoffeeSugar coffeeSugar; public CoffeeCup(CoffeeSugar coffeeSugar) &#123; this.coffeeSugar = coffeeSugar; &#125; public void makeCup()&#123; coffeeSugar.makeSugar(); &#125;&#125; 优化的抽象部分，有大小两种杯子：12345678910111213141516171819202122public class LargeCup extends CoffeeCup &#123; public LargeCup(CoffeeSugar coffeeSugar) &#123; super(coffeeSugar); &#125; @Override public void makeCup() &#123; System.out.println(&quot;大杯的&quot;); super.makeCup(); &#125;&#125;public class SmallCup extends CoffeeCup &#123; public SmallCup(CoffeeSugar coffeeSugar) &#123; super(coffeeSugar); &#125; @Override public void makeCup() &#123; System.out.println(&quot;小杯的&quot;); super.makeCup(); &#125;&#125; 客户端调用：1234567891011121314public class Client &#123; public static void main(String[] args) &#123; CoffeeSugar addSugar = new AddSugar(); CoffeeSugar noSugar = new NoSugar(); CoffeeCup coffee = new LargeCup(addSugar); coffee.makeCup(); System.out.println(&quot;---&quot;); coffee = new LargeCup(noSugar); coffee.makeCup(); System.out.println(&quot;---&quot;); coffee = new SmallCup(noSugar); coffee.makeCup(); &#125;&#125; 输出： 这样就把两个维度连接到一起了。而且两个维度是可以独立拓展的。比如如果想加上个中杯，或者来个多糖少糖等分类，只需要多实现几个类就行了，然后由客户端去调用。这样就能在两个维度上独立的拓展。 再想加上第三个维度也是很简单的，现在要加上年龄分类，有老年人喝的喝年轻人喝的，者又是一个维度。 这时可以把前面两个已经连接在一起的看做是一个维度，让新的去桥接者个已有的。 抽象的people，持有一个之前的桥接，把people和CoffeeCup连接起来：123456789ublic abstract class People &#123; protected CoffeeCup coffeeCup; public People(CoffeeCup coffeeCup) &#123; this.coffeeCup = coffeeCup; &#125; public abstract void age();&#125; 具体的年龄分类：12345678910111213141516171819202122public class YoungPeople extends People &#123; public YoungPeople(CoffeeCup coffeeCup) &#123; super(coffeeCup); &#125; @Override public void age() &#123; System.out.println(&quot;年轻人喝的&quot;); coffeeCup.makeCup(); &#125;&#125;public class OldPeople extends People &#123; public OldPeople(CoffeeCup coffeeCup) &#123; super(coffeeCup); &#125; @Override public void age() &#123; System.out.println(&quot;老年人喝的&quot;); coffeeCup.makeCup(); &#125;&#125; 然后客户端只需要这样123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; CoffeeSugar addSugar = new AddSugar(); CoffeeSugar noSugar = new NoSugar(); CoffeeCup coffee = new LargeCup(addSugar); coffee.makeCup(); System.out.println(&quot;---&quot;); coffee = new LargeCup(noSugar); coffee.makeCup(); System.out.println(&quot;---&quot;); coffee = new SmallCup(noSugar); coffee.makeCup(); System.out.println(&quot;-----&quot;); //再次桥接 People people = new OldPeople(coffee); people.age(); &#125;&#125; 输出： 总结桥接模式就是把系统分为抽象部分和实现部分，而建立桥接的方式也很简单。就是让抽象部分持有实现部分的引用，可以通过这个引用调用实现部分的具体方法。 使用这个系统最重要的是把握系统的分离，分不好就失去了灵活的拓展性，因此不容易设计。 优点 分离成抽象部分和实现部分，并且两部分都可以独立的拓展，一个部分变化不会引起另一部分的变化，提高了系统的拓展性。 复用性强，避免了使用继承产生大量继承类的问题。 缺点 将系统分离为抽象部分和实现部分，会增加系统的复杂度和设计难度。如果系统不能分离出两个独立的维度的话，就不适合使用这个模式。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（二十二）-外观模式","date":"2017-04-10T09:34:48.000Z","path":"2017/04/10/Android设计模式（二十二）-外观模式/","text":"外观模式猛一听有点蒙逼，但是在开发中我们应该都用过，只是没这个概念罢了。 比如在开发时通常会把图片加载框架和网络框架进行封装，封装到最后只暴露出来一个最上级的类供外部调用，外部调用这一个类提供的方法，然后这个类内部具体调用了什么，用的什么逻辑等等外部都不用管。这样也方便后期随便更换图片加载框架和网络框架，而业务代码不用做任何改动。 这其实就是外观模式的一种实现。 定义要求子系统的外部与其内部的通讯必须通过一个统一的对象进行。提供一个高层次接口，使得子系统更易于使用， 使用场景 为一个复杂的子系统 提供一个简单的接口。子系统可能因为不断演化而变得越来越复杂，甚至可能被替换，就像上面提到的封装的框架。这种模式能让子系统有更高的独立性，对外隔离了子系统的变化。 当需要构建一个层次结构的子系统是，可以用这个模式定义每一层的接口，使各个层次之间的耦合度降低。 UML Facade: 系统对外的统一接口，系统内部系统地工作。 SubSystemA,B,C,D: 子系统。 比如客户端要用子系统A和B一起来完成一个操作，又要用B和C和D完成一个操作，那么就需要同事依赖着四个类。子系统有了一个门面之后，客户端就可以只依赖这个门面，调用他的方法。这个门面内部会调度各个子系统来完成协调工作。 简单实现这里以一个手机为例。然后再更精简一点。手机可以看成是一个系统的facade，他继承了电话，上网，摄像头功能。当我们需要视频通话时，只需要调用手机的视频通话功能就行，通话结束后直接调用挂机就行。因为手机已经集成了这些功能，手机内部会调用各个系统来完成这个操作。 想象一下如果没有手机的封装，我们视频通话的操作可能就是：打开摄像头–上网–通话。然后挂断就要手动断掉通话，然后手动关掉摄像头。 先看电话功能模块：12345678910111213141516public interface Phone &#123; void dail(); void hangup();&#125;public class PhoneImpl implements Phone &#123; @Override public void dail() &#123; System.out.println(&quot;打电话&quot;); &#125; @Override public void hangup() &#123; System.out.println(&quot;挂断&quot;); &#125;&#125; 摄像头模块：12345678910111213141516171819202122public interface Camera &#123; void open(); void takePicture(); void close();&#125;public class CameraImpl implements Camera &#123; @Override public void open() &#123; System.out.println(&quot;打开相机&quot;); &#125; @Override public void takePicture() &#123; System.out.println(&quot;开始视频&quot;); &#125; @Override public void close() &#123; System.out.println(&quot;关闭相机&quot;); &#125;&#125; 然后封装一个门面：123456789101112public class MobilePhone &#123; private Phone phone = new PhoneImpl(); private Camera camera = new CameraImpl(); public void videoChat()&#123; camera.open(); phone.dail(); &#125; public void hangup()&#123; phone.hangup(); camera.close(); &#125;&#125; 客户端直接调动统一的接口就行了：12345678public class Client &#123; public static void main(String[] args) &#123; MobilePhone mobilePhone = new MobilePhone(); mobilePhone.videoChat(); System.out.println(&quot;----&quot;); mobilePhone.hangup(); &#125;&#125; 输出： 总结外观模式的精髓就在于封装。通过封装出一个高层的统一调动接口，为系统提供统一的API，让用户通过一个API就能控制整个系统，减少 用户的使用成本，也提高了系统的灵活性。 优点 对客户屏蔽了子系统减少了客户端要调用的系统个数，减少了客户对子系统的耦合。 客户也可以直接使用子系统，是系统更加灵活。 修改子系统不用修改客户端的调用。但是外观类可能要进行对应的修改。 缺点 所有子系统的功能都通过一个接口来提供，这个接口可能会变得很复杂。 修改子系统可能要修改外观类，不太符合开闭原则。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（二十一）-享元模式","date":"2017-04-10T03:38:42.000Z","path":"2017/04/10/Android设计模式（二十一）-享元模式/","text":"享元模式是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。享元模式也是为了减少内存的使用，避免出现大量重复的创建销毁对象的场景。 享元模式用在一批相同或相似的对象上，这些对象有可以共享的内部状态和各自不同的外部状态。 享元模式中会有一个工厂，工厂维护着一个容器，容器以键值对的方式存储，键是对象的内部状态，也就是共享的部分，值就是对象本身。 客户端从这个工厂获取对象，如果容器中存在这个对象就直接返回，不存在再创建新的对象并存入容器，避免了大量重复创建对象。 定义使用共享对象有效的支持大量的细粒度对象的复用。 使用场景 系统存在大量相似或相同的对象。 这些对象有较接近的外部状态。 需要缓冲池时。 UML Flyweight:享元对象抽象类或接口。 ConcreteFlyweight：具体的享元对象 FlyweightFactory：享元工厂，管理对象池和创建享元对象。 简单实现以查询火车票价为例。假如每张车票信息都是一个对象，当有很多人在查询一个车票信息时，系统就会重复创建这个车票信息返回给每个人，这样会不停的创建和销毁对象，引发频繁的GC，影响效率。 车票是有限的，结构是一样的，内容是相似的，这里简化一下，假设车票上只有始发地，到达地，座位类型，票价四个内容。所以，如果缓存下来车票的话，就不管有多少人查询，都不会频繁的创建销毁对象了。 把始发地和到达地看做是内部可以共享的状态，当做缓存的键，整个车票对象为值。 抽象的车票，提供一个方法展示车票信息，传入信息是要查询的座位类型： 123public interface Ticket &#123; void showInfo(String type);&#125; 具体的车票，这里每次查询的事随机生成票价： 12345678910111213141516171819public class ConcreteTicket implements Ticket &#123; private String from; private String to; private int price; private String type; public ConcreteTicket(String from, String to) &#123; this.from = from; this.to = to; &#125; @Override public void showInfo(String type) &#123; price = new Random().nextInt(500); this.type=type; System.out.println(&quot;从&quot;+from+&quot;到&quot;+to+&quot;的&quot;+this.type+&quot;票价是&quot;+price); &#125;&#125; 车票工厂：12345678910111213141516public class TicketFactory &#123; private static Map&lt;String,Ticket&gt; tickets = new HashMap&lt;&gt;(); public static Ticket getTicket(String from,String to)&#123; String key = from+to; if (tickets.containsKey(key))&#123; System.out.println(&quot;从缓存中获取&quot;); return tickets.get(key); &#125;else &#123; System.out.println(&quot;新建对象&quot;); Ticket ticket = new ConcreteTicket(from,to); tickets.put(key,ticket); return ticket; &#125; &#125;&#125; 客户端调用：1234567public class Client &#123; public static void main(String[] args) &#123; TicketFactory.getTicket(&quot;A&quot;,&quot;B&quot;).showInfo(&quot;硬座&quot;); TicketFactory.getTicket(&quot;A&quot;,&quot;B&quot;).showInfo(&quot;硬卧&quot;); TicketFactory.getTicket(&quot;C&quot;,&quot;B&quot;).showInfo(&quot;硬卧&quot;); &#125;&#125; 输出： 总结享元模式的核心就在享元工厂，因为享元对象有可共享的内部状态部分和不可共享的外部状态部分，因此，内部可共享的就交给工厂去维护处理了，而外部可变的就可以交给客户端去实现。 优点 大大减少系统创建的对象，降低内存总对象的数量，降低程序占用的内存，增强系统的性能。 缺点 将对象分为内部状态和外部状态两部分，导致系统变复杂，逻辑也更复杂。 将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（二十）-装饰模式","date":"2017-04-09T12:31:55.000Z","path":"2017/04/09/Android设计模式（二十）-装饰模式/","text":"装饰模式也叫做包装模式，是结构型设计模式之一。目的是为了给一个类或对象增加行为。可以是继承的一种替代。 装饰模式也很好理解，比如一个人，给他装上火箭就能上天了，装上潜水服就能下海了，但本身还是个人，人没有任何变化。 定义动态地给一个对象添加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。 使用场景 需要拓展一个类的功能，增加附加职责时。 需要动态增加功能，并动态删除功能时。 当不能使用继承，但要提供继承的功能时。 UML Component:抽象组件，可以是一个接口或抽象类，是被装饰的原始对象 ConcreteComponent：组件的具体实现类。是被装饰的具体对象。 Decorator：抽象的装饰者。职责是装饰被装饰的对象。内部一定有一个对被装饰者的引用。一般情况下也是一个抽象类，根据具体逻辑实现不同的子类。如果逻辑简单可以直接是实现类。 ConcreteDecoratorA，B：具体的装饰者。 先抽象组件类：123public abstract class Component &#123; public abstract void operate();&#125; 组件的一个具体实现类，也就是被装饰者者：123456public class ConcreteComponent extends Component &#123; @Override public void operate() &#123; System.out.println(\"被装饰者的操作\"); &#125;&#125; 抽象的装饰者，持有一个被装饰者的引用： 123456789101112public abstract class Decorator extends Component &#123; private Component component; public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operate() &#123; component.operate(); &#125;&#125; 具体的两个装饰者，拓展功能：12345678910111213141516171819public class ConcreteDecoratorA extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operate() &#123; operateA(); super.operate(); operateB(); &#125; private void operateA()&#123; System.out.println(&quot;装饰者A在被装饰者的操作之前加些操作&quot;); &#125; private void operateB()&#123; System.out.println(&quot;装饰者A在被装饰者的操作之前后加些操作&quot;); &#125;&#125; 123456789101112131415161718public class ConcreteDecoratorB extends Decorator &#123; public ConcreteDecoratorB(Component component) &#123; super(component); &#125; @Override public void operate() &#123; operateA(); super.operate(); operateB(); &#125; private void operateA()&#123; System.out.println(&quot;装饰者B在被装饰者的操作之前加些操作&quot;); &#125; private void operateB()&#123; System.out.println(&quot;装饰者B在被装饰者的操作之前后加些操作&quot;); &#125;&#125; 客户端调用：12345678910public class Client &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component); ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(component); concreteDecoratorA.operate(); concreteDecoratorB.operate(); &#125;&#125; 输出： 装饰类并没有在原来的类上做审核改动，只是拓展了一些操作。通过不同的包装类就能拓展不同的功能。而传入不同的被包装类，也能拓展不同的具体对象。 简单实现拿一开始说的那个人为例子。人是个抽象的概念。男孩是个具体的人。但是这个人要干不同的事情要穿不一样的衣服，就需要进行不同的包装。 抽象的人:123public abstract class Person &#123; public abstract void dress();&#125; 具体的人,也是原始的人，被装饰者：123456public class Boy extends Person &#123; @Override public void dress() &#123; System.out.println(&quot;穿内衣内裤&quot;); &#125;&#125; 抽象的装饰者：1234567891011public abstract class PersonDecorator &#123; Person person; public PersonDecorator(Person person) &#123; this.person = person; &#125; public void dress()&#123; person.dress(); &#125;&#125; 工作人装饰者：123456789101112131415public class WorkPersonDecorator extends PersonDecorator &#123; public WorkPersonDecorator(Person person) &#123; super(person); &#125; @Override public void dress() &#123; super.dress(); dressWork(); &#125; private void dressWork()&#123; System.out.println(&quot;穿西装领带&quot;); &#125;&#125; 运动的人装饰者：1234567891011121314public class SportPersonDecorator extends PersonDecorator &#123; public SportPersonDecorator(Person person) &#123; super(person); &#125; @Override public void dress() &#123; super.dress(); dressSport(); &#125; private void dressSport()&#123; System.out.println(&quot;穿运动衣&quot;); &#125;&#125; 客户端调用：1234567891011public class Client &#123; public static void main(String[] args) &#123; Person boy = new Boy(); System.out.println(&quot;包装一个上班人：&quot;); WorkPersonDecorator workPersonDecorator = new WorkPersonDecorator(boy); workPersonDecorator.dress(); System.out.println(&quot;包装一个运动的人：&quot;); SportPersonDecorator sportPersonDecorator = new SportPersonDecorator(boy); sportPersonDecorator.dress(); &#125;&#125; 输出： Android中的装饰者模式经常使用的Context其实用的就是包装模式： 先看一下他们的继承关系： Activity的： 然后是service的： 然后是application的: 他们都继承了ContextWrapper类。根据这个名字就觉得这是一个装饰类。装饰类里面会持有一个被装饰者的引用，找一下：1234567891011121314151617181920package android.content;public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; @Override public AssetManager getAssets() &#123; return mBase.getAssets(); &#125; //.......&#125; 看到前面这两行就感觉找对了。有两种方法可以给mBase赋值。而且这个类的一切操作都像getAssets方法一样，调用的是mBase的方法。因此可以知道，传进来的mBase才是真正的执行者。 接下来就找一下具体的被包装类是什么。 在分析Activity的onCreate方法调用时，知道activity的创建是在ActivityThread的performLaunchActivity方法中的，再来看一下： 1234567891011121314151617181920212223242526272829303132private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity activity = null; try &#123; //创建Activity java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; //...... try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //创建Activity的Context Context appContext = createBaseContextForActivity(r, activity); //...... activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //...... &#125; //...... &#125; return activity; &#125; createBaseContextForActivity创建的是具体的Activity的Context，查看源码发现是ContextImpl：123456789private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; //......这里创建的是ContextImpl。 ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, r.token, displayId, r.overrideConfig); appContext.setOuterContext(activity); Context baseContext = appContext; //...... return baseContext; &#125; 在performLaunchActivity通过createBaseContextForActivity拿到一个ContextImpl之后，会调用activity.attach方法,看这个方法：1234567891011final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); //...... &#125; 都知道传进来的是前面获取的ContextImpl。 然后调用Activity的父类ContextThemeWrapper的attachBaseContext方法：1234@Override protected void attachBaseContext(Context newBase) &#123; super.attachBaseContext(newBase); &#125; 看他有调用了父类的方法，ContextThemeWrapper的父类就是ContextWrapper了，然后就回到了ContextWrapper。 前面可以看到ContextWrapper刚好就有个attachBaseContext，给mBase赋值，因此可以说，至少在Activity上，ContextWrapper这个装饰类里面引用的具体被装饰类是ContextImpl。其实Application和Service的被装饰者也是ContextImpl。 123456789package android.app;class ContextImpl extends Context &#123; //...... @Override public AssetManager getAssets() &#123; return getResources().getAssets(); &#125; //......&#125; 下面就可以画出他们的关系了： 总结装饰模式和前面的代理模式有点类似，容易把装饰模式看成代理模式。装饰模式是继承的一种替代方案，主要为所装饰的对象增强功能，动态的增加方法。而代理模式主要是为了控制对原有对象的访问权限，不对原有对象进行功能增强。 我觉得两者的区别主要是使用目的的区别。 优点 是继承的一种替代方案，但是比继承要灵活的多，可以在运行时通过传入不同的被装饰器或不同的装饰器来达成不同的行为。 增加新的被装饰类和装饰类很方便，而且不用修改原有代码。便于拓展。符合开闭原则。 缺点 设计模式基本都有这个缺点，就是会生成额外的类，增加系统复杂度。 由于装饰可以层层包装，交叉包装，如果包装的很深的话，调试排错会比较麻烦，也不容易理解。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十九）-适配器模式","date":"2017-04-07T08:09:38.000Z","path":"2017/04/07/Android设计模式（十九）-适配器模式/","text":"适配器模式是咋Android中使用非常广泛的一种设计模式，总到处可见的Adapter就可以看出来。适配器模式类似于电源适配器的设计思想，将两个不兼容的东西通过适配兼容到一起。 在实际开发中，经常会遇见两个没有关系的类型之间的交互。那么有下面两个方式： 修改各自类的接口，以达到互相交互的目的。 在两个类之间建立一个“混血儿”接口，将两个类型进行兼容，不用修改原来的类的代码。 第一种方式明显不是个好选择，我们不愿意为了一个应用而修改各自的接口。而且如果一个类要适配很多类的话，避免要做很多 这样的修改，既不利于扩展也不利于维护。 第二种就是要说的适配器模式了。 定义适配器模式吧一个类的接口变换成客户端锁期待的另一种接口，从而使原本因为接口不匹配而无法在一起工作的两个类能够在一起工作。 使用场景 系统需要使用现有的类，但是这个类的接口不符合系统的需要。 想要建立一个可以重复使用的类，用于与一些批次之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 需要一个统一的输出接口，而输出的类型不确定。 UML适配器模式也分两种，类适配器和对象适配器 类适配器 类适配器通过实现Target接口和继承Adaptee类来实现接口转换。比如Target需要operation2，而Adaptee只有operation3，所以Adapter就能把operation3转为operation2供Target使用。 目标角色，所期待的接口，虽然是类适配器，但这个目标不能是类。 需要适配的接口 适配器，把源接口转换成目标接口。这个角色必须是具体类。 类适配器简单实现就以电源适配器为例子，一般笔记本需要5V的电压，而电源都是220V的。这是就需要电源适配器出来干活了。 代码很简单 先建目标接口，需要的是5V的电压123public interface FiveVolt &#123; public int getVolt5();&#125; 然后是插座的电压220v12345public class Volt220 &#123; public int getVolt220()&#123; return 220; &#125;&#125; 适配器123456public class VoltAdapter extends Volt220 implements FiveVolt &#123; @Override public int getVolt5() &#123; return 5; &#125;&#125; 这样就解决了接口不兼容的问题 对象适配器 对象适配器一样是吧被适配类的API转化成目标类的API。但是，对象适配器模式不是使用继承关系连接到Adaptee类，而是使用代理关系。 目标：123public interface FiveVolt &#123; public int getVolt5();&#125; 需要适配的:12345public class Volt220 &#123; public int getVolt220()&#123; return 220; &#125;&#125; 适配器:123456789101112131415public class VoltAdapter implements FiveVolt &#123; Volt220 volt220 ; public VoltAdapter(Volt220 volt220) &#123; this.volt220 = volt220; &#125; @Override public int getVolt5() &#123; return 5; &#125; public int getVolt220()&#123; return volt220.getVolt220(); &#125;&#125; 客户端调用：123456public class Client &#123; public static void main(String[] args) &#123; VoltAdapter voltAdapter = new VoltAdapter(new Volt220()); System.out.println(voltAdapter.getVolt5()); &#125;&#125; 对象适配器直接把要被适配的对象传递到Adapter中，使用组合的形式实现接口兼容。比类适配器更加灵活，而且不会暴露被适配对象中的方法。 类适配器由于继承了被适配的类，所以这个适配器会拥有被适配对象的方法，导致适配器出现一些奇怪的方法。 适配器模式还经常用于处理不兼容类型的统一输出问题。例如ListView的输入有很多种类型，但输出都是View，适配器就可以做到这一点。 总结优点 提高现有类和系统类的复用性，适配器能让一个类有更广泛的用途。 提高了灵活想，更换适配器就能达到不同的效果。而且不用修改原有代码。 类适配器可以重写继承的被适配者的一些方法来增加灵活性 对象适配器可以传入不同的对象把不同的对象都适配到同一个接口。 缺点 过多的使用适配器，会让系统变得非常凌乱，不易整体把握。明明调用A接口，却被适配成B接口。 java不能多继承，所以类适配器只能适配一个被适配类。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十八）-组合模式","date":"2017-04-07T03:59:31.000Z","path":"2017/04/07/Android设计模式（十八）-组合模式/","text":"组合模式，也称作部分整体模式。是结构型设计模式之一。组合模式画成图就是数据结构中的树结构，有一个根节点，然后有很多分支。将最顶部的根节点叫做根结构件，将有分支的节点叫做枝干构件，将没有分支的末端节点叫做叶子构件. 定义将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 使用场景 想表示对象的部分-整体层次结构时。 希望用户忽略单个对象和组合对象的不同，对对象使用具有统一性时。 从一个整体中能够独立出部分模块或功能时。 UML安全的组合模式 Component:抽象节点，为组合中的对象声明接口，适当的时候实现所有类的公有接口方法的默认行为。 Composite：定义所有枝干节点的行为，存储子节点，实现相关操作。 Leaf：叶子节点，没有子节点，实现相关对象的行为。 看一下这个模式的通用代码 抽象的节点：12345678public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; public abstract void doSonthing();&#125; 枝干节点：123456789101112131415161718192021222324252627public class Composite extends Component &#123; private List&lt;Component&gt; components = new ArrayList&lt;&gt;(); public Composite(String name) &#123; super(name); &#125; @Override public void doSonthing() &#123; System.out.println(name); if (null!=components)&#123; for (Component c:components) &#123; c.doSonthing(); &#125; &#125; &#125; public void addChild(Component child)&#123; components.add(child); &#125; public void removeChild(Component child)&#123; components.remove(child); &#125; public Component getChild(int index)&#123; return components.get(index); &#125;&#125; 叶子节点：12345678910public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override public void doSonthing() &#123; System.out.println(name); &#125;&#125; 客户端调用：12345678910111213141516171819202122public class CLient &#123; public static void main(String[] args) &#123; Composite root = new Composite(&quot;root&quot;); Composite branch1 = new Composite(&quot;branch1&quot;); Composite branch2 = new Composite(&quot;branch2&quot;); Composite branch3 = new Composite(&quot;branch3&quot;); Leaf leaf1 = new Leaf(&quot;leaf1&quot;); Leaf leaf2 = new Leaf(&quot;leaf2&quot;); Leaf leaf3 = new Leaf(&quot;leaf3&quot;); branch1.addChild(leaf1); branch3.addChild(leaf2); branch3.addChild(leaf3); root.addChild(branch1); root.addChild(branch2); root.addChild(branch3); root.doSonthing(); &#125;&#125; 输出： 我们可以发现在Client使用的时候，根本没用到接口Component。违反了依赖倒置原则。 因为接口中没有定义公共方法，必须使用对应搞得实现节点才能完成相应的操作，叫安全的组合模式。 透明的组合模式所以就有一种透明的组合模式，所有的节点都包含有同样的结构 抽象的节点：123456789101112public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; public abstract void doSonthing(); public abstract void addChild(Component child); public abstract void removeChild(Component child); public abstract Component getChild(int index);&#125; 枝干节点：123456789101112131415161718192021222324252627public class Composite extends Component &#123; private List&lt;Component&gt; components = new ArrayList&lt;&gt;(); public Composite(String name) &#123; super(name); &#125; @Override public void doSonthing() &#123; System.out.println(name); if (null!=components)&#123; for (Component c:components) &#123; c.doSonthing(); &#125; &#125; &#125; public void addChild(Component child)&#123; components.add(child); &#125; public void removeChild(Component child)&#123; components.remove(child); &#125; public Component getChild(int index)&#123; return components.get(index); &#125;&#125; 叶子节点：12345678910111213141516171819202122232425public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override public void doSonthing() &#123; System.out.println(name); &#125; @Override public void addChild(Component child) &#123; throw new UnsupportedOperationException(&quot;叶子节点没有子节点&quot;); &#125; @Override public void removeChild(Component child) &#123; throw new UnsupportedOperationException(&quot;叶子节点没有子节点&quot;); &#125; @Override public Component getChild(int index) &#123; throw new UnsupportedOperationException(&quot;叶子节点没有子节点&quot;); &#125;&#125; 客户端调用：12345678910111213141516171819202122public class CLient &#123; public static void main(String[] args) &#123; Component root = new Composite(&quot;root&quot;); Component branch1 = new Composite(&quot;branch1&quot;); Component branch2 = new Composite(&quot;branch2&quot;); Component branch3 = new Composite(&quot;branch3&quot;); Component leaf1 = new Leaf(&quot;leaf1&quot;); Component leaf2 = new Leaf(&quot;leaf2&quot;); Component leaf3 = new Leaf(&quot;leaf3&quot;); branch1.addChild(leaf1); branch3.addChild(leaf2); branch3.addChild(leaf3); root.addChild(branch1); root.addChild(branch2); root.addChild(branch3); root.doSonthing(); &#125;&#125; 输出： 简单实现以文件夹系统举个例子： 抽象的文件系统：1234567891011121314151617public abstract class Dir &#123; protected List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;(); private String name; public Dir(String name) &#123; this.name = name; &#125; public abstract void addDir(Dir dir); public abstract void rmDir(Dir dir);//删除文件或文件夹 public abstract void clear();//清空所有元素 public abstract void print();//打印文件夹系统结构 public abstract List&lt;Dir&gt; getFiles(); public String getName()&#123; return name; &#125;&#125; 文件夹：12345678910111213141516171819202122232425262728293031323334353637383940public class Folder extends Dir &#123; public Folder(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; dirs.add(dir); &#125; @Override public void rmDir(Dir dir) &#123; dirs.remove(dir); &#125; @Override public void clear() &#123; dirs.clear(); &#125; @Override public void print() &#123; //利用递归来输出文件夹结构 System.out.print(getName()+&quot;(&quot;); Iterator&lt;Dir&gt; i = dirs.iterator(); while (i.hasNext())&#123; Dir dir = i.next(); dir.print(); if (i.hasNext())&#123; System.out.print(&quot;, &quot;); &#125; &#125; System.out.print(&quot;)&quot;); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; return dirs; &#125;&#125; 文件：123456789101112131415161718192021222324252627282930public class File extends Dir &#123; public File(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; throw new UnsupportedOperationException(&quot;文件不支持此操作&quot;); &#125; @Override public void rmDir(Dir dir) &#123; throw new UnsupportedOperationException(&quot;文件不支持此操作&quot;); &#125; @Override public void clear() &#123; throw new UnsupportedOperationException(&quot;文件不支持此操作&quot;); &#125; @Override public void print() &#123; System.out.print(getName()); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; throw new UnsupportedOperationException(&quot;文件不支持此操作&quot;); &#125;&#125; 客户端调用：123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; //创建根目录 root Dir root = new Folder(&quot;root&quot;); //root下有个文件log.txt和三个文件夹 system,user,lib; root.addDir(new File(&quot;log.txt&quot;)); Dir system = new Folder(&quot;system&quot;); system.addDir(new File(&quot;systemlog.txt&quot;)); root.addDir(system); Dir user = new Folder(&quot;user&quot;); user.addDir(new File(&quot;usernamelist.txt&quot;)); root.addDir(user); Dir lib = new Folder(&quot;lib&quot;); lib.addDir(new File(&quot;libs.txt&quot;)); root.addDir(lib); root.print(); &#125;&#125; 输出： Android源码中的组合模式组合模式在Android中太常用了，View和ViewGroup就是一种很标准的组合模式： 在Android的视图树中，容器一定是ViewGroup，只有ViewGroup才能包含其他View和ViewGroup。View是没有容器的。者是一种安全的组合模式。 总结在Android开发中用到组合模式并不很多，组合模式更多的用于界面UI的架构设计上，而这部分让开发者去实现的并不多。 优点 可以清楚定义分层次的复杂对象，表示全部或部分层次，让高层忽略层次的差异，方便对整个层次结构进行控制。 高层模块可以一致的使用一个组合结构或其中的单个对象，不必挂心处理的是单个对象还是整个组合结构，简化了高层模块的代码。 增加新的枝干和叶子构件都很方便，无需对现有类进行任何修改，就像增加一个自定义View一样。 将对象之间的关系形成树形结构，便于控制。 缺点 设计变得更加抽象，因此很难限制组合中的组件，因为他们都来自相同的抽象层。所以必须在运行时进行类型检查才能实现。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十七）-代理模式","date":"2017-04-06T08:41:35.000Z","path":"2017/04/06/Android设计模式（十七）-代理模式/","text":"代理模式也叫委托模式，是结构型设计模式。代理就是让别人帮你做事，比如帮你带饭，请律师打官司什么的。 定义为其他对象提供一种代理以控制对这个对象的访问。 使用场景 当一个对象不能或者不想直接访问另一个对象时，可以通过一个代理对象来间接访问。为保证客户端使用的透明性，委托对象和代理对象要实现同样的接口。 被访问的对象不想暴露全部内容时，可以通过代理去掉不想被访问的内容。 UML Subject: 抽象主题类，声明真是主体与代理主题的共同接口方法。 RealSubject: 真实主题类，定义了代理所表示的真是对象，执行具体的业务方法。客户端通过代理类来间接的调动这个真实主题中的方法。 ProxySubject: 代理类，持有一个真实类的引用，在接口方法中调用真实主题相应的方法，达到代理的作用。 简单实现就以打官司为例。我们一般人要打官司都要找个律师来代理。 静态代理先建立一个起诉类的接口：123456public interface ILawsuit &#123; void submit();//提交申请 void burden();//进行举证 void defend();//开始辩护 void finish();//诉讼完成&#125; 真正的起诉者：123456789101112131415161718192021public class Civilian implements ILawsuit &#123; @Override public void submit() &#123; System.out.println(&quot;起诉&quot;); &#125; @Override public void burden() &#123; System.out.println(&quot;举证&quot;); &#125; @Override public void defend() &#123; System.out.println(&quot;辩护&quot;); &#125; @Override public void finish() &#123; System.out.println(&quot;胜诉&quot;); &#125;&#125; 找的律师：123456789101112131415161718192021222324252627public class Lawyer implements ILawsuit &#123; private ILawsuit civilian; public Lawyer(ILawsuit civilian) &#123; this.civilian = civilian; &#125; @Override public void submit() &#123; civilian.submit(); &#125; @Override public void burden() &#123; civilian.burden(); &#125; @Override public void defend() &#123; civilian.defend(); &#125; @Override public void finish() &#123; civilian.finish(); &#125;&#125; 客户端调用，调用律师的方法，通过律师调用真正的su起诉者的方法。12345678910public class Client &#123; public static void main(String[] args) &#123; ILawsuit civilian = new Civilian(); ILawsuit lawyer = new Lawyer(civilian); lawyer.submit(); lawyer.burden(); lawyer.defend(); lawyer.finish(); &#125;&#125; 输出： 一个代理可以代理多个类，就像这个律师可以给很多人打官司，只需要在实现一个具体的ILawsuit就行了。代理会根据传进来的被代理者调用传进来的被代理者的方法。 动态代理代理模式大致分为两大部分：静态代理和动态代理。 上面是是一种静态代理，代理者的代码时先生成写好，然后再对其进行编译，在代码运行前，代理类的class编译文件就已经存在了。 动态代理是相反的，通过反射动态的生成代理者对象，也就是说在写代码的时候根本不知道要代理谁，具体代理谁会在执行阶段决定。 Java提供了一个便捷的动态代理接口InvocationHandler，动态代理类只要实现这个接口就行：123456public class DynamicProxy implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125;&#125; 看一下动态代理的用法：1234567891011121314public class DynamicProxy implements InvocationHandler &#123; private Object object; public DynamicProxy(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //当然这里可以对方法名进行判断过滤 if(method.getName().equals(&quot;***&quot;)) Object result = method.invoke(object,args); return result; &#125;&#125; 客户端调用：1234567891011121314public class Main &#123; public static void main(String[] args) &#123; ILawsuit lawsuit = new Civilian(); DynamicProxy proxy = new DynamicProxy(lawsuit); ClassLoader loader = lawsuit.getClass().getClassLoader(); //动态创建代理类，需要传入一个类加载器ClassLoader；一个你希望这个代理实现的接口列表，这里要代理ILawsuit接口； //和一个InvocationHandler的实现，也就是前面创建的proxy。 ILawsuit lawyer = (ILawsuit) Proxy.newProxyInstance(loader,new Class[]&#123;ILawsuit.class&#125;,proxy); lawyer.submit(); lawyer.burden(); lawyer.defend(); lawyer.finish(); &#125;&#125; 输出和上面一毛一样： 动态代理并不局限与代理一个接口的实现，可以根据运行时传入的接口，动态的生成代理类，然后通过Method的invoke方法来执行被代理类的真实方法。非常灵活。 其他分类静态代理和动态代理是从code方便进行分类的。这两个分类根据适用范围来分都可以分为下面几种： 远程代理：为摸个对象在不同的内存地址空间提供局部代理，是系统Server部分隐藏，以便Client不用考虑Server的存在。 虚拟代理：如果要创建一个资源消耗较大的对象，可以先用一个代理对象表示，在真正需要的时候才真正创建。 保护代理：用代理对象控制对一个对象的访问，给不同的用户提供不同的访问权限。 智能引用：在引用原始对象的时候附加额外操作，并对指向原始对象的引用增加引用计数。 总结代理模式使用非常广泛，从分类就能感觉出来，而且其他的设计模式中也会有代理模式的影子。 优点优点可以从他的适用范围看出来 协调调用者和被调用者，降低系统耦合度。 用小对象代表大对象，减少系统资源消耗，提高系统运行速度，如虚拟代理。 控制用户对呗调用者的使用权限，如保护代理。 缺点 首先当然是比直接调用原始对象多了一个中间者，会让结构有点复杂。 调用原始对象的方法要通过代理来调用，可能会造成请求处理速度变慢。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十六）-中介者模式","date":"2017-04-06T06:17:19.000Z","path":"2017/04/06/Android设计模式（十六）-中介者模式/","text":"中介者模式又叫调解者模式或调停者模式，是行为型设计模式之一。 生活中的中介者的作用就是连接两方的一个桥梁，比如房产中介，买房的只需跟中介打交道，然后买房的也跟着中介打交道， 没有中介的时候是这样的： 每个买房的和卖房的都要和很多对方打交道，有了新的买房人，这些卖房的都得知道才能去和他联系。 有了中介者之后： 所有买房的和卖房的都只需要跟中介者一个人打交道，买房的不需要知道卖房的是什么人，有多少卖房的等等。都省事了很多。 定义通过中介者包装一系列对象的交互，使得这些对象不必相互显式引用，从而使它们可以松散耦合。 当某些对象之间的作用发生变化是，不会立即影响其他对象间的作用，保证这些作用协议彼此独立的变化。 中介者模式将多对多的相互作用转化为一堆多的相互作用。 使用场景 多个对象之间的交互操作很多，每个对象的行为都依赖批次，形成网状的多对多结构，为了防止修改一个对象时要修改很多其他对象，可以用中介者模式。 UML Mediator: 抽象的中介者角色，定义了同事对象到中介者的接口。 ConcreteMediator：具体的中介者角色，从具体的同事对象接收消息，同时向具体的同事对象发出命令。 Colleague：抽象同事类角色，定义了中介者对象的接口，只知道中介而不知道其他同事对象。 ConcreteColleagueA，B：具体的同事类角色，每个具体同事类都知道本身在小范围内的行为，而不知道他在大范围中的行为。 模板代码： 抽象的中介者：123public interface Mediator &#123; void change();&#125; 具体的中介者：123456789101112131415161718public class ConcreteMediator implements Mediator &#123; public ConcreteColleagueA concreteColleagueA; public ConcreteColleagueB concreteColleagueB; public void setConcreteColleagueA(ConcreteColleagueA concreteColleagueA) &#123; this.concreteColleagueA = concreteColleagueA; &#125; public void setConcreteColleagueB(ConcreteColleagueB concreteColleagueB) &#123; this.concreteColleagueB = concreteColleagueB; &#125; @Override public void change() &#123; concreteColleagueA.action(); concreteColleagueB.action(); &#125;&#125; 抽象的同事：12345678public abstract class Colleague &#123; public Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void action();&#125; 具体的同事：1234567891011121314151617181920public class ConcreteColleagueA extends Colleague &#123; public ConcreteColleagueA(Mediator mediator) &#123; super(mediator); &#125; @Override public void action() &#123; System.out.println(&quot;交给中介做A的事情&quot;); &#125;&#125;public class ConcreteColleagueB extends Colleague &#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; @Override public void action() &#123; System.out.println(&quot;交给中介做B的事情&quot;); &#125;&#125; 简单实现以电脑为例子。CPU，显卡，内存等零件的交互都是通过主板实现的，而且每个零件只需要做好自己的工作，不需要知道其他零件是什么。所以主板可以作为他们的中介者。 抽象的中介者：123public abstract class Mediator &#123; public abstract void change(Colleague colleague);&#125; 具体的中介者，主板：1234567891011121314151617181920212223242526272829303132333435363738public class MainBoard extends Mediator &#123; private CDDevice cdDevice; private CPU cpu; private GraphicsCard graphicsCard; private SoundCard soundCard ; @Override public void change(Colleague colleague) &#123; if (colleague==cdDevice)&#123; handleCD((CDDevice) colleague); &#125; if (colleague==cpu)&#123; handleCPU((CPU) colleague); &#125; &#125; private void handleCD(CDDevice cdDevice)&#123; cpu.decodeData(cdDevice.read()); &#125; private void handleCPU(CPU cpu)&#123; soundCard.playSound(cpu.getDataSound()); graphicsCard.vidoePlay(cpu.getDataVideo()); &#125; public void setCdDevice(CDDevice cdDevice) &#123; this.cdDevice = cdDevice; &#125; public void setCpu(CPU cpu) &#123; this.cpu = cpu; &#125; public void setGraphicsCard(GraphicsCard graphicsCard) &#123; this.graphicsCard = graphicsCard; &#125; public void setSoundCard(SoundCard soundCard) &#123; this.soundCard = soundCard; &#125;&#125; 抽象的零件：1234567public abstract class Colleague &#123; public Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; 具体的零件：1234567891011121314151617181920public class CPU extends Colleague &#123; private String dataVideo,dataSound; public CPU(Mediator mediator) &#123; super(mediator); &#125; public String getDataVideo()&#123; return dataVideo; &#125; public String getDataSound() &#123; return dataSound; &#125; //解析数据，分割音频和视频 public void decodeData(String data)&#123; String[] tmp = data.split(&quot;，&quot;); dataVideo=tmp[0]; dataSound=tmp[1]; mediator.change(this); &#125;&#125; 12345678910111213public class CDDevice extends Colleague &#123; private String data; public CDDevice(Mediator mediator) &#123; super(mediator); &#125; public String read()&#123; return data; &#125; public void load()&#123; data=&quot;视频数据，音频数据&quot;; mediator.change(this); &#125;&#125; 123456789public class GraphicsCard extends Colleague &#123; public GraphicsCard(Mediator mediator) &#123; super(mediator); &#125; public void vidoePlay(String data)&#123; System.out.println(&quot;播放视频：&quot;+data); &#125;&#125; 12345678910public class SoundCard extends Colleague &#123; public SoundCard(Mediator mediator) &#123; super(mediator); &#125; public void playSound(String data)&#123; System.out.println(&quot;播放音频：&quot;+ data); &#125;&#125; 总结在面向对象编程中，一个类必然会与其他类产生依赖关系，当依赖关系错综复杂时，可以考虑用中介者模式进行解耦。 优点 降低类的关系复杂度，将多对多转化成一对多，实现解耦。 符合迪米特原则（最少知识原则） 缺点 中介者要做很多事，会变得庞大且难以维护。 如果本来关系并不复杂，那么使用中介者可能会让关系变得更复杂。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十五）-访问者模式","date":"2017-04-05T09:21:55.000Z","path":"2017/04/05/Android设计模式（十五）-访问者模式/","text":"访问者模式是一种将数据操作与数据结构分离的设计模式。确实是我目前为止见过的最复杂的了。 访问者模式的思想是： 软件系统中拥有一个由许多对象构成的，比较稳定的对象结构。这些对象都拥有一个accept方法来接受访问者的访问。 访问者是一个接口，对对象结构中的每一个元素都提供一个visit方法，对不同的访问对象执行不同的visit方法做出不同的处理。 在对象结构的一次访问中，遍历整个对象结构，对每一个元素执行accept方法，在每个accept方法中调用访问者的visit方法，从而使访问者可以处理对象结构中的每一个元素。 可以针对同一个对象结构，设计不同的访问者类，达到区别对待的目的。 定义 封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 使用场景 对象结构稳定，但经常需要在此对象结构上定义新的操作。 需要对一个对象结构中的元素进行很多不同的操作，为了避免这些操作“污染”这些对象的类，也为了避免在增加新操作时修改这些类。 加入在一组对象中存在相似的操作，为了减少代码重复率，将相同的操作封装到访问者中去。 UML Visitor：接口或抽象类，定义了对每一个元素的访问行为，参数就是可访问的元素，方法个数理论上是个元素个数一样的。因此，访问者模式要求被访问的对象结构要稳定，如果经常增删元素，必然会导致频繁修改Visitor接口，就不适合用访问者模式了。 ConcreteVisitor：具体的访问者，定义具体的对每一个元素的具体访问行为。 Element：抽象的元素接口或抽象类，定义了一个接待访问者的方法，让每个元素都可以被访问者访问。 Element，ElementB:具体的元素类，提供接收访问方法的具体实现。这个具体实现通常是调用访问者提供的访问该元素的方法。 ObjectStructure：定义对象结构，里面维护了一个元素的集合，并且迭代这些元素供访问者访问。 简单实现就举公司的年终考核来说。假设一个公司的基层结构很稳定，就是工程师和经理。那么不同的高层来考核就要访问他们不同的东西。 工程师和经理是被考核者，可以看成被访问者。CEO和CTO是考核者，他们的考核指标不一样，但都是考核工程师的经理，他们可以看做是访问者。 CEO访问工程师和经理，要获取他们的KPI作为考核依据。 CTO访问工程师要获取代码量，访问经理要获取项目个数作为开合依据。 被访问者，员工的基类：1234567891011public abstract class Staff &#123; public String name; public int kpi; public Staff(String name) &#123; this.name = name; kpi = new Random().nextInt(10); &#125;//定义一个抽象的受访问方法 public abstract void accept(Visitor visitor);&#125; 工程师12345678910111213141516public class Engineer extends Staff &#123; public Engineer(String name) &#123; super(name); &#125;//实现受访问方法，里面调用访问者的访问方法。通传参来确定调用Visitor的哪个方法。 @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public int getCodeLines()&#123; return new Random().nextInt(1000000); &#125;&#125; 经理1234567891011121314public class Manager extends Staff &#123; public Manager(String name) &#123; super(name); &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; public int getProducts()&#123; return new Random().nextInt(10); &#125;&#125; 访问者的抽象类,为每一个被访问者都提供可一个访问方法。1234public interface Visitor &#123; void visit(Engineer engineer); void visit(Manager manager);&#125; CTO,实现每一个访问元素的方法，访问不同的元素进行不同的操作,各取所需1234567891011public class CTO implements Visitor &#123; @Override public void visit(Engineer engineer) &#123; System.out.println(&quot;我CTO考察工程师&quot;+engineer.name+&quot;的代码量是&quot;+engineer.getCodeLines()); &#125; @Override public void visit(Manager manager) &#123; System.out.println(&quot;我CTO考察经理&quot;+manager.name+&quot;的产品量是&quot;+manager.getProducts()); &#125;&#125; CEO，1234567891011public class CEO implements Visitor &#123; @Override public void visit(Engineer engineer) &#123; System.out.println(&quot;我CEO考察工程师&quot;+engineer.name+&quot;的KPI是&quot;+engineer.kpi); &#125; @Override public void visit(Manager manager) &#123; System.out.println(&quot;我CEO考察经理&quot;+manager.name+&quot;的KPI是&quot;+manager.kpi); &#125;&#125; 生成报表，也就是对象结构。内部遍历调用每一个元素的接受访问方法。123456789101112131415161718public class Report &#123; List&lt;Staff&gt; list = new ArrayList&lt;&gt;(); public Report() &#123; list.add(new Engineer(&quot;小王&quot;)); list.add(new Engineer(&quot;大王&quot;)); list.add(new Engineer(&quot;老王&quot;)); list.add(new Manager(&quot;小张&quot;)); list.add(new Manager(&quot;大张&quot;)); list.add(new Manager(&quot;老张&quot;)); &#125; public void showReport(Visitor visitor)&#123; for (Staff staff:list) &#123; staff.accept(visitor); &#125; &#125;&#125; 客户端调用12345678public class Client &#123; public static void main(String[] args) &#123; Report report = new Report(); report.showReport(new CTO()); System.out.println(&quot;---------&quot;); report.showReport(new CEO()); &#125;&#125; 输出： 到这里能感觉到访问者模式最大的好处就是，当被访问者是固定的时候，拓展访问者非常容易。 比如现在有COO还要进行考核，那么只需实现一个COO实现Visitor接口，实现具体的访问方法。然后在report.showReport(new COO())，就能拿到他需要的内容了，其他地方都不用修改。 总结访问者模式适合在访问对象稳定的时候使用。 优点 角色分离，各司其职，符合单一职责原则 具有优秀的拓展性 使数据结构和作用于结构上的操作解耦，是操作集合可以独立变化。 缺点 具体元素对访问者公布细节，违反了迪米特原则。 具体元素修改的成本太大。 违反了依赖倒置原则，为了达到区别对待依赖了具体而不是抽象。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十四）-模板方法模式","date":"2017-04-05T06:42:29.000Z","path":"2017/04/05/Android设计模式（十四）-模板方法模式/","text":"模板方法模式，名字就很直接，也很容易理解。什么是模板，模板就是一套固定格式。我们可以想象一个普通员工的一天的上班模板：去公司上班-&gt;工作-&gt;下班回家。对于每一个员工来说，这三个步骤的具体内容是不一样的，但是流程都是这样的。 在开发中也会有这种情况，架构师或者高级开发人员写好一些方法流程，规定方法名，方法输出，执行顺序等等，但是方法体是空的，留给初级的开发人员去填写具体的实现功能。而且这样一套模板用不同的平台语言实现就可以生成不同平台的产品。这些解决方案都可以称为模板方法模式。 定义定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 使用场景 多个逻辑有公有的方法，且逻辑基本相同。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能由各个子类实现。 重构时经常会用到模板方法，把相同的代码抽取到父类中，然后通过钩子方法约束其行为。 UML UML图很简单 Abstemplate：抽象类，定义了一套算法框架 ConcreteImplA：具体实现类A ConcreteImplB：具体实现类B 简单实例这里以打开计算机的过程为例。虽然计算机有不同的系统和用处，但是计算机的开机过程都是一样的。 启动电源–&gt;检查系统状态–&gt;进入操作系统–&gt;验证身份登录 定义一个抽象的计算机模板1234567891011121314151617181920212223public abstract class AbsComputer &#123; protected void powerOn()&#123; System.out.println(&quot;打开电源&quot;); &#125; protected void checkHardware()&#123; System.out.println(&quot;检查硬件&quot;); &#125; protected void loadOS()&#123; System.out.println(&quot;载入操作系统&quot;); &#125; protected void login()&#123; System.out.println(&quot;用户登录&quot;); &#125; //这里不允许重写，必须按这个顺序来 public final void startUp()&#123; System.out.println(&quot;开机 START&quot;); checkHardware(); loadOS(); login(); System.out.println(&quot;开机 END&quot;); &#125;&#125; 实现一个程序员计算机1234567public class CoderComputer extends AbsComputer &#123; @Override protected void login() &#123; super.login(); System.out.println(&quot;程序员计算机需要验证用户名和密码&quot;); &#125;&#125; 实现一个牛逼计算机12345678910111213public class NBComputer extends AbsComputer &#123; @Override protected void checkHardware() &#123; super.checkHardware(); System.out.println(&quot;牛逼的计算机要验证硬件防火墙&quot;); &#125; @Override protected void login() &#123; super.login(); System.out.println(&quot;牛逼的计算机要验证指纹&quot;); &#125;&#125; 使用：1234567891011public class Client &#123; public static void main(String[] args) &#123; CoderComputer coderComputer = new CoderComputer(); coderComputer.powerOn(); coderComputer.startUp(); System.out.println(&quot;--------&quot;); NBComputer nbComputer = new NBComputer(); nbComputer.powerOn(); nbComputer.startUp(); &#125;&#125; 输出: 子类都只能修改部分具体的实现，整体的逻辑流程是不允许修改的。 Android中的模板方法常用的AsyncTask的使用方法是这样的：1234567891011121314151617class MyAsynctask extends AsyncTask&#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Object doInBackground(Object[] params) &#123; return null; &#125; @Override protected void onPostExecute(Object o) &#123; super.onPostExecute(o); &#125; &#125; 通常要重写者三个方法。AsyncTask的执行过程就是一个逻辑流程，在这个过程中会在适当的时候执行者三个方法，这个过程是固定的。但是子类可以通过重写者三个方法来改变具体的执行内容。 总结模板方法模式就是流程封装，父类提取公用代码，子类实现部分或全部步骤。父类规定了整体流程。 优点 封装不变部分，扩展可变部分，符合开闭原则。 提取公共代码，提高代码复用率，利于维护。 缺点 用户阅读代码时只看子类会觉得难以理解，因为子类中并不是一个完整的逻辑。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十三）-迭代器模式","date":"2017-04-05T03:21:01.000Z","path":"2017/04/05/Android设计模式（十三）-迭代器模式/","text":"迭代器模式又称游标模式，也是行为型设计模式。源于对容器的访问，主要解决容器的遍历操作。 我们队容器的访问必然会用到遍历。我们可以将遍历的方法封装到容器中，或者不提供遍历方法。如果封装在容器中，容器就承担了过多的功能。如果不提供遍历方法，使用者会自己去实现遍历方法，让容器内部细节暴露无遗。 因此在访问类和容器之间加上了第三者–迭代器。 定义提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。 使用场景 遍历一个容器对象时。 UML Iterator : 迭代器接口，负责定义、访问、遍历元素的接口。 ConcreteIterator:具体的迭代类，实现迭代器接口，并记录遍历的当前位置。 Aggregate：容器接口，负责提供创建具体迭代器的接口。 ConcreteAggregate：具体容器类，和具体迭代器相关联。 模板代码抽象的迭代器1234public interface Iterator&lt;T&gt;&#123; boolean hasNext(); T next();&#125; 具体的迭代器12345678910111213141516171819202122public class ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; private List&lt;T&gt; list = new ArrayList&lt;&gt;(); private int cursor = 0; public ConcreteIterator(List&lt;T&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return cursor!=list.size(); &#125; @Override public T next() &#123; T obj = null; if (this.hasNext())&#123; obj = list.get(cursor++); &#125; return obj; &#125;&#125; 抽象的容器12345public interface Aggregate&lt;T&gt; &#123; void add(T obj); void remove(T obj); Iterator&lt;T&gt; iterator();&#125; 具体的容器1234567891011121314151617public class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt; &#123; private List&lt;T&gt; list = new ArrayList&lt;&gt;(); @Override public void add(T obj) &#123; list.add(obj); &#125; @Override public void remove(T obj) &#123; list.remove(obj); &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ConcreteIterator&lt;&gt;(list); &#125;&#125; 客户端调用1234567891011121314public class Client &#123; public static void main(String[] args) &#123; Aggregate aggregate = new ConcreteAggregate(); aggregate.add(&quot;a&quot;); aggregate.add(&quot;r&quot;); aggregate.add(&quot;f&quot;); aggregate.add(&quot;w&quot;); aggregate.add(&quot;e&quot;); Iterator iterator = aggregate.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 输出 简单实现可以直接用上面的模板代码，集合是泛型，存什么都可以。因为迭代器就是用来遍历的。 Android中的迭代器模式其实在上面的例子中用List来存储本来就是不合适的。因为Java本身提供的容器都已经提供了相应的迭代器。所以在开发中，我们基本不需要亲自去实现。 Android中的迭代器例子有一个是SQLite数据库的查询了。 12SQLiteDatabase db = SQLiteDatabase.openDatabase(path, null,SQLiteDatabase.OPEN_READWRITE);Cursor cursor = db.rawQuery(&quot;select * from android_basic , 15&quot;,null); 返回的是一个Cursor对象，这个对象实质是其实就是个迭代器。看看他的用法。123while (cursor.moveToNext())&#123;//遍历读取数据 ......&#125; 总结迭代器就是把容器中遍历对象的功能提取出来，这样既不暴露容器的细节，又可以让外部访问容器内部的内容。 优点 支持不同的方式去遍历一个容器，也可以有多个遍历，弱化了容器和遍历算法之间的关系。 不用用户自己去实现遍历功能，也分离了容器和遍历算法，避免了容器承担过多功能。 封装性更好，方便修改遍历算法而不用修改容器。 缺点 类文件会增加，所以对于简单的遍历来说不是很重要。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十二）-备忘录模式","date":"2017-04-05T00:26:57.000Z","path":"2017/04/05/Android设计模式（十二）-备忘录模式/","text":"备用录模式是一种行为型设计模式，用于保存对象当前的状态，以便之后可以再次恢复到此状态。 备忘录模式要保证保存的对象状态不能被对象从外部访问，保护好被保存的这些对象状态的完整性以及内部实现不向外部暴露。 定义在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。 使用场景 需要保存一个对象在某个适合的全部或部分状态时。 一个对象不希望外部直接访问其内部状态时。 UML Originator：负责创建一个备忘录，可以记录，恢复自身内部的状态。同时可以决定哪些状态需要备忘。 Memoto：备忘录角色，用于存储Originator的内部状态，并且可以防止Originator之外的对象访问Memoto。 Caretaker：负责存储备忘录，不能对备忘录的内容进行操作和访问，只能讲备忘录传递给其他对象。 看这个解释可能有点晕，直接看一下实例就很清晰了。 简单实现最容易理解的就是子啊游戏中的存档了。一般在打boss之前，都会存个档，以便于之后直接开始打boss。这个存档就包含了我们当前的状态，被boss打死后，下次读取存档就会回到这个状态，方便挑战boss。 首先是一个玩家类，包含各种玩法以及玩家自身状态。然后提供了保存生成当前状态的封装类和从保存的装套中恢复的方法。1234567891011121314151617181920212223242526272829303132333435363738public class Player &#123; private int lv = 1; private int hp = 100; private int mp = 50; public void play()&#123; lv++; hp+=100; mp+=50; System.out.println(&quot;升级了，当前级别&quot;+lv+&quot; hp:&quot;+hp+&quot; mp:&quot;+mp); &#125; public void attackBoss()&#123; hp-=80; mp-=40; System.out.println(&quot;打boss之后，当前级别&quot;+lv+&quot; hp:&quot;+hp+&quot; mp:&quot;+mp); &#125; public Memoto createMemoto()&#123; Memoto memoto = new Memoto(); memoto.lv = lv; memoto.hp = hp; memoto.mp = mp; return memoto; &#125; public void restore(Memoto memoto)&#123; lv = memoto.lv; hp = memoto.hp; mp = memoto.mp; System.out.println(&quot;回档了，当前级别&quot;+lv+&quot; hp:&quot;+hp+&quot; mp:&quot;+mp); &#125; @Override public String toString() &#123; return &quot;当前状态：级别&quot;+lv+&quot; hp:&quot;+hp+&quot; mp:&quot;+mp; &#125;&#125; 然后是备忘录对象，存储玩家状态12345public class Memoto &#123; public int lv; public int hp; public int mp;&#125; 最后是备忘录操作者者，用来存储和返回备忘录对象123456789public class Caretaker &#123; private Memoto memoto; public void save(Memoto memoto)&#123; this.memoto=memoto; &#125; public Memoto load()&#123; return memoto; &#125;&#125; 客户端调用：123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Player player = new Player(); player.toString(); player.play(); player.toString(); System.out.println(&quot;存档&quot;); Caretaker caretaker = new Caretaker(); caretaker.save(player.createMemoto()); player.attackBoss(); player.toString(); player.restore(caretaker.load()); player.toString(); &#125;&#125; 输出： 打完boss后，红和蓝都不满了，想重新回到打boss之前的状态就直接恢复之前备份的状态就行了。 当然，真实的游戏中你的游戏进度也会保存在存档中，恢复了状态肯定也要重新打boss了。 Android中的备忘录模式在Activity中有这两个方法：123456789@Overridepublic void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) &#123; super.onSaveInstanceState(outState, outPersistentState);&#125;@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState);&#125; 我们在用他们的时候目的就是为了保存Activity当前的状态，所以这个就是个备忘录模式。当然，操作者，备份和恢复过程等，已经被系统帮忙做了一部分。 总结优点 提供了一种备份恢复机制，使用户能方便的回到某个时刻的状态。 保存的状态是保存在发起人之外的类的，实现了对保存的状态的封装。发起人就不需要对备份进行管理了。 缺点 每一次保存都会消耗一定的内存。当保存的状态非常多的时候，会非常消耗资源。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十一）-观察者模式","date":"2017-04-04T14:19:36.000Z","path":"2017/04/04/Android设计模式（十一）-观察者模式/","text":"观察者模式是一种使用频率非常高的设计模式，最常用的地方就是订阅-发布系统。 这个模式的重要作用就是将观察者和被观察者解耦，使他们之间的依赖更小甚至没有。 定义定义对象一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于他的对象都会得到通知并被自动更新。 使用场景 关联行为场景，这个关联是可拆分的。将观察者和被观察者封装在不同的对象中，可以各自独立的变化。 当一个对象改变时，有其他对象要进行相应的变化，但是他并不知道有多少个对象需要变化。 跨系统的消息交换长江，如消息队列，时事件总线等 UML Subject : 抽象被观察者（Observeable），吧所有观察者对象的医用保存在一个集合里，每个主题都可以有任意数量的观察者，抽象被观察者提供一个接口，可以增加和删除观察者对象。 ConcreteSubject： 具体的被观察者，将有关状态存入具体的观察者对象，在具体的被观察者内部状态发生变化时，给所有注册的观察者发送通知。 Observer ： 抽象观察者，定义了一个更新接口，使得在得到被观察者的通知时更新自己。 ConcreteObserver ： 具体的观察者，实现了抽象观察者锁定义的接口，用来在收到通知时更新自己。 简单实现订阅模式就是个观察者模式，订阅后，被订阅的有更新就会提示你。 拿微信公众号举个例子吧.Java提供的有Observer和Observable类，可以很方便的实现观察者模式。 先定义一个订阅者，实现更新方法。123456789101112public class User implements Observer &#123; public String name; public User(String name) &#123; this.name = name; &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(&quot;Hi &quot;+name +&quot;,公众号更新了内容：&quot;+arg); &#125;&#125; 定义一个可观察者，有变化时发布更新通知。12345678public class Gamedaily extends Observable &#123; public void postNewArticle(String content)&#123; //内容发生改变 setChanged(); //通知所有订阅者改变的内容 notifyObservers(content); &#125;&#125; 使用1234567891011121314public class Client &#123; public static void main(String[] args) &#123; Gamedaily gamedaily = new Gamedaily(); User user1 = new User(&quot;user1&quot;); User user2 = new User(&quot;user2&quot;); User user3 = new User(&quot;user3&quot;); //将观察者注册到可观察者的通知列表中。 gamedaily.addObserver(user1); gamedaily.addObserver(user2); gamedaily.addObserver(user3); gamedaily.postNewArticle(&quot;新文章来了&quot;); &#125;&#125; 输出 当公众号发布新文章的时候，所有订阅者都收到的通知，并作出相应的改变。一个公众号对应多个订阅者，并且完全没有耦合。 Android源码中的观察者模式通常在ListView的内容变化时，我们会调用notifyDataSetChanged()这个方法，然后ListView里面的数据就会进行更新。这个感觉就像是观察者模式。ListView在观察者内容，内容变化发布通知之后ListView就会更新数据。 看一下这个方法。12345678910111213141516package android.widget;public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123; private final DataSetObservable mDataSetObservable = new DataSetObservable(); public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer); &#125; public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer); &#125; ...... public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged(); &#125; ......&#125; 这段代码可以看到这应该是一个观察者模式，而且这个一个被观察者，里面提供了注册和注销观察者以及通知观察者的方法。 这些方法是通过DataSetObservable这个类调用的：1234567891011package android.database;public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123; public void notifyChanged() &#123; synchronized(mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125; &#125; ......&#125; 这个类继承自Observable，Observable中有一个protected final ArrayList&lt;T&gt; mObservers = new ArrayList&lt;T&gt;();,用来保存注册的观察者。mDataSetObservable.registerObserver(observer)和mDataSetObservable.unregisterObserver(observer)分别就是增加和删除。 在notifyChanged方法中，循环这个集合，调用每一个观察者的onChanged()方法。 那么这些观察者是什么时候注册的呢？也就是ListView和Adapter什么时候成了订阅关系。在ListView的setAdapter()中 12345678910111213141516171819202122232425262728293031323334353637public class ListView extends AbsListView &#123; public void setAdapter(ListAdapter adapter) &#123; //如果已经有了一个adapter，注销这个adapter之前的观察者， if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; ...... if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; //将新的adapter赋给mAdapter mAdapter = adapter; &#125; ...... super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); //保存之前的数据个数 mOldItemCount = mItemCount; //获取新的个数 mItemCount = mAdapter.getCount(); checkFocus(); //创建数据集观察者 mDataSetObserver = new AdapterDataSetObserver(); //注册观察者 mAdapter.registerDataSetObserver(mDataSetObserver); ... &#125; &#125; else &#123; ... &#125; requestLayout(); &#125;&#125; AdapterDataSetObserver是ListView的父类AbsListView的内部类12345678910111213141516package android.widget;public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123; class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver &#123; @Override public void onChanged() &#123; super.onChanged(); if (mFastScroll != null) &#123; mFastScroll.onSectionsChanged(); &#125; &#125; ······ &#125;&#125; AdapterDataSetObserver是AdapterView.AdapterDataSetObserver的子类，所以要看super.onChanged()12345678910111213141516171819202122232425262728package android.widget;public abstract class AdapterView&lt;T extends Adapter&gt; extends ViewGroup &#123; class AdapterDataSetObserver extends DataSetObserver &#123; private Parcelable mInstanceState = null; @Override public void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); //重新布局 requestLayout(); &#125; ...... &#125;&#125; 整理一下：当ListView数据变化时，调用Adapter的notifyDataSetChange方法，这个方法调用DataSetObservable的notifyChanged方法，这个方法又会调用所有观察者的onChanged方法，onChanged再调用重新布局View的方法，完成刷新数据的功能。 总结优点 解除了观察者和被观察者的耦合，而且依赖的都是抽象，容易应对业务变化，各自的变化都不会影响另一个。 增强系统灵活性、可拓展性。 缺点 Java中的消息默认是顺序执行，如果一个观察者卡顿，会造成整个系统效率变低，可以考虑异步。 可能会引起无用的操作甚至错误的操作。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（十）-命令模式","date":"2017-04-01T07:16:11.000Z","path":"2017/04/01/Android设计模式（十）-命令模式/","text":"命令模式是行为型设计模式之一。命令模式没那么多条条框框，所以很灵活。命令模式简单的说就是给他下一个命令，然后他就会执行和这个命令的一系列操作。例如点击电脑的关机命令，系统会执行暂停，保存，关闭等一系列的命令，最后完成关机。 命令模式也跟关机一样，将一系列方法封装为一个方法，用户只要执行这个方法就会执行封装的一系列方法。不过真正用起来并不是这么直白简单。 定义将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求队列或者记录请求日志，以及支持可撤销的操作。 使用场景 需要对行为进行记录，撤销，重做，事务处理时。 需要抽象出待执行的动作，然后以参数的形式提供出来。 UML Receiver : 命令接收者，负责具体执行一个请求。在接收者中封装的具体操作逻辑的方法叫行动方法。 Command：命令角色，定义具体命令类的接口。 ConcreteCommand : 具体的命令角色。，实现了Command接口，在excute()方法中调用接收者Receiver的相关方法，弱化了命令接收者和具体行为之间的耦合。 Invoker：请求者角色，调用命令对象执行具体的请求。 模板代码： 接收者，执行具体命令12345public class Receiver &#123; public void action()&#123; System.out.println(&quot;具体执行&quot;); &#125;&#125; 抽象的命令123public interface Command &#123; void excute();&#125; 具体的命令123456789101112public class ConcreteCommand implements Command &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void excute() &#123; receiver.action(); &#125;&#125; 发起请求者12345678910public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.excute(); &#125;&#125; 客户端调用12345678public class Client &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(command); invoker.action(); &#125;&#125; 输出 简单实现接下来就以俄罗斯方块举个例子。将俄罗斯方块这个游戏看做是命令接收者，我们的手柄按键作为命令请求者。 先创建一个游戏,执行具体命令123456789101112public class Game &#123; public void toLeft()&#123; System.out.println(&quot;向左移动&quot;); &#125; public void toRight()&#123; System.out.println(&quot;向右移动&quot;); &#125; public void transform()&#123; System.out.println(&quot;变形&quot;); &#125;&#125; 创建抽象命令接口123public interface Command &#123; void excute();&#125; 创建三个具体命令123456789101112public class LeftCommand implements Command &#123; private Game receiver; public LeftCommand(Game receiver) &#123; this.receiver = receiver; &#125; @Override public void excute() &#123; receiver.toLeft(); &#125;&#125; 123456789101112public class RightCommand implements Command &#123; private Game receiver; public RightCommand(Game receiver) &#123; this.receiver = receiver; &#125; @Override public void excute() &#123; receiver.toRight(); &#125;&#125; 123456789101112public class TransformCommand implements Command &#123; private Game receiver; public TransformCommand(Game receiver) &#123; this.receiver = receiver; &#125; @Override public void excute() &#123; receiver.transform(); &#125;&#125; 创建一个按钮，这个按钮发起命令1234567891011121314151617181920212223242526272829public class Buttons &#123; private LeftCommand leftCommand; private RightCommand rightCommand; private TransformCommand transformCommand; public void setLeftCommand(LeftCommand leftCommand) &#123; this.leftCommand = leftCommand; &#125; public void setRightCommand(RightCommand rightCommand) &#123; this.rightCommand = rightCommand; &#125; public void setTransformCommand(TransformCommand transformCommand) &#123; this.transformCommand = transformCommand; &#125; public void toLeft()&#123; leftCommand.excute(); &#125; public void toRight()&#123; rightCommand.excute(); &#125; public void transform()&#123; transformCommand.excute(); &#125;&#125; 客户端调用1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; Game game = new Game(); LeftCommand leftCommand = new LeftCommand(game); RightCommand rightCommand = new RightCommand(game); TransformCommand transformCommand = new TransformCommand(game); Buttons buttons = new Buttons(); buttons.setLeftCommand(leftCommand); buttons.setRightCommand(rightCommand); buttons.setTransformCommand(transformCommand); buttons.toRight(); buttons.toLeft(); buttons.transform(); &#125;&#125; 最后输出 说明可能看到上面写那么一大堆东西，最后就实现那么点功能，是不是觉得太麻烦了？确实太麻烦了，上面的功能其实几行代码就搞定了： 12345678public class Client &#123; public static void main(String[] args) &#123; Game game = new Game(); game.toLeft(); game.toRight(); game.transform(); &#125;&#125; 输出同样是： 这其实也体现出来了命令模式的优点和缺点，命令模式提供了更低的耦合度，更好的扩展性，但也生成了大量的命令类。膨胀极其迅速。 总结命令模式本质就是将命令进行封装，将命令的发起者和真正的执行者隔离，降低耦合度。 命令请求者只需要发起请求，命令的具体执行时什么用，由谁执行都不需要知道。 优点 降低了请求者和发起者的耦合，降低了系统的耦合度 对命令更容易控制，可以自由组合不同的命令组。 对命令的拓展极其容易，新命令很容易加到系统中 缺点 类的数量膨胀太严重。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（九）-解释器模式","date":"2017-04-01T01:17:43.000Z","path":"2017/04/01/Android设计模式（九）-解释器模式/","text":"解释器模式是一种行为模式，实际开发中用的很少，提供了一种解释语言的语法或表达式的方式。 定义了一个表达式接口，通过接口解释一个特定的上下文。类似于json解析器按一定的语法解析json的。 定义给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。什么是文法？文法就是语言的规则，语法。每一个语法都对应一个解释器对象，解释器根据语法来解释相应的句子。 举个例子，那汉语中的主谓宾结构来说，我们经常是自己是什么是这样说的，我是程序员，`我是设计师…。那么，就可以把我是[职位]定义为一条文法。解释器一看见这样的文法，就能解析出来你的职业是[职业]。 使用场景 当一个语言需要解释执行，并且该语言中的句子可以表示为一个抽象的语法树时。 某些重复出现的问题，可以用一种简单的语言来表示的时候，可以将这个问题转化为一种语法规则下的语句。 UML AbstractExpression:抽象的解析方法。声明一个解析方法，具体实现在具体的子类中完成 TernimalExprission:实现对文法中与终结符有关的解释操作。 NonterminalExpression:实现对文法中的非终结符有关的解释操作。 Context：包含解释器之外的全部信息。 Client: 解析表达式，构建抽象语法书，执行具体的解释操作等。 简单实现以数字计算为例，`a+b+c,如果使用解释器模式对表达式进行解释，那么a,b,c可以看做是终结负号，+看做是非终结负号。 抽象的解释器，定义每个解释器都有个方法提取结果值123public abstract class ArithmeticExpression &#123; public abstract int interpret();&#125; 数字解释器，仅仅解释数字123456789101112public class NumExpression extends ArithmeticExpression &#123; private int num; public NumExpression(int num) &#123; this.num = num; &#125; @Override public int interpret() &#123; return num; &#125;&#125; 抽象的运算符解释器，要求传入两个参数进行计算12345678public abstract class OperatorExpression extends ArithmeticExpression &#123; protected ArithmeticExpression exp1,exp2; public OperatorExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; this.exp1 = exp1; this.exp2 = exp2; &#125;&#125; 一个具体的加法运算符,解析出两个参数的和12345678910public class AddExpression extends OperatorExpression &#123; public AddExpression(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; super(exp1, exp2); &#125; @Override public int interpret() &#123; return exp1.interpret()+exp2.interpret(); &#125;&#125; 一个计算类，处理与解析相关的业务12345678910111213141516171819202122232425262728293031public class Calculator &#123; private Stack&lt;ArithmeticExpression&gt; mExp = new Stack&lt;&gt;();//使用的时候在构造方法里传入要计算的字符串。 public Calculator(String expression) &#123; //准备两个解释器 ArithmeticExpression exp1, exp2; //将字符串按空格分割 String[] elements = expression.split(&quot; &quot;); for (int i = 0; i &lt; elements.length; i++) &#123; switch (elements[i].charAt(0)) &#123; case &apos;+&apos;: //如果是’+‘，说明是个运算符，将上一个数和下一个数相加，也就是当前下标i的i-1和i+1相加。 //去除栈中前一次压如的数。也就是这个加号之前的计算结果。 exp1 = mExp.pop(); //取出这个加号后面的数，解析成数字， exp2 = new NumExpression(Integer.valueOf(elements[++i])); //将这两个数进行计算，并将结果压入栈中。 mExp.push(new AddExpression(exp1,exp2)); break; default: //如果是数字，就解析为数字，加入栈中。 mExp.push(new NumExpression(Integer.valueOf(elements[i]))); break; &#125; &#125; &#125; public int calculate()&#123; return mExp.pop().interpret(); &#125;&#125; 客户端调用123456public class Client &#123; public static void main(String[] args) &#123; Calculator calculator = new Calculator(&quot;1 + 2 + 3&quot;); System.out.println(calculator.calculate()); &#125;&#125; 可以看到输出结果是16 如果需要加上减号运算符呢？就子啊实现一个减号的解析器：12345678910public class Subtraction extends OperatorExpression &#123; public Subtraction(ArithmeticExpression exp1, ArithmeticExpression exp2) &#123; super(exp1, exp2); &#125; @Override public int interpret() &#123; return exp1.interpret()-exp2.interpret(); &#125;&#125; 然后在计算的类里加一种判断：12345case &apos;-&apos;: exp1 = mExp.pop(); exp2 = new NumExpression(Integer.valueOf(elements[++i])); mExp.push(new SubtractionExpression(exp1,exp2)); break; 客户端调用123456public class Client &#123; public static void main(String[] args) &#123; Calculator calculator = new Calculator(&quot;1 + 2 + 3 - 1&quot;); System.out.println(calculator.calculate()); &#125;&#125; 可以看到输出结果变成了15 上面只是一个简单的算术运算的解析。根据这个模式，可以增加很多运算法则，只要创建响应的解释器就可以。 由于解释器和文法是一一对应的，所以一个解释器只负责解析一种文法。我们可以为一种文法创建多个解释器，但不能用一个解释器解析多重文法。 解释器值负责解析单个的文法，所以解析树的建立就有距离的使用者去根据实际情况构建了。 总结优点 拓展性很灵活，需要增加新的解释器的时候，直接实现一个新的就行了，然后在实际运用中灵活构建语法树来运用。 缺点 每一个文法都至少对应一个解释器，会产生大量的类，维护困难。 对于复杂的文法，要构建语法书会非常繁琐，甚至需要构建多颗语法树。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（八）-责任链模式","date":"2017-03-31T12:50:39.000Z","path":"2017/03/31/Android设计模式（八）-责任链模式/","text":"责任链模式是一个行为模式。责任链就是从一个起点发起请求，然后沿着任务链依次传递给每一个节点上的对象，直到有一个节点处理这个请求为止。听着是不是跟Android的事件分发机制很像。 定义使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递改请求，直到有对象处理它为止 使用场景 多个对象可以处理统一请求，但具体谁处理在运行时动态决定。 在请求的处理者不明确的情况下，向多个对象的一个提交请求。 需要动态指定一组对象处理请求。 UML简单版 Handler：抽象处理者角色，声明一个处理请求的方法，并保持对下一个处理节点Handler对象的引用。 ConcreteHandler: 具体的处理者，对请求进行处理，如果不处理就讲请求转发给下一个节点上的处理对象。 模板代码： 抽象处理者：1234public abstract class Handler &#123; protected Handler successor; public abstract void handleRequest(String condition);&#125; 实际处理者1234567891011public class ConcreteHandler1 extends Handler &#123; @Override public void handleRequest(String condition) &#123; if (&quot;ConcreteHandler1&quot;.equals(condition))&#123; System.out.println(&quot;ConcreteHandler1 handled&quot;); return; &#125;else &#123; successor.handleRequest(condition); &#125; &#125;&#125; 1234567891011public class ConcreteHandler2 extends Handler &#123; @Override public void handleRequest(String condition) &#123; if (&quot;ConcreteHandler2&quot;.equals(condition)) &#123; System.out.println(&quot;ConcreteHandler2 handled&quot;); return; &#125; else &#123; successor.handleRequest(condition); &#125; &#125;&#125; 客户端调用,组成一条责任链123456789public class Client &#123; public static void main(String[] args) &#123; ConcreteHandler1 concreteHandler1 = new ConcreteHandler1(); ConcreteHandler2 concreteHandler2 = new ConcreteHandler2(); concreteHandler1.successor = concreteHandler2; concreteHandler2.successor = concreteHandler1; concreteHandler1.handleRequest(&quot;ConcreteHandler2&quot;); &#125;&#125; 输出： 复杂版简单版中，传递的都是统一的字符串，处理也比较简单。但是在实际开发中，责任链中的请求处理规则是不尽相同的，这种时候需要对请求进行封装，同时对请求的处理规则也进行一个封装， 类图如下 抽象处理者1234567891011121314151617public abstract class AbstractHandler &#123; protected AbstractHandler nextHandler; public final void handleRequest(AbstractRequest request)&#123; if (request.getRequestLevel()==getHandleLevel())&#123; handle(request); &#125;else &#123; if (nextHandler!=null)&#123; nextHandler.handleRequest(request); &#125;else &#123; System.out.println(&quot;没有对象能处理这个请求&quot;); &#125; &#125; &#125; protected abstract int getHandleLevel(); protected abstract void handle(AbstractRequest request);&#125; 抽象请求者12345678910public abstract class AbstractRequest &#123; private Object obj; public AbstractRequest(Object obj)&#123; this.obj=obj; &#125; public Object getContent()&#123; return obj; &#125; public abstract int getRequestLevel();&#125; 实现的三个请求12345678910public class Request1 extends AbstractRequest &#123; public Request1(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 1; &#125;&#125; 12345678910public class Request2 extends AbstractRequest &#123; public Request2(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 2; &#125;&#125; 12345678910public class Request3 extends AbstractRequest &#123; public Request3(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 3; &#125;&#125; 三个处理者1234567891011public class Handler1 extends AbstractHandler &#123; @Override protected int getHandleLevel() &#123; return 1; &#125; @Override protected void handle(AbstractRequest request) &#123; System.out.println(&quot;Handler1处理了请求：&quot;+request.getRequestLevel()); &#125;&#125; 1234567891011public class Handler2 extends AbstractHandler &#123; @Override protected int getHandleLevel() &#123; return 2; &#125; @Override protected void handle(AbstractRequest request) &#123; System.out.println(&quot;Handler2处理了请求：&quot;+request.getRequestLevel()); &#125;&#125; 1234567891011public class Handler3 extends AbstractHandler &#123; @Override protected int getHandleLevel() &#123; return 3; &#125; @Override protected void handle(AbstractRequest request) &#123; System.out.println(&quot;Handler3处理了请求：&quot;+request.getRequestLevel()); &#125;&#125; 客户端调用12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; //构造三个处理对象 AbstractHandler handler1 = new Handler1(); AbstractHandler handler2 = new Handler2(); AbstractHandler handler3 = new Handler3(); //串成一个责任链 handler1.nextHandler=handler2; handler2.nextHandler=handler3; //构造三个请求 AbstractRequest request1 = new Request1(&quot;A&quot;); AbstractRequest request2 = new Request2(&quot;B&quot;); AbstractRequest request3 = new Request3(&quot;C&quot;); handler1.handleRequest(request1); handler1.handleRequest(request2); handler1.handleRequest(request3); &#125;&#125; 输出 简单实现现实中最适合责任链的应该就是部门领导之间的上报请求了。比如员工要申请一笔资金，会先向组长申请，额度如果在组长的范围内，组长就批了，组长权限不够就向主管申请，主管如果也额度不够就向经理申请。这就形成了个责任链。 组长，主管，经理。每个人都是责任链上的一个节点。一个请求被层层转达，知道被处理或没有一个人能处理。普通员工，就是那个申请的发起者并不需要知道到底最后是谁审批的，他只要拿到钱就行了。这样就造成了请求者和处理者的解耦。 抽象的领导12345678910111213141516public abstract class Leader &#123; protected Leader nextLeader; public final void handleRequest(int money)&#123; if (money&lt;=getLimit())&#123; handle(money); &#125;else &#123; if (nextLeader!=null)&#123; nextLeader.handleRequest(money); &#125;else &#123; System.out.println(money+&quot;没人能批准&quot;); &#125; &#125; &#125; public abstract int getLimit(); public abstract void handle(int money);&#125; 三个具体的领导1234567891011public class GroupLeader extends Leader &#123; @Override public int getLimit() &#123; return 5000; &#125; @Override public void handle(int money) &#123; System.out.println(money+&quot;由组长批准&quot;); &#125;&#125; 1234567891011public class Director extends Leader &#123; @Override public int getLimit() &#123; return 10000; &#125; @Override public void handle(int money) &#123; System.out.println(money+&quot;由主管批准&quot;); &#125;&#125; 1234567891011public class Manager extends Leader &#123; @Override public int getLimit() &#123; return 20000; &#125; @Override public void handle(int money) &#123; System.out.println(money+&quot;由经理批准&quot;); &#125;&#125; 员工申请：1234567891011121314public class A &#123; public static void main(String[] args) &#123; Leader groupLeader = new GroupLeader(); Leader director = new Director(); Leader manager = new Manager(); groupLeader.nextLeader = director; director.nextLeader = manager; groupLeader.handleRequest(5000); groupLeader.handleRequest(9000); groupLeader.handleRequest(12000); groupLeader.handleRequest(30000); &#125;&#125; 输出: 总结优点 降低耦合度，便于拓展，提高代码灵活性。 责任链对象互相链接，只用想头部发起请求。 缺点 如果责任链太长，或者每条链判断处理的时间太长会影响性能。特别是递归循环的时候。 请求不一定能得到处理，可能会没有对象处理。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（七）-状态模式","date":"2017-03-31T02:56:17.000Z","path":"2017/03/31/Android设计模式（七）-状态模式/","text":"状态模式看起来和策略模式很像，但是是两个不一样的设计模式。状态模式是一个类根据内部的状态动态的选择行为。策略模式一般用于算法，通过设置不同的策略类来执行不同的算法。状态模式的一个特点就是行为改变状态，而状态又导致行为的变化。策略模式是可以在运行时外部直接策略的，状态模式一般是不能替换的。 定义允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 使用场景 一个类的状态决定了他的行为，而且在运行时必须根据当前的状态来改变行为。 跟策略模式一样，解决一大堆分支语句的存在。 UML Context:提供供用户调用的方法，内部维护一个State类，定义当前的状态 State：抽象的状态类，定义了每个状态下应该有的行为。 ConcreteState:具体的状态类，定义类各自状态下的具体的不同行为。 简单示例例子还举书上的吧，虽然我感觉这个太像策略模式了。 纯粹是个例子，不是模板，因为见过很多写法。以电视机的状态和遥控器为例。电视机有开和关两种状态，在开的时候可以关机，可以换台。在关的时候只能开机。 定义一个状态接口：定义了开机，关机，换频道123456public interface TvState &#123; void tvOn(Controller controller); void tvOff(Controller controller); void nextChinal(Controller controller); void lastChinal(Controller controller);&#125; 定义一个遥控器：123456789101112131415161718192021222324public class Controller &#123; private TvState state; public Controller(TvState state) &#123; this.state = state; &#125; public void setState(TvState state)&#123; this.state=state; &#125; public void turnOn()&#123; state.tvOn(this); &#125; public void turnOff()&#123; state.tvOff(this); &#125; public void nextChinal()&#123; state.nextChinal(this); &#125; public void lastChinal()&#123; state.lastChinal(this); &#125;&#125; 定义两个状态的实现，开机和关机下点不同的按钮有不同的反应：12345678910111213141516171819202122public class OnState implements TvState &#123; @Override public void tvOn(Controller controller) &#123; &#125; @Override public void tvOff(Controller controller) &#123; System.out.println(&quot;关机&quot;); controller.setState(new OffState()); &#125; @Override public void nextChinal(Controller controller) &#123; System.out.println(&quot;下个频道&quot;); &#125; @Override public void lastChinal(Controller controller) &#123; System.out.println(&quot;上个频道&quot;); &#125;&#125; 12345678910111213141516171819202122public class OffState implements TvState &#123; @Override public void tvOn(Controller controller) &#123; System.out.println(&quot;开机&quot;); controller.setState(new OnState()); &#125; @Override public void tvOff(Controller controller) &#123; &#125; @Override public void nextChinal(Controller controller) &#123; &#125; @Override public void lastChinal(Controller controller) &#123; &#125;&#125; 客户端调用：12345678910111213141516171819public class Mian &#123; public static void main(String[] args) &#123; Controller controller = new Controller(new OffState()); System.out.println(1+&quot;点击上一个频道&quot;); controller.lastChinal(); System.out.println(2+&quot;点击关机&quot;); controller.turnOff(); System.out.println(3+&quot;点击开机&quot;); controller.turnOn(); System.out.println(4+&quot;点击下一个频道&quot;); controller.nextChinal(); System.out.println(5+&quot;点击开机&quot;); controller.turnOn(); System.out.println(6+&quot;点击关机&quot;); controller.turnOff(); System.out.println(7+&quot;点击下一个频道&quot;); controller.nextChinal(); &#125;&#125; 可以看看输出： 在调用的时候，只设置一个初始值，然后控制器内部会根据状态切换行为，然后又由行为切换状态，在不同的状态下按同样的按钮会有不同的效果。 总结状态模式和策略模式都是为了实现解耦，避免一大堆的if-else的写法，但是状态模式更多的是适合不同状态下，同样的行为有不同的相应。根据实际生活来说，这种模式适合有明显的状态区分的时候。比如电视的开，关就是两种状态。而在策略模式中J举得例子就不适合叫状态了。 优点 将所有的状态和该状态的行为封装在同一个实现类中，然后有一个共同的接口，代码结构清晰，便于扩展和修改。 缺点 也是要增加很多类","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（六）-策略模式","date":"2017-03-30T14:02:31.000Z","path":"2017/03/30/Android设计模式（六）-策略模式/","text":"在开发中几女航遇见下面这种情况：实现同一个功能有很多不停的算法和策略，然后根据实际情况来选择不同的算法和策略。 一般的做法是在一个类里写不同的方法，然后根据实际情况用一连串的if-else或switch来选择对应的方法。这种方法多了后，这个类会变得臃肿，难以修改。 所以如果把不同的策略抽象出来，提供一个统一的接口，为每一个策略写一个实现类，这样客户端就能通过调用接口的不同的实现类来动态替换策略。这就是策略模式 定义策略模式定义了一系列的算法，并将一系列算法封装起来，使他们能相互替换。策略模式让算法独立于使用者而独立变化。 使用场景 针对同一类型的问题有多重解决方式，仅仅是具体行为有差异时。让系统可以动态的选择算法策略。 需要安全的封装多重同一类对象时，调用者不会知道算法策略的具体过程。 一个类有多个子类，并且在调用的时候用if或switch判断的时候。 UML 简单实现模拟一下城市交通系统，假设情况如下： 公交：起步2元，超过5公里每公里加1元。 地铁：5公里内3元，5-10公里4元，最多5元。 出租：每公里2元。 先看一下原来的写法写一个类计算并返回价钱：12345678910111213141516171819202122232425262728293031323334353637public class PriceCaculator &#123; public static final int BUS = 1; public static final int SUBWAY = 2; public static final int TAXI =3; private int busPrice(int km)&#123; int busP = 2; if (km&gt;5) busP = busP+km-5; return busP; &#125; private int subwayPrice(int km)&#123; int subwayP=0; if (km&lt;5) subwayP = 3; if (km&gt;5&amp;&amp;km&lt;=10) subwayP=4; if (km&gt;10) subwayP=5; return subwayP; &#125; private int taxiPrice(int km) &#123; return 2 * km; &#125; public int getPrice(int km,int type)&#123; if (type==BUS) return busPrice(km); if (type == SUBWAY) return subwayPrice(km); if (type==TAXI) return taxiPrice(km); return 0; &#125;&#125; 客户端调用，不是重点1234567public class Main &#123; public static void main(String[] args) &#123; PriceCaculator priceCaculator = new PriceCaculator(); int price = priceCaculator.getPrice(10,2); System.out.println(price); &#125;&#125; 可以看到计算价钱那个类已经写了很多了，而且如果要再增加其他交通工具计算方法的话，这个类要增加相应的方法和判断。 使用策略模式先声明一个接口，声明一个计算的方法123public interface CalculateStrategy &#123; int calculatePrice(int km);&#125; 实现三个具体的计算方法12345678910111213141516171819202122232425262728public class BusCalculate implements CalculateStrategy &#123; @Override public int calculatePrice(int km) &#123; int busP = 2; if (km&gt;5) busP = busP+km-5; return busP; &#125;&#125;public class SubwayCalculate implements CalculateStrategy &#123; @Override public int calculatePrice(int km) &#123; int subwayP=0; if (km&lt;5) subwayP = 3; if (km&gt;5&amp;&amp;km&lt;=10) subwayP=4; if (km&gt;10) subwayP=5; return subwayP; &#125;&#125;public class TaxiCalculate implements CalculateStrategy &#123; @Override public int calculatePrice(int km) &#123; return 2 * km; &#125;&#125; 然后看看我们现在的计算类，这个是重点 12345678910public class PriceCalculate2 &#123; private CalculateStrategy calculateStrategy; public void setCalculateStrategy(CalculateStrategy calculateStrategy)&#123; this.calculateStrategy=calculateStrategy; &#125; public int getPrice(int km)&#123; return calculateStrategy.calculatePrice(km); &#125;&#125; 客户端调用,这个不是重点12345678public class Main &#123; public static void main(String[] args) &#123; PriceCalculate2 priceCalculate2 = new PriceCalculate2(); priceCalculate2.setCalculateStrategy(new SubwayCalculate()); int price = priceCalculate2.getPrice(10); System.out.println(price); &#125;&#125; 这里重点就是计算类了，可以看到里面的解法非常简便。而且如果要新增其他算法的话，直接实现一个接口就可以了，其他类都不需要变化。便于之后的升级或扩展。 Android源码中的粗略模式看一下一帮使用属相动画时候的样子：1234Animation animation = new AlphaAnimation(1,0); animation.setInterpolator(new AccelerateDecelerateInterpolator()); imageView.setAnimation(animation); animation.start(); animation.setInterpolator()其实用的就是策略模式，Android中有很多不同的插值器，都实现了Interpolator接口。然后通过setInterpolator设置给Animation。 在动画执行的时候，会通过设置的计时器来在不同的动画时间执行不同的动画效果。 12345678910111213141516171819202122public void setInterpolator(Interpolator i) &#123; mInterpolator = i; &#125;protected void ensureInterpolator() &#123; if (mInterpolator == null) &#123; //默认就是加速度插值器,在Animation初始化的时候执行。 mInterpolator = new AccelerateDecelerateInterpolator(); &#125; &#125;public boolean getTransformation(long currentTime, Transformation outTransformation) &#123; ...... if ((normalizedTime &gt;= 0.0f || mFillBefore) &amp;&amp; (normalizedTime &lt;= 1.0f || mFillAfter)) &#123; ...... //通过策略模式来获取不同的值。 final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime); applyTransformation(interpolatedTime, outTransformation); &#125; ...... &#125; 总结策略模式主要就是为了分离算法和使用，是系统用于很好的拓展性 优点 结构清晰明了，消除了代码中的一大串选择语句，而是分离为一个个独立的类，代码更清晰。 耦合度低，都是基于接口调用和实现，便于拓展和修改。 封装更彻底，数据更安全。 缺点 首先是会产生很多策略类，增加了系统开销。 用户要知道所有的策略类。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（五）-抽象工厂模式","date":"2017-03-30T12:52:56.000Z","path":"2017/03/30/Android设计模式（五）-抽象工厂模式/","text":"在上一篇的工厂模式中中，工厂生产出来的产品都是实现同一个接口或继承同一个抽象类的。而有时候工厂可以生产出不是同一个接口或抽象类的产品，也就是说生产出来的产品是不确定的，就是抽象工厂了。 博客地址 定义为创建一组相关或相互依赖的对象提供一个接口，而无需指定他们的具体类。 使用场景适用于当一组产品族之间有互相约束的时候。它的起源就来与这种模式，期初是解决不同操作系统的图形化解决方案。Windows和Linux是两个系统，可以看出两个产品族，但里面的按钮和文本要统一风格，他们有个字的产品等级。这就有了约束。 由上面可以看出UML图了AbstractFactory：抽象工厂角色，声明了一组用于创建一种产品的方法，每个方法对应生产一种产品，上面生成产品A和B。ConcreteFactory：具体工厂角色，实现了抽象工厂中定义的创建产品的方法，生成一组具体的产品，每一个产品又位于某个产品等级中。AbstractProduct：抽象产品角色，定义了每种产品应有的方法ConcreteProduct：具体的产品角色，具体了工厂生产的具体独享，实现抽象产品中声明的方法。模板抽象工厂：1234public abstract class AbstractFactory &#123; public abstract AbstractProductA createProductA(); public abstract AbstractProductB createProductB();&#125; 具体的工厂1和212345678910111213141516171819202122public class ConcreteFactory1 extends AbstractFactory &#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductA1(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductB1(); &#125;&#125;public class ConcreteFactory2 extends AbstractFactory &#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductA2(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductB2(); &#125;&#125; 抽象的产品A和B 123456public abstract class AbstractProductA &#123; public abstract void method();&#125;public abstract class AbstractProductB &#123; public abstract void method();&#125; 具体的产品A1，A2，B1，B2123456789101112131415161718192021222324public class ConcreteProductA1 extends AbstractProductA &#123; @Override public void method() &#123; System.out.println(&quot;产品A1的方法&quot;); &#125;&#125;public class ConcreteProductA2 extends AbstractProductA &#123; @Override public void method() &#123; System.out.println(&quot;产品A2的方法&quot;); &#125;&#125;public class ConcreteProductB1 extends AbstractProductB &#123; @Override public void method() &#123; System.out.println(&quot;产品B1的方法&quot;); &#125;&#125;public class ConcreteProductB2 extends AbstractProductB &#123; @Override public void method() &#123; System.out.println(&quot;产品B2的方法&quot;); &#125;&#125; 简单实现还是以车为例，上一次的奥迪用工厂模式生产了Q3，Q7，但是他们的零件又有差别，Q3的发动机是国产的，轮胎是铁的。Q7的发动机是外国的，轮胎是塑料的。不同的轮胎，不同的发动机，都也是一种产品类型，这时候就能用抽象产品模式：汽车首先由生产轮胎，发动机，然后组装成汽车。抽象的工厂类声明要生产两种产品：1234public abstract class CarFactory &#123; public abstract ITire createTire(); public abstract IEngine createEngine();&#125; 轮胎类：123456789101112131415interface ITire &#123; void tire();&#125;public class FerricFTire implements ITire &#123; @Override public void tire() &#123; System.out.println(&quot;铁轮胎&quot;); &#125;&#125;public class PlasticTire implements ITire &#123; @Override public void tire() &#123; System.out.println(&quot;塑料轮胎&quot;); &#125;&#125; 引擎类：123456789101112131415interface IEngine &#123; void engine();&#125;public class DomesticEngine implements IEngine &#123; @Override public void engine() &#123; System.out.println(&quot;国产引擎&quot;); &#125;&#125;public class ImportIEngine implements IEngine &#123; @Override public void engine() &#123; System.out.println(&quot;进口引擎&quot;); &#125;&#125; 具体工厂类1234567891011121314151617181920212223public class Q3Factory extends CarFactory &#123; @Override public ITire createTire() &#123; return new FerricFTire(); &#125; @Override public IEngine createEngine() &#123; return new DomesticEngine(); &#125;&#125;public class Q7Factory extends CarFactory &#123; @Override public ITire createTire() &#123; return new PlasticTire(); &#125; @Override public IEngine createEngine() &#123; return new ImportIEngine(); &#125;&#125; 客户端调用：1234567891011public class Client &#123; public static void main(String[] args) &#123; CarFactory Q3 = new Q3Factory(); Q3.createEngine().engine(); Q3.createTire().tire(); System.out.println(&quot;===&quot;); CarFactory Q7 = new Q7Factory(); Q7.createEngine().engine(); Q7.createTire().tire(); &#125;&#125; 输出：12345国产引擎铁轮胎===进口引擎塑料轮胎 总结抽象工厂模式用的并不多，它和简单工厂和工厂模式的行为很相近，一般在开发中用工厂模式就可以解决问题。而且这几种模式之间可以很隐晦的转换，所以在用的时候不用特别在意是哪一种工厂模式，只要能达到解耦的目的就行 优点 也是实现了解耦，客户按抽象工厂进行生产，不需要知道具体的实现是谁。 但是在产品等级上加了一个约束，便于管理。缺点要新家一个产品的时候要改动非常多的对象，而且要新增一大堆的文件。因为每增加一个产品都要修改抽象类，所以他的实现类也要进行相应的修改。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（四）续：Activity的onCreate是怎么调用的","date":"2017-03-30T12:52:02.000Z","path":"2017/03/30/Android设计模式（四）续：Activity的onCreate是怎么调用的/","text":"这里分析的是app第一次启动时的第一个Activity的onCreate()方法的启动流程。 图先贴一下大致的流程图吧，不会画，很丑 ActivityThread.main()APP的启动入口应该都知道是ActivityThread的main方法了，所以整个APP的启动就从这里开始，直到我们看到首页。代码不多：1234567891011121314151617181920212223242526package android.app;public final class ActivityThread &#123; public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); CloseGuard.setEnabled(false); Environment.initForCurrentUser(); EventLogger.setReporter(new EventLoggingReporter()); final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125;&#125; 其实通过这个代码我们可以发现一个有趣的现象,APP可以一直运行不会退出就因为这个main方法最后的Looper.loop()是个死循环。 当一个APP启动的时候，系统会从Zygone线程中为应用fork一个新的线程，然后在线程中执行ActivityThread的main方法。main方法中主要流程就是： 准备一个主线程的Looper 新建一个ActivityThread，并执行他的attach方法 开启Looper的loop方法开始无限循环的读取消息队列的消息 并处理。ActivityThread.attach(false)下面看一下ActivityThread.attach()，在main()中传入的参数是FALSE，说明这个APP不是系统APP。所以我们主要就看不是系统APP的处理。12345678910111213141516171819202122232425private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123;//不是系统APP ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123;//确定虚拟机正常 ensureJitEnabled(); &#125; &#125;); //.....略//获取一个ActivityManagerService AMS final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123;//mAppThread = new ApplicationThread(),绑定到AMS上 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; //......略 &#125; else &#123; //.....略 &#125; ActivityManagerNative.getDefault()就是获取一个AMS,从下面的代码可以看到用的是单例模式从SystemManager中获取到。1234567891011121314151617181920package android.app;public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; static public IActivityManager getDefault() &#123; return gDefault.get(); &#125; private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123;//获取AMS IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); &#125; return am; &#125; &#125;;&#125; (AMS)mgr.attachApplication()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.android.server.am;public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; @Override public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity();//执行AMS的这个方法 attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125; &#125; private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; //......略 try &#123; ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);//执行了ApplicationThread的bindApplication方法 thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); //..... &#125; catch (Exception e) &#123; //...... &#125; // See if the top visible activity is waiting to run in this process... if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; &#125; &#125; return true; &#125;&#125; 这里 主要看两个方法，thread.bindApplication(……)方法和mStackSupervisor.attachApplicationLocked(app)。ApplicationThread是ActivityThread的内部类，里面主要还是把这个ApplicationThread绑定到AMS中。mStackSupervisor是一个ActivityStackSupervisor类，在AMS创建的时候初始化。 mStackSupervisor.attachApplicationLocked(app)下面看他的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.android.server.am;public final class ActivityStackSupervisor implements DisplayListener &#123; boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123;//看这个方法就知道是真正启动一个Activity if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, &quot;Exception in new application when starting activity &quot; + hr.intent.getComponent().flattenToShortString(), e); throw e; &#125; &#125; &#125; &#125; &#125; if (!didSomething) &#123; ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; return didSomething; &#125; final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123;//这个传进来是true,所以一定会进去 if (andResume) &#123;//冻结尚未启动的其他APP r.startFreezingScreenLocked(app, 0); mWindowManager.setAppVisibility(r.appToken, true); // 搜集启动比较慢的APP的信息 r.startLaunchTickingLocked(); &#125; final ActivityStack stack = task.stack; try &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;ReferrerIntent&gt; newIntents = null; if (andResume) &#123; results = r.results; newIntents = r.newIntents; &#125; //... if (r.isHomeActivity())&#123;//如果是桌面的activity，就加到栈底 mService.mHomeProcess = task.mActivities.get(0).app; &#125; //。。。。 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); &#125; catch (RemoteException e) &#123; &#125; &#125; return true; &#125;&#125; 上面的方法里一大堆代码，主要就是检查准备要启动的Activity的信息，信息正常的话就执行 app.thread.scheduleLaunchActivity(…..)方法。然后就又回到了ApplicationThread： ApplicationThread.scheduleLaunchActivity(…..)12345678910111213141516171819202122232425262728293031323334353637package android.app;public final class ActivityThread &#123; private class ApplicationThread extends ApplicationThreadNative &#123; @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; &#125;&#125; 里面创建了一个ActivityClientRecord来保存activity的各种信息，然后放在消息里发送给H，消息的标识是H.LAUNCH_ACTIVITY，消息的内容就是这个ActivityClientRecord。H也是ActivityThread的一个内部类： ActivityThread.H123456789101112131415private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; &#125; &#125;&#125; 这个handler接收到LAUNCH_ACTIVITY的信息后，会调用handleLaunchActivity(…)方法 ActivityThread.handleLaunchActivity(r, null, “LAUNCH_ACTIVITY”);12345private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; //..... Activity a = performLaunchActivity(r, customIntent);//..... &#125; ActivityThread.performLaunchActivity(r, customIntent)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //获取activity的信息 ActivityInfo aInfo = r.activityInfo; //...对信息进行一些判断 略 Activity activity = null; try &#123;//通过反射获取到activity类 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123;//如果没在清单里注册就会出现这个错误，应该都遇见过吧。。 throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123;//获取application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123;//生成activity的Context Context appContext = createBaseContextForActivity(r, activity); //....略//将activity绑定到application activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //...略//调用callActivityOnCreate方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; &#125; &#125; catch (SuperNotCalledException e) &#123; &#125; return activity; &#125; 继续 Instrumentation.callActivityOnCreate12345678package android.app;public class Instrumentation &#123; public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); &#125;&#125; 是不是终于看到了activity的方法，马上就到了 activity.performCreate(icicle);1234567891011121314package android.app;public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback &#123; final void performCreate(Bundle icicle) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); &#125;&#125; 看到没，执行到了onCreate方法，还有一些生命周期的方法也是这样的逻辑，包括service和广播。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（四）- 工厂方法模式","date":"2017-03-30T12:51:02.000Z","path":"2017/03/30/Android设计模式（四）-工厂方法模式/","text":"工厂方法模式也是创建型模式。工厂模式根据抽象程度可以分为三种：简单工厂模式，工厂方法模式，抽象工厂模式。 博客地址 定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。 使用场景任何需要生成复杂对象的地方，都可以使用工厂方法模式。用new就能创建的对象不需要使用工厂模式，因为使用工厂模式就要增加一个工厂类，增加了系统复杂度。 UML 模式1抽象的产品：123public abstract class Product &#123; public abstract void method();&#125; 具体的产品：123456789101112public class ConcreteProductA extends Product &#123; @Override public void method() &#123; System.out.println(&quot;产品A&quot;); &#125;&#125;public class ConcreteProductB extends Product &#123; @Override public void method() &#123; System.out.println(&quot;产品B&quot;); &#125;&#125; 抽象的工厂：123public abstract class Factory &#123; public abstract Product createProduct();&#125; 具体的工厂：123456public class ConcreteFactory extends Factory &#123; @Override public Product createProduct() &#123; return new ConcreteProductA(); &#125;&#125; 客户端使用:1234567public class Client &#123; public static void main(String[] args) &#123; Factory factory = new ConcreteFactory(); Product product = factory.createProduct(); product.method(); &#125;&#125; 这样就生产出来一个ConcreteProductA。如果想生产ConcreteFactory，在ConcreteFactory里修改为返回ConcreteFactory就行了。123456public class ConcreteFactory extends Factory &#123; @Override public Product createProduct() &#123; return new ConcreteProductB(); &#125;&#125; 模式2通过反射来了解要生产哪个产品抽象工厂：123public abstract class Factory &#123; public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz);&#125; 具体工厂：12345678910111213141516public class ConcreteFactory extends Factory &#123; @Override public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clz) &#123; Product product = null; try &#123; product= (Product) Class.forName(clz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return (T) product; &#125;&#125; 客户端调用：1234567public class Client &#123; public static void main(String[] args) &#123; Factory factory = new ConcreteFactory(); Product product = factory.createProduct(ConcreteProductB.class); product.method(); &#125;&#125; 这样，客户端调用的时候，传入什么产品就生产什么产品。 模式3可以为每个产品都创建一个具体的工厂类，如：123456789101112public class ConcreteFactoryA extends Factory &#123; @Override public Product createProduct() &#123; return new ConcreteProductA(); &#125;&#125;public class ConcreteFactoryB extends Factory &#123; @Override public Product createProduct() &#123; return new ConcreteProductA(); &#125;&#125; 要生产哪个就调用哪个工厂。 这种叫多工厂方法模式。 简单工厂模式（静态工厂模式）当确定工厂类只有一个的时候，123456public class Factory&#123; public static Product createProduct()&#123; return new ConcreteProductA(); //return new ConcreteProductB(); &#125;&#125; 简单实现以汽车举个例子，抽象的汽车厂：123public abstract class AodiFactory &#123; public abstract &lt;T extends AodiCar&gt; T createAudiCar(Class&lt;T&gt; clz);&#125; 具体的汽车生产工厂：123456789101112public class AodiCarFactory extends AodiFactory &#123; @Override public &lt;T extends AodiCar&gt; T createAudiCar(Class&lt;T&gt; clz) &#123; AodiCar aodiCar = null; try &#123; aodiCar = (AodiCar) (Class.forName(clz.getName())).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) aodiCar; &#125;&#125; 抽象的汽车：1234public abstract class AodiCar &#123; public abstract void diver(); public abstract void selfNav();&#125; 具体的汽车：12345678910111213141516171819202122public class AodiQ3 extends AodiCar &#123; @Override public void diver() &#123; System.out.println(&quot;Q3启动&quot;); &#125; @Override public void selfNav() &#123; System.out.println(&quot;Q3导航&quot;); &#125;&#125;public class AodiQ5 extends AodiCar &#123; @Override public void diver() &#123; System.out.println(&quot;Q5启动&quot;); &#125; @Override public void selfNav() &#123; System.out.println(&quot;Q5导航&quot;); &#125;&#125; 客户端调用：1234567891011public class Client &#123; public static void main(String[] args) &#123; AodiFactory aodiFactory = new AodiCarFactory(); AodiCar Q3 = aodiFactory.createAudiCar(AodiQ3.class); Q3.diver(); Q3.selfNav(); AodiCar Q5 = aodiFactory.createAudiCar(AodiQ5.class); Q5.diver(); Q5.selfNav(); &#125;&#125; Android源码中的工厂方法书中举例是Activity的onCreate()方法，理由是：在不同的Activity的onCreate方法中调用setContentView会根据设置的不同的布局文件而产生不同的布局，所以可以看做是一个工厂。 个人觉得有点牵强吧。。。不知道你们怎么看呢？ 有个很明显的BitmapFactory，应该是符合简单工厂模式的：123456789package android.graphics;public class BitmapFactory &#123; public static Bitmap decodeFile(String pathName, Options opts) &#123; Bitmap bm = null; ...... return bm; &#125; //有很多静态方法返回一个Bitmap对象。&#125; 总结优点 降低了对象之间的耦合度，代码结构清晰，对调用者隐藏了产品的生产过程，生产过程改变后，调用者不用做什么改变，易于修改。 易于拓展，要增加工厂和产品都非常方便，直接实现接口，不用修改之前的代码。缺点缺点应该就是会让系统结构复杂化了，如果是非常简单的结构就不需要使用这种模式了。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（三）- 原型模式","date":"2017-03-30T12:49:03.000Z","path":"2017/03/30/Android设计模式（三）-原型模式/","text":"博客地址原型模式也是一种创建型设计模式，从名字就能理解，这个模式应该有一个样板实例，也就是原型，然后用户从这个原型中复制出一个内部属性一致的实例，也就是克隆。有时，一个对象的构造比较复杂并且比较耗时时，直接从已有对象复制一个实例比重新构造出来更高效。 定义用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 使用场景 对象的初始化要消耗非常多的资源，包括硬件，数据等。可以使用原型模式避免这种资源的消耗。 用new来实例化一个对象时需要非常繁琐的数据准备或访问权限时，可以使用原型模式。 一个对象要供其他对象访问，而每个调用者都可能会修改他的值，这时可以考虑用原型模式拷贝多个原型的对象供各个调用者使用，不互相影响，即保护性拷贝。 需要频繁的创建相似的对象时，比如在一个循环中创建对象。 这里说明一下，使用clone产生实例并不一定都比new来的快，当一些对象的构造非常简单时，new是比clone还快的。但是当对象的构造复杂起来的时候用new构造就会造成较大的成本，这时clone才能体现出效率的优势。 UML类图其中Prototype不一定非要实现Cloneable接口，在演示的时候会有两种。 简单实现使用Cloneable接口原型,实现Cloneable接口：12public class Prototype implements Cloneable&#123; &#125; 原型的实现：12345678910111213141516171819202122232425public class ConcretePrototype extends Prototype &#123; public String name; public ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); public ConcretePrototype() &#123; System.out.println(&quot;执行了ConcretePrototype构造函数&quot;); &#125; @Override public ConcretePrototype clone() &#123; ConcretePrototype prototype = null; try &#123; prototype = (ConcretePrototype) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return prototype; &#125; @Override public String toString() &#123; return &quot;ConcretePrototype&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, list=&quot; + list + &apos;&#125;&apos;; &#125;&#125; 使用：12345678910111213public class MainM &#123; public static void main(String[] args) &#123; ConcretePrototype concretePrototype = new ConcretePrototype(); concretePrototype.name=&quot;yuanxing&quot;; concretePrototype.list.add(&quot;yuanxing1&quot;); concretePrototype.list.add(&quot;yuanxing2&quot;); concretePrototype.list.add(&quot;yuanxing3&quot;); ConcretePrototype cloneConcretePrototype = (ConcretePrototype) concretePrototype.clone(); cloneConcretePrototype.name = &quot;clone&quot;; System.out.println(concretePrototype.toString()); System.out.println(cloneConcretePrototype.toString()); &#125;&#125; 输出：通过clone方法获得一个实例，而且修改这个实例的内容并不会影响原来的实例的内容。当然，这样也只是对基本数据类型有效。 不实现Cloneable接口原型：12public class Prototype1 &#123;&#125; 原型的实现：123456789101112131415161718192021public class ConcretePrototype1 extends Prototype1 &#123; public String name; public ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); public ConcretePrototype1() &#123; System.out.println(&quot;执行了ConcretePrototype构造函数&quot;); &#125; public ConcretePrototype1 clone() &#123; ConcretePrototype1 prototype1 = new ConcretePrototype1() ; prototype1.name = this.name; prototype1.list=this.list; return prototype1; &#125; @Override public String toString() &#123; return &quot;ConcretePrototype1&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, list=&quot; + list + &apos;&#125;&apos;; &#125;&#125; 使用：12345678910111213public class MainM &#123; public static void main(String[] args) &#123; ConcretePrototype1 concretePrototype1 = new ConcretePrototype1(); concretePrototype1.name=&quot;yuanxing&quot;; concretePrototype1.list.add(&quot;yuanxing1&quot;); concretePrototype1.list.add(&quot;yuanxing2&quot;); concretePrototype1.list.add(&quot;yuanxing3&quot;); ConcretePrototype1 cloneconcretePrototype1 = (ConcretePrototype1) concretePrototype1.clone(); cloneconcretePrototype1.name=&quot;clone&quot;; System.out.println(concretePrototype1.toString()); System.out.println(cloneconcretePrototype1.toString()); &#125;&#125; 输出的结果是有点不一样的:直接调用Cloneable的方法是不会再次调用构造方法的，而自己new是一定会调用构造方法的。我个人觉得这个应该是伪克隆吧，只是写了一个clone的方法，然后在方法中new出一个对象，然后要手动把自己本来的值赋值给新的对象。 问题上面两个都测试了name这个属性，如果在克隆的对象里修改了ArrayList对象list会怎样呢？来试试：使用：1234567891011121314public class MainM &#123; public static void main(String[] args) &#123; ConcretePrototype concretePrototype = new ConcretePrototype(); concretePrototype.name=&quot;yuanxing&quot;; concretePrototype.list.add(&quot;yuanxing1&quot;); concretePrototype.list.add(&quot;yuanxing2&quot;); concretePrototype.list.add(&quot;yuanxing3&quot;); ConcretePrototype cloneConcretePrototype = (ConcretePrototype) concretePrototype.clone(); cloneConcretePrototype.name = &quot;clone&quot;; cloneConcretePrototype.list.add(&quot;clone1&quot;); System.out.println(concretePrototype.toString()); System.out.println(cloneConcretePrototype.toString()); &#125;&#125; 发现输出并不是预期的：修改了克隆出来的对象的list，原型中的list的值也变了。 深拷贝-浅拷贝之所以会出现上面的情况，是因为上面的原型中使用的是浅拷贝。Cloneable的方法clone默认就是浅拷贝，浅拷贝并不是把所有字段都重新构造了一份，而是引用了原型中的字段。对于值类型，也就是基本数据类型来说，还有String类型，clone方法会进行一个拷贝，可以让拷贝的对象和原型互不干扰。但是对于引用类型（对象，集合，数组等）来说，clone方法只是让他们指向了同一个内存地址，所以修改其中一个的内容，两个都会变化。所以对于不是基本类型的属性，在clone的时候要手动调用引用对象的clone方法进行拷贝，也就是深拷贝。把重写的clone方法加上深拷贝1234567891011@Override public ConcretePrototype clone() &#123; ConcretePrototype prototype = null; try &#123; prototype = (ConcretePrototype) super.clone(); prototype.list = (ArrayList&lt;String&gt;) this.list.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return prototype; &#125; 然后就会得到我们期望的输出： Android源码中的原型模式：原型模式可能很少单独使用吧，在书中的例子举了个Intent，虽然实现了Cloneable接口，但在clone方法中是直接new的一个Intent，把原型传进去，然后复制给新的Intent：12345678910111213141516171819202122232425262728293031323334package android.content;public class Intent implements Parcelable, Cloneable &#123; /** * 拷贝构造函数 */ public Intent(Intent o) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;String&gt;(o.mCategories); &#125; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125; &#125; @Override public Object clone() &#123; return new Intent(this); &#125; &#125; 这里可能考虑的就是直接new比clone快吧。。 总结原型模式主要就是拷贝对象，拷贝对象一般有两个作用 保护原型不被修改，只给外部提供一个拷贝以供访问，保护性拷贝。 避免构造复杂的对象时的资源消耗问题，提升创建对象的效率。 优点 Object的clone方法是一个本地方法，直接操作的是二进制流，性能会好很多。缺点 构造方法在clone的时候不会执行，既是优点也是缺点，使用时要注意这个潜在的问题。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（二） 续：WindowManager","date":"2017-03-30T12:48:06.000Z","path":"2017/03/30/Android设计模式（二）-续：WindowManager/","text":"博客地址通过前面的分析可以知道，Android系统中，所有的界面内容显示都是通过Window来实现的，包括Activity，Dialog，Toast等。先初步分析一下Window，WindowManager，WindowManagerService的关系。 获取WindowManager从Android设计模式（一）-单例模式中后面的内容可以看到，系统在启动的时候就注册了许多服务。其中就有这样的代码：12345678910111213package android.app;final class SystemServiceRegistry &#123;...... static &#123;...... registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() &#123; @Override public WindowManager createService(ContextImpl ctx) &#123; return new WindowManagerImpl(ctx); &#125;&#125;); &#125;&#125; 这样就创建了一个WindowManager，而且也能看出来WindowManager的实现类是WindowManagerImpl。同理，要获得一个WindowManager也很简单了：1WindowManager manager = (WindowManager) getSystemService(Context.WINDOW_SERVICE); Dialog的显示从头开始分析，先看AlertDialog的构造方法：1234567AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = AlertController.create(getContext(), this, getWindow()); &#125; 调用了父类Dialog的构造方法：123456789101112131415Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; ......//获取WindowManager mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);//创建一个PhonwWindow final Window w = new PhoneWindow(mContext); mWindow = w;//设置回调 w.setCallback(this); w.setOnWindowDismissedCallback(this);//设置WindowManager w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); &#125; Window通过调用他的w.setWindowManager(mWindowManager, null, null)将WindowManager和Window联系起来。：123456789101112package android.view;public abstract class Window &#123; ...... public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; ...... if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125;&#125; 最后一句代码很重要mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);，调用了WindowManagerImpl的createLocalWindowManager方法，这个方法里就一行代码123public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow); &#125; 这里重新创建了一个WindowManagerImpl，但是参数比系统注册的时候多了一个构造参数parentWindow。这说明这个WindowManagerImpl是跟一个具体的Window绑定起来的。123456789101112131415161718192021222324252627282930313233343536373839package android.view;public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow;...... private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow; &#125;...... public void setDefaultToken(IBinder token) &#123; mDefaultToken = token; &#125; @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params); &#125; ...... @Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125; @Override public void removeViewImmediate(View view) &#123; mGlobal.removeView(view, true); &#125;...... @Override public Display getDefaultDisplay() &#123; return mContext.getDisplay(); &#125;&#125; 从中 很明显的可以看出真正实现一些关键方法如addview 、remoteView等方法的也不是WindowManagerImpl，而是在内部交给了WindowManagerGlobal，由WindowManagerGlobal来真正实现。 然后看一下真正的addView吧：12345678910111213141516171819202122232425262728293031package android.view;public final class WindowManagerGlobal &#123; private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... //创建ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams);//添加到列表中 mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // 最后执行这个，将View显示在手机屏幕上 try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; ...... &#125; &#125;&#125; ViewRootImplnew ViewRootImpl(view.getContext(), display);上面的方法中先是new了一个ViewRootImpl，然后调用他的setView来显示布局。Android中的View都是通过ViewRootImpl来完成绘制的。 书中说这个类继承Handler ,可能是以前是这样吧，我看的源码不是这样的12345678910111213package android.view;public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.HardwareDrawCallbacks &#123; public ViewRootImpl(Context context, Display display) &#123; mContext = context;//获取IWindowSession，与WindowManagerService建立连接 mWindowSession = WindowManagerGlobal.getWindowSession(); ......//这里保存当前线程 mThread = Thread.currentThread(); ...... &#125;&#125; 继续追踪WindowManagerGlobal.getWindowSession()：1234567891011121314151617181920212223242526272829303132333435public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance();//获取WindowManagerService IWindowManager windowManager = getWindowManagerService();//与系统的WindowManagerService建立一个IWindowSession sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125; &#125;public static IWindowManager getWindowManagerService() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowManagerService == null) &#123;//这里返回的是IBinder对象，进行IPC通信 sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(&quot;window&quot;)); ...... &#125; return sWindowManagerService; &#125; &#125; 继续看 sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(“window”));这行：12345678910111213141516package android.os;public final class ServiceManager &#123; public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;error in getService&quot;, e); &#125; return null; &#125;&#125; 所以IWindowManager.Stub.asInterface( ServiceManager.getService(“window”));得到的是一个IBinder对象。 到这里，在ServiceManager的getService方法中通过getIServiceManager().getService(“window”)获取到一个IBinder，与WMS建立初步连接。然后通过IWindowManager.Stub.asInterface方法将IBinder转换成IWindowManager对象。通过这个对象调用openSession打开一个Session，实现通话。 但是，WMS只负责管理View的z-order，也就是管理当前那个View在最上层显示，并不管理绘制。 setView(view, wparams, panelParentView);既然addView就肯定要把view显示在屏幕上，那么绘制View的任务就在ViewRootImpl的setView方法中。123456789101112131415161718public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; ......//请求绘制View requestLayout(); ...... int res; /* = WindowManagerImpl.ADD_OKAY; */ try &#123; ......//请求WindowManagerService，让WMS实现Window的添加。 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; ...... &#125; &#125; setView主要做了两件事：（1）requestLayout();（2）向WMS请求添加Window； requestLayout();12345678@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 这里我另外注意一下checkThread()这个方法。123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125; &#125; 是不是看到了熟悉的异常提示？这个方法要判断当前更新UI 的线程是不是创建ViewRootImpl时的线程，只有在创建ViewRootImpl的线程中更新对应的UI才不会报错。所以不能在子线程中更新UI也是这个原因。 回到requestLayout()，查看scheduleTraversals();12345678void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; ...... mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ...... &#125; &#125; 这里的mTraversalRunnable是个Runnable对象，mChoreographer.postCallback最终会通过一个handler把这个任务发送出去：123456final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; 看doTraversal();123456789void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);...... performTraversals();...... &#125; &#125; 看performTraversals();这个方法里将近一千行代码,大致是四个过程：123456private void performTraversals()&#123; // 1 获取Surface对象，用于图形绘制 //2 测量整个视图树中各个View的大小，用performMeasure方法 //3 布局整个视图树，用performLayout方法 //4 绘制整个视图树，用performDraw方法&#125; 在第四步中，performDraw方法里会调用ViewRootImpl的draw()方法。 draw()中获取到绘制表面Surface，里面最后调用ViewRootImpl的drawSoftware方法，调用GPU绘图。123456789101112131415161718192021222324252627282930313233private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; final Canvas canvas; try &#123;//获取canvas canvas = mSurface.lockCanvas(dirty); // TODO: Do this in native canvas.setDensity(mDensity); &#125; catch (Surface.OutOfResourcesException e) &#123; &#125; try &#123; if (!canvas.isOpaque() || yoff != 0 || xoff != 0) &#123; canvas.drawColor(0, PorterDuff.Mode.CLEAR); &#125; try &#123; ......//从这里开始绘制整个视图树，从DecorView开始 mView.draw(canvas); &#125; finally &#123; ...... &#125; &#125; finally &#123; try &#123;//解锁canvas，并通知SurfaceFlinger更新这块区域。 surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; ...... &#125; &#125; return true; &#125; 综上所述，视图树的绘制主要有以下步骤：（1）判断使用CPU还是GPU绘制（2）获取绘制表面Surface对象（3）通过Surface对象获取并锁住绘图对象（4）从DecorView开始绘制整个视图树（5）解锁Canvas，并通知SurfaceFlinger更新这块区域。 注意Dialog的使用，系统级弹窗在创建AlertDialog时，如果传入的Context是ApplicationContext而不是Activity的Context，那么抛出一个异常：1234Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application at android.view.ViewRootImpl.setView(ViewRootImpl.java:583) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:313) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:86) 看出出错的地方是ViewRootImpl中的setView方法中。在这个方法中，调用mWindowSession.addToDisplay发送添加View的请求后会返回一个数值。然后对这个数值进行判断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int res; res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123; mAttachInfo.mRootView = null; mAdded = false; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); switch (res) &#123; case WindowManagerGlobal.ADD_BAD_APP_TOKEN: case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN: throw new WindowManager.BadTokenException( &quot;Unable to add window -- token &quot; + attrs.token + &quot; is not valid; is your activity running?&quot;); case WindowManagerGlobal.ADD_NOT_APP_TOKEN: throw new WindowManager.BadTokenException( &quot;Unable to add window -- token &quot; + attrs.token + &quot; is not for an application&quot;); case WindowManagerGlobal.ADD_APP_EXITING: throw new WindowManager.BadTokenException( &quot;Unable to add window -- app for token &quot; + attrs.token + &quot; is exiting&quot;); case WindowManagerGlobal.ADD_DUPLICATE_ADD: throw new WindowManager.BadTokenException( &quot;Unable to add window -- window &quot; + mWindow + &quot; has already been added&quot;); case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED: // Silently ignore -- we would have just removed it // right away, anyway. return; case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON: throw new WindowManager.BadTokenException(&quot;Unable to add window &quot; + mWindow + &quot; -- another window of type &quot; + mWindowAttributes.type + &quot; already exists&quot;); case WindowManagerGlobal.ADD_PERMISSION_DENIED: throw new WindowManager.BadTokenException(&quot;Unable to add window &quot; + mWindow + &quot; -- permission denied for window type &quot; + mWindowAttributes.type); case WindowManagerGlobal.ADD_INVALID_DISPLAY: throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot; + mWindow + &quot; -- the specified display can not be found&quot;); case WindowManagerGlobal.ADD_INVALID_TYPE: throw new WindowManager.InvalidDisplayException(&quot;Unable to add window &quot; + mWindow + &quot; -- the specified window type &quot; + mWindowAttributes.type + &quot; is not valid&quot;); &#125; throw new RuntimeException( &quot;Unable to add window -- unknown error code &quot; + res); &#125; 通过异常提示可以看出，异常的原因是应用没有token造成的。而token一般只有activity才有，所以要传入activity的context才行。 有一个特殊的对话框不需要传入activity，那就是系统对话框。不传入activity的context也能正常弹出系统对话框。使用过程： 在AndroidManifest.xml中加上权限 1&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; 然后在调用dialog.show()之前加上下面一句 1alertDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR); 系统的type有很多都可以用，TYPE_SYSTEM_ERROR，TYPE_SYSTEM_OVERLAY都可以。 有些手机需要对这个应用开启悬浮窗权限才能看见这个应用弹出的系统级对话框。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（二）- Builder模式","date":"2017-03-30T12:47:16.000Z","path":"2017/03/30/Android设计模式（二）-Builder模式/","text":"博客地址Builder模式是一步一步创建复杂对象的创建型模式。允许用户在不知道内部构建细节的情况下，可以更精细的控制构造流程。该模式是为了将构建过程和表示分开，使构建过程和部件都可以自由扩展，两者的耦合度也降到最低。 定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 #使用场景 相同的方法，不同的执行顺序，产生不同的结果。 多个部件或零件都可以装配到一个对象中，但产生的运行结果又不相同时。 产品类非常复杂，或者构建部件的顺序不同产生了不同的作用。 当初始化一个对象特别复杂时，如参数特别多且很多参数都有默认值的时UML类图角色介绍： Product 产品的抽象类 Builder 抽象的Builder类，规范产品的组建，一般由子类实现具体的构建过程 ConcreteBuilder 具体的Builder类 Director 统一组装类，导演类 简单实现书中以计算机举了个例子 先创建计算机的抽象类 123456789101112131415161718192021222324252627282930313233343536public abstract class Computer &#123; /** * 主板 */ protected String mBoard; /** * 显示器 */ protected String mDisplay; /** * 系统 */ protected String mOS; protected Computer() &#123; &#125; public void setmBoard(String mBoard) &#123; this.mBoard = mBoard; &#125; public void setmDisplay(String mDisplay) &#123; this.mDisplay = mDisplay; &#125; public abstract void setmOS(); @Override public String toString() &#123; return &quot;Computer&#123;&quot; + &quot;mBoard=&apos;&quot; + mBoard + &apos;\\&apos;&apos; + &quot;, mDisplay=&apos;&quot; + mDisplay + &apos;\\&apos;&apos; + &quot;, mOS=&apos;&quot; + mOS + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 创建计算机的一个实现类 苹果计算机 123456789public class Macbook extends Computer &#123; public Macbook() &#123; &#125; @Override public void setmOS() &#123; mOS=&quot;macOS&quot;; &#125;&#125; 创建builder的抽象类，规范产品的组建 123456public abstract class Builder &#123; public abstract Builder buildBoard(String board); public abstract Builder buildDisplay(String display); public abstract Builder buildOS(); public abstract Computer create();&#125; 创建具体的Builder类，实现苹果计算机的组装 1234567891011121314151617181920public class MacbookBuilder extends Builder &#123; private Computer mComputer = new Macbook();//这里的方法返回builder本身，可以链式调用 @Override public Builder buildBoard(String board) &#123; mComputer.setmBoard(board); return this; &#125; @Override public Builder buildDisplay(String display) &#123; mComputer.setmDisplay(display); return this; &#125; @Override public Builder buildOS() &#123; mComputer.setmOS(); return this; &#125; //调用这个方法生成最终的产品12345 @Override public Computer create() &#123; return mComputer; &#125;&#125; 导演类12345678910111213public class Director &#123; Builder mBuilder = null; public Director(Builder mBuilder) &#123; this.mBuilder = mBuilder; &#125;//使用导演类的话只要传参数就行，然后用传入的builder创建产品。 public void construct(String board,String display)&#123; mBuilder.buildBoard(board); mBuilder.buildDisplay(display); mBuilder.buildOS(); &#125;&#125; -使用示例12345678910111213141516public class MainM &#123; public static void main(String[] args) &#123; Builder builder = new MacbookBuilder();//不适用导演类直接创建,通常都用这样的方式 Computer computer =builder.buildBoard(&quot;huashuo&quot;) .buildOS() .buildDisplay(&quot;sanxing&quot;) .create(); System.out.println(computer.toString());//使用导演类创建 Director director = new Director(builder); director.construct(&quot;weixing&quot;,&quot;dell&quot;); Computer computer1 = builder.create(); System.out.println(computer1); &#125;&#125; -打印结果12Computer&#123;mBoard=&apos;huashuo&apos;, mDisplay=&apos;sanxing&apos;, mOS=&apos;macOS&apos;&#125;Computer&#123;mBoard=&apos;weixing&apos;, mDisplay=&apos;dell&apos;, mOS=&apos;macOS&apos;&#125; Android源码中的Builder模式实现我们在构建对话框的时候通常都是以下的用法：1234567891011121314151617181920212223242526private void showDialog(final Context context) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.mipmap.ic_launcher) .setTitle(&quot;标题&quot;) .setMessage(&quot;哈哈哈的信息&quot;) .setPositiveButton(&quot;按钮1&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(context,&quot;点了按钮1&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;) .setNegativeButton(&quot;按钮2&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(context,&quot;点了按钮2&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;) .setNeutralButton(&quot;按钮3&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(context,&quot;点了按钮3&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); AlertDialog alertDialog = builder.create(); alertDialog.show(); &#125; 可以看出AlertDialog就是通过AlertDialog.Builder来构建的。 AlertDialog源码：看着源码来分析 创建AlertDialog1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class AlertDialog extends Dialog implements DialogInterface &#123; //留意这个变量 private AlertController mAlert; //不公开构造方法，外部无法直接实例化 protected AlertDialog(Context context) &#123; this(context, 0); &#125; //......省略 AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); //初始化mAlert mAlert = AlertController.create(getContext(), this, getWindow()); &#125; @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; public void setCustomTitle(View customTitleView) &#123; mAlert.setCustomTitle(customTitleView); &#125; //......省略很多这样的代码 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mAlert.installContent(); &#125;//......省略代码 //这个是AlertDialog的内部类 AlertDialog.Builder public static class Builder &#123; //这里面有一个AlertController.AlertParams， P private final AlertController.AlertParams P; public Builder(Context context, int themeResId) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); &#125;//......省略代码 public Context getContext() &#123; return P.mContext; &#125; public Builder setTitle(@StringRes int titleId) &#123; P.mTitle = P.mContext.getText(titleId); return this; &#125;//......省略很多这样的代码 public AlertDialog create() &#123; // 这里创建了一个AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); //通过这个方法，把P中的变量传给AlertDialog的mAlert。 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; //显示Dialog public AlertDialog show() &#123; final AlertDialog dialog = create(); dialog.show(); return dialog; &#125; &#125;&#125; 在源码中可以看出，我们通过builder的各种setxxx方法设置一些属性的时候，builder吧这些设置都存在一个变量P中，这个P在Builder创建时在构造方法中初始化，类型是AlertController.AlertParams，是AlertController的内部类。 然后在Builder的create方法中，new一个新的AlertDialog，并在AlertDialog的构造方法中初始化了AlertDialog的变量mAlert，类型是AlertController。调用P.apply(mAlert)方法把P中保存的参数传递给AlertDialog的变量mAlert。最后返回这个生成的AlertDialog。看一下这个方法：1234567891011121314151617181920package com.android.internal.app;public class AlertController &#123; public static class AlertParams &#123; public void apply(AlertController dialog) &#123;//基本上所有的方法都是把自己的参数设置给传进来的dialog。 if (mCustomTitleView != null) &#123; dialog.setCustomTitle(mCustomTitleView); &#125; else &#123; if (mTitle != null) &#123; dialog.setTitle(mTitle); &#125; ...... &#125; if (mMessage != null) &#123; dialog.setMessage(mMessage); &#125; ...... &#125; &#125;&#125; 显示AlertDialog在上面的使用例子中可以看出，获取到Dialog后，直接调用alertDialog.show()就能显示AlertDialog了。123456789101112131415161718192021222324252627282930313233343536373839404142434445package android.app;public class Dialog implements DialogInterface, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, Window.OnWindowDismissedCallback &#123; public void show() &#123;//如果已经显示，就直接return if (mShowing) &#123; if (mDecor != null) &#123; if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123; mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); &#125; mDecor.setVisibility(View.VISIBLE); &#125; return; &#125; mCanceled = false;//如果没有创建，就执行Dialog的onCreate方法 if (!mCreated) &#123; dispatchOnCreate(null); &#125; else &#123; // Fill the DecorView in on any configuration changes that // may have occured while it was removed from the WindowManager. final Configuration config = mContext.getResources().getConfiguration(); mWindow.getDecorView().dispatchConfigurationChanged(config); &#125; onStart();//获取DecorView mDecor = mWindow.getDecorView(); ......//获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) &#123; WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; &#125;//将DecorView和布局参数添加到WindowManager中 mWindowManager.addView(mDecor, l); mShowing = true;//向Handler发送一个Dialog的消息，从而显示AlertDialog sendShowMessage(); &#125;&#125; 简单分析一下这个方法的主要流程就是：（1）先确认AlertDialog的onCreate方法是否执行，如果没有执行就调用dispatchOnCreate(null)方法来调用AlertDialog的onCreate方法。（2）调用Dialog的onStart()方法。（3）将设置好的DecorView添加到WindowManager中。 在AlertDialog的onCreate方法中只有两行代码：12345@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mAlert.installContent(); &#125; mAlert就是AlertDialog的AlertController类型的变量。12345678910package com.android.internal.app;public class AlertController &#123; public void installContent() &#123;//获取相应的对话框内容的布局 int contentView = selectContentView();//将布局调用Window.setContentView设置布局。 mWindow.setContentView(contentView); setupView(); &#125;&#125; 分析LayoutInflater时就知道，Activity的setContentView最后也是调用了Window.setContentView这个方法。所以这个方法里主要就是给对话框设置布局。12345678910private int selectContentView() &#123; if (mButtonPanelSideLayout == 0) &#123; return mAlertDialogLayout; &#125; if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) &#123; return mButtonPanelSideLayout; &#125; // TODO: use layout hint side for long messages/lists return mAlertDialogLayout; &#125; 看到通过selectContentView()获得的布局是mAlertDialogLayout，那么这个布局是什么时候初始化的呢？在AlertController的构造方法中可以看见：12345678910111213141516171819 protected AlertController(Context context, DialogInterface di, Window window) &#123; mContext = context; mDialogInterface = di; mWindow = window; mHandler = new ButtonHandler(di); final TypedArray a = context.obtainStyledAttributes(null, R.styleable.AlertDialog, R.attr.alertDialogStyle, 0);//这里可以看处mAlertDialogLayout的布局文件是R.layout.alert_dialog文件。 mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); ...... mShowTitle = a.getBoolean(R.styleable.AlertDialog_showTitle, true); a.recycle(); /* 因为用自定义的标题栏，所以要隐藏DecorView的Title布局 */ window.requestFeature(Window.FEATURE_NO_TITLE); &#125; 好，来看一下布局文件，也就是alert_dialog.xml默认的布局是这样的，本来文件中是空白的，为了能看出来，我给布局设置了一些值和背景色：源代码贴出来，可以自己试试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133alert_dialog.xml&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/parentPanel&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:paddingTop=&quot;9dip&quot; android:paddingBottom=&quot;3dip&quot; android:paddingStart=&quot;3dip&quot; android:paddingEnd=&quot;1dip&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/topPanel&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:minHeight=&quot;54dip&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/title_template&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;center_vertical&quot; android:layout_marginTop=&quot;6dip&quot; android:layout_marginBottom=&quot;9dip&quot; android:layout_marginStart=&quot;10dip&quot; android:layout_marginEnd=&quot;10dip&quot;&gt; &lt;ImageView android:id=&quot;@+id/icon&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;top&quot; android:paddingTop=&quot;6dip&quot; android:paddingEnd=&quot;10dip&quot; android:src=&quot;@drawable/ic_dialog_info&quot; /&gt; &lt;com.android.internal.widget.DialogTitle android:id=&quot;@+id/alertTitle&quot; style=&quot;?android:attr/textAppearanceLarge&quot; android:singleLine=&quot;true&quot; android:ellipsize=&quot;end&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textAlignment=&quot;viewStart&quot; /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/titleDivider&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dip&quot; android:visibility=&quot;gone&quot; android:scaleType=&quot;fitXY&quot; android:gravity=&quot;fill_horizontal&quot; android:src=&quot;@android:drawable/divider_horizontal_dark&quot; /&gt; &lt;!-- If the client uses a customTitle, it will be added here. --&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/contentPanel&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ScrollView android:id=&quot;@+id/scrollView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingTop=&quot;2dip&quot; android:paddingBottom=&quot;12dip&quot; android:paddingStart=&quot;14dip&quot; android:paddingEnd=&quot;10dip&quot; android:overScrollMode=&quot;ifContentScrolls&quot;&gt; &lt;TextView android:id=&quot;@+id/message&quot; style=&quot;?android:attr/textAppearanceMedium&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;5dip&quot; /&gt; &lt;/ScrollView&gt; &lt;/LinearLayout&gt; &lt;FrameLayout android:id=&quot;@+id/customPanel&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot;&gt; &lt;FrameLayout android:id=&quot;@+android:id/custom&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingTop=&quot;5dip&quot; android:paddingBottom=&quot;5dip&quot; /&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:id=&quot;@+id/buttonPanel&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:minHeight=&quot;54dip&quot; android:orientation=&quot;vertical&quot; &gt; &lt;LinearLayout style=&quot;?android:attr/buttonBarStyle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:paddingTop=&quot;4dip&quot; android:paddingStart=&quot;2dip&quot; android:paddingEnd=&quot;2dip&quot; android:measureWithLargestChild=&quot;true&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/leftSpacer&quot; android:layout_weight=&quot;0.25&quot; android:layout_width=&quot;0dip&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:visibility=&quot;gone&quot; /&gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;0dip&quot; android:layout_gravity=&quot;start&quot; android:layout_weight=&quot;1&quot; style=&quot;?android:attr/buttonBarButtonStyle&quot; android:maxLines=&quot;2&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;0dip&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_weight=&quot;1&quot; style=&quot;?android:attr/buttonBarButtonStyle&quot; android:maxLines=&quot;2&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;0dip&quot; android:layout_gravity=&quot;end&quot; android:layout_weight=&quot;1&quot; style=&quot;?android:attr/buttonBarButtonStyle&quot; android:maxLines=&quot;2&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;LinearLayout android:id=&quot;@+id/rightSpacer&quot; android:layout_width=&quot;0dip&quot; android:layout_weight=&quot;0.25&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:visibility=&quot;gone&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 回到AlertController的installContent()方法中，看下一行代码setupView();123456789101112131415161718192021222324252627282930private void setupView() &#123;//获取alert_dialog.xml中的布局 final View parentPanel = mWindow.findViewById(R.id.parentPanel); final View defaultTopPanel = parentPanel.findViewById(R.id.topPanel); ...... // 这里看有没有设置自定义布局 final ViewGroup customPanel = (ViewGroup) parentPanel.findViewById(R.id.customPanel); setupCustomContent(customPanel);........ //根据传入的参数来设置布局里面的View的显示或隐藏 if (!hasButtonPanel) &#123; if (contentPanel != null) &#123; final View spacer = contentPanel.findViewById(R.id.textSpacerNoButtons); if (spacer != null) &#123; spacer.setVisibility(View.VISIBLE); &#125; &#125; mWindow.setCloseOnTouchOutsideIfNotSet(true); &#125;......... final TypedArray a = mContext.obtainStyledAttributes( null, R.styleable.AlertDialog, R.attr.alertDialogStyle, 0);//所有的布局设置为背景 setBackground(a, topPanel, contentPanel, customPanel, buttonPanel, hasTopPanel, hasCustomPanel, hasButtonPanel); a.recycle(); &#125; 所以setupView的流程就是：（1）初始化AlertDialog布局中的各个部分（2）布局全部设置完毕后，又通过Window对象关联到DecorView。并将DecorView添加到用户窗口上显示出来。 总结优点 良好的封装性，使用Builder模式可以使客户端不必知道产品的内部组成的细节 builder独立，容易扩展缺点 会产生多余的Builder对象以及Director对象（用的不多），消耗内存","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（一）续：LayoutInflater","date":"2017-03-30T12:46:07.000Z","path":"2017/03/30/Android设计模式（一）续：LayoutInflater/","text":"PhoneLayoutInflater 12345678910111213package android.view;public abstract class LayoutInflater &#123;...... public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(&quot;LayoutInflater not found.&quot;); &#125; return LayoutInflater; &#125;......&#125; 博客地址很明显这是一个抽象类，那么肯定有一个具体的实现类。通过上一篇的注册服务的时候的方法中可以看到，：123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); 最终真正注册的是PhoneLayoutInflater类。这个类的完整代码就很少12345678910111213141516171819202122232425262728293031323334package com.android.internal.policy;public class PhoneLayoutInflater extends LayoutInflater &#123; private static final String[] sClassPrefixList = &#123; &quot;android.widget.&quot;, &quot;android.webkit.&quot;, &quot;android.app.&quot; &#125;; public PhoneLayoutInflater(Context context) &#123; super(context); &#125; protected PhoneLayoutInflater(LayoutInflater original, Context newContext) &#123; super(original, newContext); &#125;//主要就重写了这个方法 @Override protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; for (String prefix : sClassPrefixList) &#123; try &#123; View view = createView(name, prefix, attrs); if (view != null) &#123; return view; &#125; &#125; catch (ClassNotFoundException e) &#123; // In this case we want to let the base class take a crack // at it. &#125; &#125; return super.onCreateView(name, attrs); &#125; public LayoutInflater cloneInContext(Context newContext) &#123; return new PhoneLayoutInflater(this, newContext); &#125;&#125; onCreateView方法中调用的是LayoutInflater类中的createView(String name, String prefix, AttributeSet attrs)方法。主要就是把&quot;android.widget.&quot;, &quot;android.webkit.&quot;, &quot;android.app.&quot;三个参数依次传进去。他的作用就是在传进来的view前面加上前缀，例如，把Button变成android.widget.Button，然后根据这个完整的路径来创建相应的View类。 这也就是这也就是我们在布局文件中用系统的控件不需要写完整的包名，而自定义控件和support包中的必须写完整的包名。因为系统的控件会在这里补全完整包名。 那么布局文件xml是怎么和LayoutInflater联系起来的呢？那就从头开始说了。布局文件使用的第一步就是在activity中调用setContentView(R.layout.activity_main)看一下Activity的源码：123456789101112package android.app;public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback &#123;。。。 public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125;&#125; getWindow()获取的是Window类。 先大致看一下Activity的界面架构图： 每个Activity都包含一个Window，通常都是PhoneWindow。PhoneWindow将一个DecorView设置为整个窗口的根View。DecorView分为两部分，其中一部分就是我们设置的ContentView。PhoneWindow通过setContentView把布局设置给DecorView的ContentView。 看前面的代码，getWindow().setContentView(layoutResID);;getWindow()获取的是一个Window，mWindow。 mWindow在Activity的attach()方法中初始化，这是Activity创建后执行的第一个方法,123456789101112131415final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); ......//初始化Window，就是PhoneWindow mWindow = new PhoneWindow(this, window); ...... mWindow.getLayoutInflater().setPrivateFactory(this); ...... &#125; 然后看PhoneWindow的setContentView方法：123456789101112131415161718192021222324252627282930313233public class PhoneWindow extends Window implements MenuBuilder.Callback &#123;...... public PhoneWindow(Context context) &#123; super(context);//构造方法中通过单例获取LayoutInflater mLayoutInflater = LayoutInflater.from(context); &#125;...... public void setContentView(int layoutResID) &#123;//mContentParent就是PhoneWindow的根布局DecorView，当DecorView为空时先创建。不等于空就移除原来所有的View。 if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123;//这里就用到了LayoutInflater来加载布局。 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125;......&#125; 进入LayoutInflater.inflate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package android.view;public abstract class LayoutInflater &#123; public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; ......//第三个参数表示是否添加到父View上，//PhoneWindow调用时传的就是DecorView，必定不为空，所以这个值为TRUE。 public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); &#125; final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125;......//第一个参数是XML解析器，解析的是布局文件。//第二个参数是要解析的布局的父布局，//第三个参数是是否把解析的布局加到父布局上 public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // 寻找根节点 root int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); &#125; final String name = parser.getName(); ...... //是merge标签单独处理 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; //递归生成View rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // 不是merge标签就调用createViewFromTag直接解析布局 final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; ...... // 生成布局参数 params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; //如果不绑定到父视图的话，就将参数设置给temp temp.setLayoutParams(params); &#125; &#125;......//解析布局的所有子View，里面也是调用rInflate方法。 rInflateChildren(parser, temp, attrs, true);...... // 如果绑定到父视图的话就把temp添加到父视图上 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // 如果不绑定到父视图的话就直接返回temp if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; ...... &#125; return result; &#125; &#125; &#125; 这里用到了递归，采用深度优先遍历，所以如果布局层次过多的话效率就会很低。分析一下过程：（1）解析布局文件的根元素（2）如果根元素是merge，就直接调用rInflate进行解析，rInflate会将merge标签下的所有子View直接添加到跟标签中。（3）如果是普通标签，就调用createViewFromTag对元素进行解析。（4）然后调用rInflate方法递归根元素的所有子元素，生成View加载temp下.（5）返回解析的根视图。 所以解析单个元素就是用下面这个createViewFromTag的方法了：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(&quot;view&quot;)) &#123; name = attrs.getAttributeValue(null, &quot;class&quot;); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; if (name.equals(TAG_1995)) &#123; // Let&apos;s party like it&apos;s 1995! return new BlinkLayout(context, attrs); &#125; try &#123; View view;//如果是用其他的LayoutInflate创建的LayoutInflate，就用之前的那个onCreateView方法 if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125;//全新的LayoutInflate if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123;//名字中不包含“.”，类似 &lt;Button&gt; 说明是系统控件，根据 if (-1 == name.indexOf(&apos;.&apos;)) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123;//说明是自定义控件 类似 &lt;com.xxx.xxx.MyView&gt; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; &#125; 最终还是调用createView方法12345678910111213141516171819202122232425262728293031323334353637383940414243public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); if (constructor == null) &#123; // 找不到缓存的构造方法，如果传入的第二个参数prefix为null，就说明name是完整的包名，是自定义控件，直接反射加载自定义View。//如果第二个参数不为 null，就由PhoneLayoutInflate加上前缀组成完整的类名。 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true);//将构造方法存入缓存 sConstructorMap.put(name, constructor); &#125;......//生成View final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123;//如果是ViewStub就延迟加载 final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; catch (NoSuchMethodException e) &#123; ...... &#125; &#125; 总结LayoutInflater的工作过程就是， 先获取系统的LayoutInflater服务， 然后解析传入的布局文件xml,用深度优先遍历每一个节点，根据每个节点的名称生成对应的View并加载到父布局， 整个树加载完成后就形成一个最终的View返回出来，完成布局解析。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式（一）-单例模式","date":"2017-03-30T12:45:18.000Z","path":"2017/03/30/Android设计模式（一）-单例模式/","text":"博客地址最近在看《Android源码设计模式解析与实战》这本书，发现里面还有对源码的一些分析，之前也没好好看过设计模式，就来做个笔记，跟着看一下。包括设计模式和一些源码分析。 定义确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景需要确保一个类只有一个实例的场景，避免产生多个对象小号过多的资源，或者是这个类只应该有一个实例。比如创建一个对象要消耗的资源过多,或者要访问IO和数据库等资源.配置文件,工具类,线程池,缓存,日志对象等。 UML类图角色介绍： . Client——高层客户端. Singleton——单例类 实现单例模式的关键点： 构造函数不对外开放，一般为Private。就是不允许外部通过new Singleton()来获取对象。 通过一个静态方法或枚举返回单例类对象，如getInstance()方法。 确保单例类的对象只有一个，尤其是在多线程的情况下。确保即使在多线程也能实现单例。 确保单例类对象在反序列化时不会重新构建对象。 实现方式饿汉式1234567public class Singleton &#123; private static final Singleton mSingleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return mSingleton; &#125;&#125; 里面的对象是个静态对象，第一次声明的时候就会实现初始化。外部只能通过getInstance()获取到这个对象，实现单例。 懒汉式12345678910public class Singleton &#123; private static Singleton mSingleton ; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if (mSingleton==null)&#123; mSingleton=new Singleton(); &#125; return mSingleton; &#125;&#125; 这里的getInstance()方法加上了synchronized关键字，保证了多线程也能实现单例。 优点：单例只有在使用时才会被实例化，一定程度上节约了资源。缺点：（1）单例在第一次加载时要及时进行实例化，反应稍慢（2）每次调用getInstance()都要进行同步，造成不必要的同步开销。 所以一般不建议用。 Double Check Lock（DCL）双重检查锁1234567891011121314public class Singleton &#123; private static Singleton mSingleton ; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if (mSingleton==null)&#123; synchronized (Singleton.class)&#123; if (mSingleton==null)&#123; mSingleton=new Singleton(); &#125; &#125; &#125; return mSingleton; &#125;&#125; 这个getInstance方法中对mSingleton进行了两次判空：第一次是为了避免不必要的同步锁；第二层是为了在null的时候创建实例。DCL失效：在多线程下，假设A线程执行到mSingleton=new Singleton()的时候，CPU并不是一次性执行完这条语句的，因为这不是一个原子操作（指不会被线程调度机制打断的操作）。举个例子：执行 Timer timer = new Timer(); 通过字节码文件可以看到这一行代码编译出来是这样的：123450: new #2 // class java/util/Timer3: dup4: invokespecial #3 // Method java/util/Timer.&quot;&lt;init&gt;&quot;:()V7: astore_18: return 所以mSingleton=new Singleton()大致做了三件事：（1）给Singleton的实例分配内存（2）调用Singleton的构造方法（3）将mSingleton指向分配的内存空间（这个时候mSingleton才不为空）由于Java编译器允许处理器乱序执行，所以上面的第二步第三步的执行顺序没法得到保证。执行顺序可能是1-2-3也可能是1-3-2。当A线程执行顺序是1-3-2的时候，如果执行到了1-3，第2步还没执行的时候，如果B线程判断mSingleton==null的时候就会的发哦FALSE的结果，从而返回一个错误的单例。 优点：资源利用率高，第一次执行getInstance的时候才会被实例化，效率高。缺点：第一册加载反应稍慢，而且有失败的可能，但是概率很小。 这种是用的最多的单例实现方式，大部分情况下都能保证单例。 静态内部类123456789public class Singleton &#123; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.mSingleton; &#125; private static class SingletonHolder&#123; private static final Singleton mSingleton = new Singleton(); &#125;&#125; 当第一次加载Singleton的时候并不会初始化mSingleton，只有在第一次调用getInstance的时候才会加载SIngletonHolder类。优点：不仅能保证线程安全，也能保证单例的唯一性，也延迟了单例的实例化，比较推荐。 枚举单例123456public enum Singleton&#123; INSTANCE; public void doThing()&#123; System.out.println(this.hashCode()); &#125;&#125; 使用时可以通过Singleton singleton = Singleton.INSTANCE;来获取单例。优点：写法简单，而且默认线程安全，任何情况下都是一个单例。 特点：上面的几种在有一种情况下会单例失效，出现重复创建对象，那就是反序列化。反序列化的时候会调用一个readResolve()方法重新生成一个实例，所以上面的几种方式要解决这个问题需要加入以下方法，：12345678910111213public class Singleton &#123; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.mSingleton; &#125; private static class SingletonHolder&#123; private static final Singleton mSingleton = new Singleton(); &#125; private Object readRedolve() throws ObjectStreamException&#123; return SingletonHolder.mSingleton; &#125;&#125; 使用容器实现单例123456789101112public class SingletonManager &#123; private static Map&lt;String,Objects&gt; objMap = new HashMap&lt;&gt;(); private SingletonManager()&#123;&#125; public static void registerService(String key,Object obj)&#123; if (!objMap.containsKey(key))&#123; objMap.put(key,obj); &#125; &#125; public static Object getService(String key)&#123; return objMap.get(key); &#125;&#125; 在程序的开始，将许多要单例的对象放到一个容器里，用的时候根据key取得对应的单例对象。 Android源码中的单例模式源码中的单例模式太多了，甚至有一个专门的单例的抽象类：123456789101112131415package android.util;public abstract class Singleton&lt;T&gt; &#123; private T mInstance; protected abstract T create(); public final T get() &#123; synchronized (this) &#123; if (mInstance == null) &#123; mInstance = create(); &#125; return mInstance; &#125; &#125;&#125; 我们经常通过context.getSystemService(String name)来获取一些系统服务，如在Activity中获取ActivityManager：1ActivityManager mActivityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); 书中举例为LayoutInflater，平时获取方式为LayoutInflater.from(context),看下这个方法：123456789package android.view;public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(&quot;LayoutInflater not found.&quot;); &#125; return LayoutInflater; &#125; 发现也是通过调用context.getSystemService(String name)获取的。 那么扎个单例是怎么实现的呢？顺着代码往上看吧。。context.getSystemService(String name)直接点进去的话会进到123456package android.content;public abstract class Context &#123;... public abstract Object getSystemService(@ServiceName @NonNull String name);...&#125; 通过分析activity的启动流程可以知道，Context的功能的具体实现是在ContextImpl.java中，看具体实现代码：123456789package android.app;class ContextImpl extends Context &#123;... @Override public Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name); &#125;&#125;... 然后继续SystemServiceRegistry.getSystemService(this, name)：123456789101112131415161718192021222324252627282930313233343536373839package android.app;final class SystemServiceRegistry &#123; ...//用来getSystemService的容器，里面存放的是ServiceFetcher&lt;?&gt;private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();...//静态代码块，第一次加载时执行，而且只会执行一次，保证了注册的服务的唯一性。 static &#123; registerService(Context.ACCESSIBILITY_SERVICE, AccessibilityManager.class, new CachedServiceFetcher&lt;AccessibilityManager&gt;() &#123; @Override public AccessibilityManager createService(ContextImpl ctx) &#123; return AccessibilityManager.getInstance(ctx); &#125;&#125;); registerService(Context.DOWNLOAD_SERVICE, DownloadManager.class, new CachedServiceFetcher&lt;DownloadManager&gt;() &#123; @Override public DownloadManager createService(ContextImpl ctx) &#123; return new DownloadManager(ctx); &#125;&#125;); ...//还有很多服务注册 &#125; ...//静态代码块中调用这个方法，把服务名和创建的服务对应放在容器中，实现单例。 private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) &#123; SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher); &#125; ... public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; &#125; ...&#125; 里面还不是直接拿到服务，而是调用了fetcher.getService(ctx)来获取服务。看看ServiceFetcher&lt;?&gt;：123static abstract interface ServiceFetcher&lt;T&gt; &#123; T getService(ContextImpl ctx); &#125; 这是个接口，看上面的静态代码块里面的方法发现注册服务的时候都是用的CachedServiceFetcher这个类：1234567891011121314151617181920212223242526272829static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123; private final int mCacheIndex; public CachedServiceFetcher() &#123; mCacheIndex = sServiceCacheSize++; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public final T getService(ContextImpl ctx) &#123;//ctx.mServiceCache是获取一个数组：new Object[sServiceCacheSize]；//数组的长度就是构造方法中的那个变量，每注册一个服务，就会new一个对应的CachedServiceFetcher，然后数组长度就+1。第一次获取到这个数组肯定是个空数组 final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; // Fetch or create the service. Object service = cache[mCacheIndex];//第一次获取这个服务的时候，数组是空的 ，所以service == null为TRUE。 if (service == null) &#123;//调用注册时实现的createService方法，把生成的具体服务放在数组对应下标中，//之后就直接从数组中获取了。实现了单例。 service = createService(ctx); cache[mCacheIndex] = service; &#125; return (T)service; &#125; &#125; // 在静态代码块中实现 public abstract T createService(ContextImpl ctx); &#125; 里面有个抽象方法，需要实例化的时候实现。在静态代码块中的方法都实现了这个createService(ContextImpl ctx)方法，并且返回了对应的服务。附上部分注册服务的截图，截不下： 总结优点： 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁创建，或者创建或销毁时性能无法优化，单例模式的优势就很明显了。 由于只生成一个实例，减少了系统性能开销。 可以避免对资源的多重占用，如文件操作等。 单例模式可以设置为全局的访问点，优化和共享资源访问。 缺点 单例模式一般没有接口，拓展很困难，基本都要修改源代码。 在Android中，如果单例模式持有Activity的Context，容易产生内存泄漏。所以尽量用ApplicationContext。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android设计模式-面向对象六大原则","date":"2017-03-30T12:44:15.000Z","path":"2017/03/30/Android设计模式-面向对象六大原则/","text":"概述最终就是 抽象 单一直则 最小化 单一职责原则(Single Responsibility Principle)简述简称SPR 一个类只做一件事. 并不是说一个类只有一个函数,而是说这个类中的所有函数必须是高度相关的.高内聚. 优点 类的复杂度降低,实现什么职责有明确的定义 可读性提高 可维护性提高 变更引起的风险降低.一个接口的修改只影响相应的实现类,对其他的接口无影响. 里氏替换原则(Liskov Substitution Principle)简述面向对象语言三大特征是封装,继承,多态. 里氏替换原则简单来说就是所有引用基类的地方必须能透明的使用其子类的对象.也就是说,只要有父类出现的地方子类就可以出现,并且用这个子类替换父类也不会产生任何错误和异常,但是反过来就不行,父类不一定能替代子类. 例如构造方法的参数是接口类型的,只要实现了这个接口的都可以调用这个构造方法创建对象 优点 代码共享减少创作类的工作量,因为每个子类都拥有父类的所有方法和属性 提高代码重用度 提高代码可扩展性,实现父类的方法就行了 提高产品和项目的开放性 缺点 继承是入侵的,只要继承就必须拥有父类的所有属性和方法 降低代码灵活性,子类必须拥有父类的所有属性的方法,对子类多了些约束 增强了耦合性,当父类的常量,变量,方法等改变时要考虑到子类的修改.搞不好大量代码需要重构. 依赖倒置原则(Dependence inversion Principle)简述 高层模块不应该依赖低层模块,两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 JAva中抽象就是指接口或抽象类,两者都不能被实例化.实现或继承他们产生的类就是细节,细节的特点是能被实例化. 模块之间的依赖通过抽象发生,实现类与实现类之间不发生直接依赖关系,他们的依赖关系是通过接口或抽象类进行的. 面向接口编程是面向对象精髓之一. 优点 可拓展性好 耦合度低 开闭原则(Open-Close Principle)简述java中最基础的设计原则,指导我们如何建立一个稳定/灵活的系统. 定义:一个软件实体,如类,模块,函数都应该对扩展开放,对修改关闭. 在软件生命周期内,迭代时尽量通过扩展的方式来实现变化,而不是通过修改执勤啊的已有代码来实现. 优点 增加稳定性 可拓展性高 接口隔离原则(Interface Segregation Principle)简述客户端不应该依赖他不需要的接口.一个类对另一个类的依赖应该建立在最小的接口上.档一个接口太大时,就要考虑分割成更小的接口.客户端进需要指导与之相关的方法即可 优点 降低耦合性 提高代码的可读性 隐藏实现细节 迪米特原则(Law of Demeter)/最少知识原则(Least Knowledge Principle)简述一个对象应该对其他对象有最少的了解. 类的内部如何实现,如何复杂都与调用者或依赖者没有关系,调用者或依赖者只需要知道他需要的方法即可. 优点 降低复杂度 降低耦合度 增加稳定性","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.miaolegewu.top/tags/设计模式/"}]},{"title":"Android文字识别tesseract ocr -训练样本库 识别字库","date":"2017-03-30T12:31:16.000Z","path":"2017/03/30/Android文字识别tesseract-ocr-训练样本库-识别字库/","text":"在上一篇文章tess_two Android图片文字识别中，使用tess_two完成了简单的文字识别。博客地址但是发现一个很明显的问题是，默认的识别速度比较慢。识别四个很明显的字需要将近两秒。DemoGitHub可以试试。tess_two用的是tesseract ocr引擎查看用到的官方提供的中文识别库chi_sim.traineddata文件有52M。里面肯定是包含了很多的训练和文字的。 我用不了那么多字，然后就按官方和网上的资料自己做了一个识别库，这个库只能识别训练过的文字。速度生成的文件应该跟训练的字数有关的，我实验了几个字，只有100多k。看看速度,快了很多。 下面大致记录一下制作训练识别库的方法。相对比较简单。 安装tesseract ocr引擎和jTessBoxEditor在官网上可以找到Window和Mac的安装方法，window的有专门的额客户端。我的是Mac，所以选的是Homebrew安装。 Homebrew 是一个包管理器，如果没装的话，在终端执行ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;就会自动装好。 单纯的安装tesseract ocr引擎是可以直接用官网的命令brew install tesseract 但是，我后面要用到训练样本的命令，所以我们要用到的安装命令是brew install --with-training-tools tesseract,否则后面一些命令会找不到。 如果初次安装用了第一个，那么可以先用brew uninstall tesseract卸载掉，然后执行brew install --with-training-tools tesseract重新安装。 装好之后，找到在上篇文章中下载的chi_sim.traineddata。 然后复制到/usr/local/Cellar/tesseract/3.05.00/share/tessdata中备用。里面已经自带了eng.traineddata。 这一步不是必须的，而且我这样好想还容易出错。 安装jTessBoxEditor这里提供了很多第三方的训练工具，我选第一个jTessBoxEditor。 jTessBoxEditor是基于java的，多以可以跨平台，下载下来在Mac和Windows上都能运行。下载下来是这样的启动jTessBoxEditor.jar就能打开客户端。 这里我有一个疑问，别人电脑上都能双击这个文件打开，而我的电脑双击一闪就没了，只能用在终端里打开。。 开始制作box准备好训练的图片：什么格式应该没关系，反正都要转化成tif格式的。 将图片转为tif格式的样本图片方法有很多，我用的在线转化。下载下来的文件是要手动吧后缀的.html去掉变成.tif文件，比较麻烦。所以不推荐用这个转换工具。。改名后 合并样本图片大家应该注意到有一个new文件夹，这个文件夹用来放之后生成的各种文件的，包括最终的traineddata文件。打开jTessBoxEditor.jar，然后点菜单上的Tool-&gt;Merge TIFF保存到new文件夹中，保存的时候注意名字sll.normal.exp0.tif关于名字 sll.normal.exp0.tif官网的写法是这样的[lang].[fontname].exp[num].tif[lang]是语言，随便起，这里的叫sll[fontname]是字体，随便起，这里叫 normal[num]我也不知道啥意思，写的是数字0这两个都是自定义的，后面会用到，所以要记住。 点击保存后，会在new文件夹中生成合并的sll.normal.exp0.tif文件然后执行命令，如果前面复制了chi_sim.traineddata文件的话用下面的1tesseract sll.normal.exp0.tif sll.normal.exp0 -l chi_sim batch.nochop makebox 否则用这个,默认的。上面那个有时候会出错没我也不知道为什么。1tesseract sll.normal.exp0.tif sll.normal.exp0 -l eng batch.nochop makebox 会在当前文件夹下生成sll.normal.exp0.box文件 修改box文件打开jTessBoxEditor.jar，点击Box Editor-&gt;open然后选上一步的tif文件，会自动打开绑定的box文件。在里面可以对他的识别区域，识别结果进行一些修改，达到我们正确的识别目的全部修改完后点击save。 用脚本生成下面的步骤可以写一个脚本自动完成。生成box文件就一行代码，就不用写了。比如，在new文件夹下创建一个gettraineddata.shell,里面写1234567891011121314151617181920212223#!/bin/shread -p &quot;输入你语言:&quot; langecho $&#123;lang&#125;read -p &quot;输入你的字体:&quot; fontecho $&#123;font&#125;echo &quot;所以完整文件名为：&quot;echo $&#123;lang&#125;.$&#123;font&#125;.exp0.tifecho &quot;开始。。。&quot;echo $&#123;font&#125; 0 0 0 0 0 &gt;font_propertiestesseract $&#123;lang&#125;.$&#123;font&#125;.exp0.tif $&#123;lang&#125;.$&#123;font&#125;.exp0 nobatch box.trainunicharset_extractor $&#123;lang&#125;.$&#123;font&#125;.exp0.boxshapeclustering -F font_properties -U unicharset $&#123;lang&#125;.$&#123;font&#125;.exp0.trmftraining -F font_properties -U unicharset -O unicharset $&#123;lang&#125;.$&#123;font&#125;.exp0.trcntraining $&#123;lang&#125;.$&#123;font&#125;.exp0.trecho &quot;开始重命名文件&quot;mv inttemp $&#123;font&#125;.inttempmv normproto $&#123;font&#125;.normprotomv pffmtable $&#123;font&#125;.pffmtablemv shapetable $&#123;font&#125;.shapetablemv unicharset $&#123;font&#125;.unicharsetecho &quot;生成最终文件&quot;combine_tessdata $&#123;font&#125;.echo &quot;完成&quot; 当然里面的东西可以改，要输入的语言和字体是根据tif文件的名字来的比如我的文件是sll.normal.exp0.tif所以就这样输入如果不出错，就能看见new里面变成了这样有了我们需要的normal.traineddata识别库。 生成font_properties在new文件夹中执行下面命令,会生成一个font_properties文件，里面的内容是normal 0 0 0 0 0 。1echo normal 0 0 0 0 0 &gt;font_properties 六个代表的东西是 fontname italic bold fixed serif fraktur像第一个是字体名，前面我起的是normal。后面的值是0或1，可以看一下默认的文件font_properties 生成接下来就是一条条命令生成一个个文件了 训练tesseract sll.normal.exp0.tif sll.normal.exp0 nobatch box.train 生成字符集文件unicharset_extractor sll.normal.exp0.box 生成shape文件shapeclustering -F font_properties -U unicharset sll.normal.exp0.tr 生成聚集字符特征文件mftraining -F font_properties -U unicharset -O unicharset sll.normal.exp0.tr 生成字符正常化特征文件cntraining sll.normal.exp0.tr 合成最终文件改名上面几步完成后，会看到下面五个文件然后全部重命名，前面加上normal. 就是字体名，变成 合并字库文件combine_tessdata normal.看 哇 拿到了我们需要的normal.traineddata文件。必须确定的是第type 1、3、4、5的数据不是-1，才算成功。然后按上一篇的方法用吧! 参考http://www.cnblogs.com/zhongtang/p/5555950.html?utm_source=tuicool&amp;utm_medium=referral参考http://www.cnblogs.com/wzben/p/5930538.html","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"文字识别","slug":"文字识别","permalink":"http://blog.miaolegewu.top/tags/文字识别/"}]},{"title":"tess_two Android图片文字识别","date":"2017-03-30T12:30:21.000Z","path":"2017/03/30/tess-two-Android图片文字识别/","text":"文字识别一般都用的tesseract-ocr。GitHub：https://github.com/tesseract-ocr/tesseract而Android对应的比较推荐的有个tess-two。GitHub：https://github.com/rmtheis/tess-twoDemo的github地址：https://github.com/wangyisll/TessTwoDemo 先看效果图我主要是识别截图，所以图片比较规范，识别率应该很高。 简介什么都不说了，直接看简单的用法吧首先肯定是引入依赖了123dependencies &#123; compile &apos;com.rmtheis:tess-two:6.2.0&apos;&#125; 简单的用法其实就几行代码：1234TessBaseAPI tessBaseAPI = new TessBaseAPI();tessBaseAPI.init(DATAPATH, DEFAULT_LANGUAGE);//参数后面有说明。tessBaseAPI.setImage(bitmap);String text = tessBaseAPI.getUTF8Text(); 就这样简单的把一个bitmap设置进去，就能识别到里面的文字并输出了。但是真正用的时候还是遇到了点麻烦，虽然只是简单的识别。主要是tessBaseAPI.init(DATAPATH, DEFAULT_LANGUAGE)这个方法容易出错。先看一下这个方法的源码吧：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean init(String datapath, String language) &#123; return init(datapath, language, OEM_DEFAULT); &#125;/** * Initializes the Tesseract engine with the specified language model(s). Returns * &lt;code&gt;true&lt;/code&gt; on success. * * @see #init(String, String) * * @param datapath the parent directory of tessdata ending in a forward * slash * @param language an ISO 639-3 string representing the language(s) * @param ocrEngineMode the OCR engine mode to be set * @return &lt;code&gt;true&lt;/code&gt; on success */ public boolean init(String datapath, String language, int ocrEngineMode) &#123; if (datapath == null) throw new IllegalArgumentException(&quot;Data path must not be null!&quot;); if (!datapath.endsWith(File.separator)) datapath += File.separator; File datapathFile = new File(datapath); if (!datapathFile.exists()) throw new IllegalArgumentException(&quot;Data path does not exist!&quot;); File tessdata = new File(datapath + &quot;tessdata&quot;); if (!tessdata.exists() || !tessdata.isDirectory()) throw new IllegalArgumentException(&quot;Data path must contain subfolder tessdata!&quot;); //noinspection deprecation if (ocrEngineMode != OEM_CUBE_ONLY) &#123; for (String languageCode : language.split(&quot;\\\\+&quot;)) &#123; if (!languageCode.startsWith(&quot;~&quot;)) &#123; File datafile = new File(tessdata + File.separator + languageCode + &quot;.traineddata&quot;); if (!datafile.exists()) throw new IllegalArgumentException(&quot;Data file not found at &quot; + datafile); &#125; &#125; &#125; boolean success = nativeInitOem(mNativeData, datapath, language, ocrEngineMode); if (success) &#123; mRecycled = false; &#125; return success; &#125; 注意从下面的方法中抛出的几个异常可以看出来，初始化的时候，第一个参数是个文件夹，而且这个文件夹中必须有一个tessdata的文件夹；而且这个文件夹中要有个文件叫做 第二个参数.traineddata 。具体的可以看下面代码里的注释。这些文件夹和文件没有的一定要创建好，不然会报错。 第二个参数.traineddata 是个什么文件呢？这个是识别用到的语言库还是文字库什么的，按那个初始化方法的意思是哟啊放到SD卡中的。可以在下面的地址下载。我的demo里把这个文件放在了assets中，启动的时候复制到内存卡里。https://github.com/tesseract-ocr/tessdata chi_sim.traineddata应该是健体中文吧，我用的是这个。中英文都能识别。 代码下面是主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import android.Manifest;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.support.annotation.NonNull;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import com.googlecode.tesseract.android.TessBaseAPI;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class MainActivity extends AppCompatActivity &#123; private static final String TAG = &quot;MainActivity&quot;; private Button btn; private TextView tv; /** * TessBaseAPI初始化用到的第一个参数，是个目录。 */ private static final String DATAPATH = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator; /** * 在DATAPATH中新建这个目录，TessBaseAPI初始化要求必须有这个目录。 */ private static final String tessdata = DATAPATH + File.separator + &quot;tessdata&quot;; /** * TessBaseAPI初始化测第二个参数，就是识别库的名字不要后缀名。 */ private static final String DEFAULT_LANGUAGE = &quot;chi_sim&quot;; /** * assets中的文件名 */ private static final String DEFAULT_LANGUAGE_NAME = DEFAULT_LANGUAGE + &quot;.traineddata&quot;; /** * 保存到SD卡中的完整文件名 */ private static final String LANGUAGE_PATH = tessdata + File.separator + DEFAULT_LANGUAGE_NAME; /** * 权限请求值 */ private static final int PERMISSION_REQUEST_CODE=0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn = (Button) findViewById(R.id.btn); tv = (TextView) findViewById(R.id.tv); if (Build.VERSION.SDK_INT &gt;= 23) &#123; if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED || checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; requestPermissions(new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); &#125; &#125; //Android6.0之前安装时就能复制，6.0之后要先请求权限，所以6.0以上的这个方法无用。 copyToSD(LANGUAGE_PATH, DEFAULT_LANGUAGE_NAME); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Log.i(TAG, &quot;run: kaishi &quot; + System.currentTimeMillis()); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.quanbu); Log.i(TAG, &quot;run: bitmap &quot; + System.currentTimeMillis()); TessBaseAPI tessBaseAPI = new TessBaseAPI(); tessBaseAPI.init(DATAPATH, DEFAULT_LANGUAGE); tessBaseAPI.setImage(bitmap); final String text = tessBaseAPI.getUTF8Text(); Log.i(TAG, &quot;run: text &quot; + System.currentTimeMillis() + text); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; tv.setText(text); &#125; &#125;); tessBaseAPI.end(); &#125; &#125;).start(); &#125; &#125;); &#125; /** * 将assets中的识别库复制到SD卡中 * @param path 要存放在SD卡中的 完整的文件名。这里是&quot;/storage/emulated/0//tessdata/chi_sim.traineddata&quot; * @param name assets中的文件名 这里是 &quot;chi_sim.traineddata&quot; */ public void copyToSD(String path, String name) &#123; Log.i(TAG, &quot;copyToSD: &quot;+path); Log.i(TAG, &quot;copyToSD: &quot;+name); //如果存在就删掉 File f = new File(path); if (f.exists())&#123; f.delete(); &#125; if (!f.exists())&#123; File p = new File(f.getParent()); if (!p.exists())&#123; p.mkdirs(); &#125; try &#123; f.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; InputStream is=null; OutputStream os=null; try &#123; is = this.getAssets().open(name); File file = new File(path); os = new FileOutputStream(file); byte[] bytes = new byte[2048]; int len = 0; while ((len = is.read(bytes)) != -1) &#123; os.write(bytes, 0, len); &#125; os.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (is != null) is.close(); if (os != null) os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 请求到权限后在这里复制识别库 * @param requestCode * @param permissions * @param grantResults */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; Log.i(TAG, &quot;onRequestPermissionsResult: &quot;+grantResults[0]); switch (requestCode)&#123; case PERMISSION_REQUEST_CODE: if (grantResults.length&gt;0&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; Log.i(TAG, &quot;onRequestPermissionsResult: copy&quot;); copyToSD(LANGUAGE_PATH, DEFAULT_LANGUAGE_NAME); &#125; break; default: break; &#125; &#125;&#125; demo下载地址http://download.csdn.net/detail/qq_25806863/9783651","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"文字识别","slug":"文字识别","permalink":"http://blog.miaolegewu.top/tags/文字识别/"}]},{"title":"Android制作library时省去application的初始化","date":"2017-03-30T12:29:11.000Z","path":"2017/03/30/Android制作library时省去application的初始化/","text":"来自 Android Debug Databasehttp://blog.csdn.net/qq_25806863/article/details/62216763 问题在使用Android Debug Database的时候，我发现仅仅是加一行引用就行了1debugCompile &apos;com.amitshekhar.android:debug-db:1.0.0&apos; 代码中没有写一点点关于这个库的代码。自定义控件那种就不说了，用到的时候肯定会调用的。而一些工具库最起码也要在Application的onCreate()方法中写一行代码什么的，需要配置一些id的这样还可以，l例如微信这些。还有些就仅仅是依据初始化：1234567891011121314public class DemoApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this);//像这样的。 APICloud.initialize(this); //微信 appid appsecret PlatformConfig.setWeixin(&quot;wxbe344a7447dcf578f&quot;, &quot;df0e35026180c930e30335436e149c7b6&quot;); api = WXAPIFactory.createWXAPI(getApplicationContext(), &quot;wxbe4d346a747d4f4578f&quot;); api.registerApp(&quot;wxb34a747dc43f578f&quot;); &#125;&#125; 发现我就好奇Android Debug Database是怎么做的了。看源码的时候发现，Android Debug Database里面写了一个内容提供者DebugDBInitProvider。代码很简单，觉得在写library的时候有时可以用下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DebugDBInitProvider extends ContentProvider &#123; public DebugDBInitProvider() &#123; &#125; @Override public boolean onCreate() &#123; Log.i(TAG, &quot;onCreate: DebugDBInitProvider&quot;); DebugDB.initialize(getContext()); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return null; &#125; @Override public String getType(Uri uri) &#123; return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; return null; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public void attachInfo(Context context, ProviderInfo providerInfo) &#123; if (providerInfo == null) &#123; throw new NullPointerException(&quot;DebugDBInitProvider ProviderInfo cannot be null.&quot;); &#125; // So if the authorities equal the library internal ones, the developer forgot to set his applicationId if (&quot;com.amitshekhar.DebugDBInitProvider&quot;.equals(providerInfo.authority)) &#123; throw new IllegalStateException(&quot;Incorrect provider authority in manifest. Most likely due to a &quot; + &quot;missing applicationId variable in application\\&apos;s build.gradle.&quot;); &#125; super.attachInfo(context, providerInfo); &#125;&#125; 这个provider几乎就是个空的，只是在onCreate()方法中执行了一下DebugDB.initialize(getContext());而这个方法就是这个类库的入口。为什么要写成这样的呢？ 把这行代码注释掉，然后在自己的Application中写上，能达到一样的效果：12345678public class App extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); DebugDB.initialize(getApplicationContext()); Log.i(TAG, &quot;onCreate: Application&quot;); &#125;&#125; 结果个人认为这个provider的作用就是方便其他人使用这个类库。不需要集成Application，不需要写那行列代码。 原因就是provider的onCreate()会在application的onCreate()之前执行，。。。不知道理解有没有错：","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"}]},{"title":"Android Debug Database 一个好用的Android数据库调试查看工具","date":"2017-03-30T12:28:13.000Z","path":"2017/03/30/Android-Debug-Database-一个好用的Android数据库调试查看工具/","text":"平时要查看手机数据库内容就很麻烦了，就算把db文件下载到电脑上了，还需要下载专门的数据库工具来查看。而且每次修改数据库都需要重新下载，很麻烦。然后今天发现了Android Debug Database，githud地址：https://github.com/amitshekhariitbhu/Android-Debug-Database #先看看他有什么功能吧： 直接查看手机该app的数据库和shared preference. 可以直接修改数据库和shared preference的值，立即生效。修改配置文件什么的特方便，真的立即生效。 可以直接搜索数据库内容。 可以直接执行sql语句 可以直接下载db数据库文件 直接排序 先看两张界面图吧； 数据库的： 共享参数的： #好了 下面说收使用吧 添加依赖项 在app的build.gradle添加 123dependencies &#123; debugCompile &apos;com.amitshekhar.android:debug-db:1.0.0&apos;&#125; 最好是用debugCompile，只在debug时可以查看。然后当你运行APP启动的时候，在日志中会看见这一行： 真机访问（手机和电脑必须在同一个局域网上）点击那个地址就可以直接访问了，也能在浏览器中手动输入。默认地址是手机IP:8080如 手机ip是 192.2.2.2 那么默认的地址就是 192.2.2.2：8080； 模拟器访问还有一种方式是针对虚拟机的，不过对真机也有效，就是浏览器访问localhost:8080;这样访问有一个前提条件，要先执行一下adb forward tcp:8080 tcp:8080 命令. 修改端口号 如果不用默认的8080端口号，可以自己指定。 在app的build.gradle中 12345678910111213141516171819202122android &#123; compileSdkVersion 25 buildToolsVersion &quot;25.0.2&quot; defaultConfig &#123; applicationId &quot;&quot; minSdkVersion 21 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; debug &#123; //这里 resValue(&quot;string&quot;, &quot;PORT_NUMBER&quot;, &quot;8088&quot;) &#125; &#125;&#125; 这样修改之后，上面的所以得8080都要改成对应的新端口号，如：192.2.2.2：8088localhost:8088adb forward tcp:8088 tcp:8088","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://blog.miaolegewu.top/tags/工具/"}]},{"title":"用ADB将Android日志输出到电脑文件，并查看","date":"2017-03-30T12:27:14.000Z","path":"2017/03/30/用ADB将Android日志输出到电脑文件，并查看/","text":"有时候需要把运行日志保存下来，在IDE上直接看一不小心之前的日志就不见了。 配好环境变量后就可以在cmd中使用adb命令了。打印日志命令是adb logcat 如果连接有多个设备的话，先用adb devices找到要打印的设备的名字，然后在logcat钱加上 -s 名字 ，这样就会打印指定设备的日志，不然会报存在多个设备的错误。有多个设备下的adb命令都要这样指定设备名。 使用下面的命令输出日志到文件，需要指定输出格式可以在logcat后加 -v * ,后面是指定的输出格式 加上格式输出就是这样的，这样会吧设备的所有日志包括系统日志输出到文件里，非常多。如果需要输出指定的TAG或线程可以试试指定TAG或线程，我这个全打出来，格式是加上了 时间和线程id，全打出来也可以过滤查看的，还比较方便。 对应文件夹就会出现一个日志文件，这个文件是不断增加的，包含了所有的日志。下面用logViewPro查看日志。自行搜索下载，很小 打开后这个日志文件也是不断更新的，只要输出到文件的命令没有中断。 可以在 编辑-过滤日志 中将过滤后的日志输出到新文件中查看，源文件继续监听不影响。例如搜索带ServiceDemo的日志。 过滤后的日志就是这样的 可以在选项–颜色过滤器中修改日志查看 最后不停过滤，搜索，全部日志斗鱼，看什么都行。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.miaolegewu.top/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://blog.miaolegewu.top/tags/工具/"}]},{"title":"上网 无限流量的 蓝 灯","date":"2017-03-30T12:19:57.000Z","path":"2017/03/30/上网-无限流量的-蓝-灯/","text":"· 本文过程完全参考http://www.jianshu.com/p/a4ace010aa83只是把自己编译的过程记录下来了。 下载地址 http://download.csdn.net/detail/qq_25806863/9778909· 现在官 网直接下载的lantern分为免费版和专业版，对于需要翻墙的来说，免费版的800M总是在几天都用完了。网上找到这样一篇文章，说自己编译出来的可以不限流量。 · 编译出来的lantern打开后显示的是老版的还没开始收费的lantern网页。 · 用这个lantern ，AndroidStudio中的代理还是设置为127.0.0.1：8787. · 只是我编译的结果和大神的不太一样，我也不懂为什么。大神编译出来了app文件，而我编译出来了个这东西，不知道是没找到编译出来的app文件还是哪里过程出错了。也能用，就是用的时候会一直有一个终端运行着。不知道怎么能编译出APP文件。有没有人能按过程编译出来app。。。 大神的文章中有他编译好的app文件的下载地址。但是大神这个app的lantern每次打开都会打开一个ManotoTv的网页，不影响使用。 1. 装了文章中安利的 homebrew。 打开终端，复制粘贴以下命令就OK，中间可能需要输一次密码： 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2. 找个地方把lantern从GitHub上clone下来1git clone --depth=1 https://github.com/getlantern/lantern.git 3. 在同一个终端中 装go、node、gulp、appdmg、svgexport一堆12345brew install gobrew install nodenpm i gulp-cli -gnpm install -g appdmgnpm install -g svgexport 4. 编译Mac版lantern123cd lanternexport VERSION=9.9.9make darwin 编译的时候可能会出现两个错误，原因文章中有说明在lantern文件夹对应路径中找到红框中四处，把MaxIdleTime改为IdleConnTimeout，然后把下面紧接的调用EnforceMaxIdleTime()这个方法的语句注释掉。就改这两个文件中的4行就行。重新编译。 然后结果就是我生成你那鬼玩意儿，也能用，没搞出来app应用程序文件。先这样。","tags":[{"name":"工具","slug":"工具","permalink":"http://blog.miaolegewu.top/tags/工具/"},{"name":"翻墙","slug":"翻墙","permalink":"http://blog.miaolegewu.top/tags/翻墙/"}]}]